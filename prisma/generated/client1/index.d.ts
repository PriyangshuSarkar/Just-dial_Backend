
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserContact
 * 
 */
export type UserContact = $Result.DefaultSelection<Prisma.$UserContactPayload>
/**
 * Model UserAddress
 * 
 */
export type UserAddress = $Result.DefaultSelection<Prisma.$UserAddressPayload>
/**
 * Model BusinessSubscription
 * 
 */
export type BusinessSubscription = $Result.DefaultSelection<Prisma.$BusinessSubscriptionPayload>
/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model BusinessPrimaryContact
 * 
 */
export type BusinessPrimaryContact = $Result.DefaultSelection<Prisma.$BusinessPrimaryContactPayload>
/**
 * Model BusinessAddress
 * 
 */
export type BusinessAddress = $Result.DefaultSelection<Prisma.$BusinessAddressPayload>
/**
 * Model BusinessDetails
 * 
 */
export type BusinessDetails = $Result.DefaultSelection<Prisma.$BusinessDetailsPayload>
/**
 * Model BusinessSupportingDocuments
 * 
 */
export type BusinessSupportingDocuments = $Result.DefaultSelection<Prisma.$BusinessSupportingDocumentsPayload>
/**
 * Model BusinessImage
 * 
 */
export type BusinessImage = $Result.DefaultSelection<Prisma.$BusinessImagePayload>
/**
 * Model BusinessWebsite
 * 
 */
export type BusinessWebsite = $Result.DefaultSelection<Prisma.$BusinessWebsitePayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Proficiency
 * 
 */
export type Proficiency = $Result.DefaultSelection<Prisma.$ProficiencyPayload>
/**
 * Model Court
 * 
 */
export type Court = $Result.DefaultSelection<Prisma.$CourtPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Pincode
 * 
 */
export type Pincode = $Result.DefaultSelection<Prisma.$PincodePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model State
 * 
 */
export type State = $Result.DefaultSelection<Prisma.$StatePayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ContactType: {
  EMAIL: 'EMAIL',
  PHONE: 'PHONE'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]


export const BusinessType: {
  INDIVIDUAL: 'INDIVIDUAL',
  FIRM: 'FIRM'
};

export type BusinessType = (typeof BusinessType)[keyof typeof BusinessType]


export const SenderType: {
  USER: 'USER',
  BUSINESS: 'BUSINESS'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]

}

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

export type BusinessType = $Enums.BusinessType

export const BusinessType: typeof $Enums.BusinessType

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserSubscriptions
 * const userSubscriptions = await prisma.userSubscription.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserSubscriptions
   * const userSubscriptions = await prisma.userSubscription.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userContact`: Exposes CRUD operations for the **UserContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserContacts
    * const userContacts = await prisma.userContact.findMany()
    * ```
    */
  get userContact(): Prisma.UserContactDelegate<ExtArgs>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<ExtArgs>;

  /**
   * `prisma.businessSubscription`: Exposes CRUD operations for the **BusinessSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessSubscriptions
    * const businessSubscriptions = await prisma.businessSubscription.findMany()
    * ```
    */
  get businessSubscription(): Prisma.BusinessSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs>;

  /**
   * `prisma.businessPrimaryContact`: Exposes CRUD operations for the **BusinessPrimaryContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessPrimaryContacts
    * const businessPrimaryContacts = await prisma.businessPrimaryContact.findMany()
    * ```
    */
  get businessPrimaryContact(): Prisma.BusinessPrimaryContactDelegate<ExtArgs>;

  /**
   * `prisma.businessAddress`: Exposes CRUD operations for the **BusinessAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessAddresses
    * const businessAddresses = await prisma.businessAddress.findMany()
    * ```
    */
  get businessAddress(): Prisma.BusinessAddressDelegate<ExtArgs>;

  /**
   * `prisma.businessDetails`: Exposes CRUD operations for the **BusinessDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessDetails
    * const businessDetails = await prisma.businessDetails.findMany()
    * ```
    */
  get businessDetails(): Prisma.BusinessDetailsDelegate<ExtArgs>;

  /**
   * `prisma.businessSupportingDocuments`: Exposes CRUD operations for the **BusinessSupportingDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessSupportingDocuments
    * const businessSupportingDocuments = await prisma.businessSupportingDocuments.findMany()
    * ```
    */
  get businessSupportingDocuments(): Prisma.BusinessSupportingDocumentsDelegate<ExtArgs>;

  /**
   * `prisma.businessImage`: Exposes CRUD operations for the **BusinessImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessImages
    * const businessImages = await prisma.businessImage.findMany()
    * ```
    */
  get businessImage(): Prisma.BusinessImageDelegate<ExtArgs>;

  /**
   * `prisma.businessWebsite`: Exposes CRUD operations for the **BusinessWebsite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessWebsites
    * const businessWebsites = await prisma.businessWebsite.findMany()
    * ```
    */
  get businessWebsite(): Prisma.BusinessWebsiteDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.proficiency`: Exposes CRUD operations for the **Proficiency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proficiencies
    * const proficiencies = await prisma.proficiency.findMany()
    * ```
    */
  get proficiency(): Prisma.ProficiencyDelegate<ExtArgs>;

  /**
   * `prisma.court`: Exposes CRUD operations for the **Court** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courts
    * const courts = await prisma.court.findMany()
    * ```
    */
  get court(): Prisma.CourtDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.pincode`: Exposes CRUD operations for the **Pincode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pincodes
    * const pincodes = await prisma.pincode.findMany()
    * ```
    */
  get pincode(): Prisma.PincodeDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserSubscription: 'UserSubscription',
    User: 'User',
    UserContact: 'UserContact',
    UserAddress: 'UserAddress',
    BusinessSubscription: 'BusinessSubscription',
    Business: 'Business',
    BusinessPrimaryContact: 'BusinessPrimaryContact',
    BusinessAddress: 'BusinessAddress',
    BusinessDetails: 'BusinessDetails',
    BusinessSupportingDocuments: 'BusinessSupportingDocuments',
    BusinessImage: 'BusinessImage',
    BusinessWebsite: 'BusinessWebsite',
    Language: 'Language',
    Proficiency: 'Proficiency',
    Court: 'Court',
    Admin: 'Admin',
    Category: 'Category',
    Tag: 'Tag',
    Review: 'Review',
    Booking: 'Booking',
    Chat: 'Chat',
    Message: 'Message',
    Pincode: 'Pincode',
    City: 'City',
    State: 'State',
    Country: 'Country'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "userSubscription" | "user" | "userContact" | "userAddress" | "businessSubscription" | "business" | "businessPrimaryContact" | "businessAddress" | "businessDetails" | "businessSupportingDocuments" | "businessImage" | "businessWebsite" | "language" | "proficiency" | "court" | "admin" | "category" | "tag" | "review" | "booking" | "chat" | "message" | "pincode" | "city" | "state" | "country"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserContact: {
        payload: Prisma.$UserContactPayload<ExtArgs>
        fields: Prisma.UserContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          findFirst: {
            args: Prisma.UserContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          findMany: {
            args: Prisma.UserContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>[]
          }
          create: {
            args: Prisma.UserContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          createMany: {
            args: Prisma.UserContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>[]
          }
          delete: {
            args: Prisma.UserContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          update: {
            args: Prisma.UserContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          deleteMany: {
            args: Prisma.UserContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserContactPayload>
          }
          aggregate: {
            args: Prisma.UserContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserContact>
          }
          groupBy: {
            args: Prisma.UserContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserContactCountArgs<ExtArgs>
            result: $Utils.Optional<UserContactCountAggregateOutputType> | number
          }
        }
      }
      UserAddress: {
        payload: Prisma.$UserAddressPayload<ExtArgs>
        fields: Prisma.UserAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findFirst: {
            args: Prisma.UserAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findMany: {
            args: Prisma.UserAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          create: {
            args: Prisma.UserAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          createMany: {
            args: Prisma.UserAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          delete: {
            args: Prisma.UserAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          update: {
            args: Prisma.UserAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          deleteMany: {
            args: Prisma.UserAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          aggregate: {
            args: Prisma.UserAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAddress>
          }
          groupBy: {
            args: Prisma.UserAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAddressCountArgs<ExtArgs>
            result: $Utils.Optional<UserAddressCountAggregateOutputType> | number
          }
        }
      }
      BusinessSubscription: {
        payload: Prisma.$BusinessSubscriptionPayload<ExtArgs>
        fields: Prisma.BusinessSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.BusinessSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>
          }
          findMany: {
            args: Prisma.BusinessSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>[]
          }
          create: {
            args: Prisma.BusinessSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>
          }
          createMany: {
            args: Prisma.BusinessSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.BusinessSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>
          }
          update: {
            args: Prisma.BusinessSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.BusinessSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.BusinessSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessSubscription>
          }
          groupBy: {
            args: Prisma.BusinessSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      BusinessPrimaryContact: {
        payload: Prisma.$BusinessPrimaryContactPayload<ExtArgs>
        fields: Prisma.BusinessPrimaryContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessPrimaryContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessPrimaryContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>
          }
          findFirst: {
            args: Prisma.BusinessPrimaryContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessPrimaryContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>
          }
          findMany: {
            args: Prisma.BusinessPrimaryContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>[]
          }
          create: {
            args: Prisma.BusinessPrimaryContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>
          }
          createMany: {
            args: Prisma.BusinessPrimaryContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessPrimaryContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>[]
          }
          delete: {
            args: Prisma.BusinessPrimaryContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>
          }
          update: {
            args: Prisma.BusinessPrimaryContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>
          }
          deleteMany: {
            args: Prisma.BusinessPrimaryContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessPrimaryContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessPrimaryContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPrimaryContactPayload>
          }
          aggregate: {
            args: Prisma.BusinessPrimaryContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessPrimaryContact>
          }
          groupBy: {
            args: Prisma.BusinessPrimaryContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessPrimaryContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessPrimaryContactCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessPrimaryContactCountAggregateOutputType> | number
          }
        }
      }
      BusinessAddress: {
        payload: Prisma.$BusinessAddressPayload<ExtArgs>
        fields: Prisma.BusinessAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>
          }
          findFirst: {
            args: Prisma.BusinessAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>
          }
          findMany: {
            args: Prisma.BusinessAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>[]
          }
          create: {
            args: Prisma.BusinessAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>
          }
          createMany: {
            args: Prisma.BusinessAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>[]
          }
          delete: {
            args: Prisma.BusinessAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>
          }
          update: {
            args: Prisma.BusinessAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>
          }
          deleteMany: {
            args: Prisma.BusinessAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessAddressPayload>
          }
          aggregate: {
            args: Prisma.BusinessAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessAddress>
          }
          groupBy: {
            args: Prisma.BusinessAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessAddressCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessAddressCountAggregateOutputType> | number
          }
        }
      }
      BusinessDetails: {
        payload: Prisma.$BusinessDetailsPayload<ExtArgs>
        fields: Prisma.BusinessDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>
          }
          findFirst: {
            args: Prisma.BusinessDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>
          }
          findMany: {
            args: Prisma.BusinessDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>[]
          }
          create: {
            args: Prisma.BusinessDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>
          }
          createMany: {
            args: Prisma.BusinessDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>[]
          }
          delete: {
            args: Prisma.BusinessDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>
          }
          update: {
            args: Prisma.BusinessDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDetailsPayload>
          }
          aggregate: {
            args: Prisma.BusinessDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessDetails>
          }
          groupBy: {
            args: Prisma.BusinessDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessDetailsCountAggregateOutputType> | number
          }
        }
      }
      BusinessSupportingDocuments: {
        payload: Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>
        fields: Prisma.BusinessSupportingDocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessSupportingDocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessSupportingDocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>
          }
          findFirst: {
            args: Prisma.BusinessSupportingDocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessSupportingDocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>
          }
          findMany: {
            args: Prisma.BusinessSupportingDocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>[]
          }
          create: {
            args: Prisma.BusinessSupportingDocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>
          }
          createMany: {
            args: Prisma.BusinessSupportingDocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessSupportingDocumentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>[]
          }
          delete: {
            args: Prisma.BusinessSupportingDocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>
          }
          update: {
            args: Prisma.BusinessSupportingDocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>
          }
          deleteMany: {
            args: Prisma.BusinessSupportingDocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessSupportingDocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessSupportingDocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSupportingDocumentsPayload>
          }
          aggregate: {
            args: Prisma.BusinessSupportingDocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessSupportingDocuments>
          }
          groupBy: {
            args: Prisma.BusinessSupportingDocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessSupportingDocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessSupportingDocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessSupportingDocumentsCountAggregateOutputType> | number
          }
        }
      }
      BusinessImage: {
        payload: Prisma.$BusinessImagePayload<ExtArgs>
        fields: Prisma.BusinessImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>
          }
          findFirst: {
            args: Prisma.BusinessImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>
          }
          findMany: {
            args: Prisma.BusinessImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>[]
          }
          create: {
            args: Prisma.BusinessImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>
          }
          createMany: {
            args: Prisma.BusinessImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>[]
          }
          delete: {
            args: Prisma.BusinessImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>
          }
          update: {
            args: Prisma.BusinessImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>
          }
          deleteMany: {
            args: Prisma.BusinessImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessImagePayload>
          }
          aggregate: {
            args: Prisma.BusinessImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessImage>
          }
          groupBy: {
            args: Prisma.BusinessImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessImageCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessImageCountAggregateOutputType> | number
          }
        }
      }
      BusinessWebsite: {
        payload: Prisma.$BusinessWebsitePayload<ExtArgs>
        fields: Prisma.BusinessWebsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessWebsiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessWebsiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>
          }
          findFirst: {
            args: Prisma.BusinessWebsiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessWebsiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>
          }
          findMany: {
            args: Prisma.BusinessWebsiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>[]
          }
          create: {
            args: Prisma.BusinessWebsiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>
          }
          createMany: {
            args: Prisma.BusinessWebsiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessWebsiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>[]
          }
          delete: {
            args: Prisma.BusinessWebsiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>
          }
          update: {
            args: Prisma.BusinessWebsiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>
          }
          deleteMany: {
            args: Prisma.BusinessWebsiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessWebsiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessWebsiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessWebsitePayload>
          }
          aggregate: {
            args: Prisma.BusinessWebsiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessWebsite>
          }
          groupBy: {
            args: Prisma.BusinessWebsiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessWebsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessWebsiteCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessWebsiteCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Proficiency: {
        payload: Prisma.$ProficiencyPayload<ExtArgs>
        fields: Prisma.ProficiencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProficiencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProficiencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>
          }
          findFirst: {
            args: Prisma.ProficiencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProficiencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>
          }
          findMany: {
            args: Prisma.ProficiencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>[]
          }
          create: {
            args: Prisma.ProficiencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>
          }
          createMany: {
            args: Prisma.ProficiencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProficiencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>[]
          }
          delete: {
            args: Prisma.ProficiencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>
          }
          update: {
            args: Prisma.ProficiencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>
          }
          deleteMany: {
            args: Prisma.ProficiencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProficiencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProficiencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProficiencyPayload>
          }
          aggregate: {
            args: Prisma.ProficiencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProficiency>
          }
          groupBy: {
            args: Prisma.ProficiencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProficiencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProficiencyCountArgs<ExtArgs>
            result: $Utils.Optional<ProficiencyCountAggregateOutputType> | number
          }
        }
      }
      Court: {
        payload: Prisma.$CourtPayload<ExtArgs>
        fields: Prisma.CourtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findFirst: {
            args: Prisma.CourtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findMany: {
            args: Prisma.CourtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          create: {
            args: Prisma.CourtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          createMany: {
            args: Prisma.CourtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          delete: {
            args: Prisma.CourtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          update: {
            args: Prisma.CourtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          deleteMany: {
            args: Prisma.CourtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          aggregate: {
            args: Prisma.CourtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt>
          }
          groupBy: {
            args: Prisma.CourtGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourtGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourtCountArgs<ExtArgs>
            result: $Utils.Optional<CourtCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Pincode: {
        payload: Prisma.$PincodePayload<ExtArgs>
        fields: Prisma.PincodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PincodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PincodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>
          }
          findFirst: {
            args: Prisma.PincodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PincodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>
          }
          findMany: {
            args: Prisma.PincodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>[]
          }
          create: {
            args: Prisma.PincodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>
          }
          createMany: {
            args: Prisma.PincodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PincodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>[]
          }
          delete: {
            args: Prisma.PincodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>
          }
          update: {
            args: Prisma.PincodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>
          }
          deleteMany: {
            args: Prisma.PincodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PincodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PincodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PincodePayload>
          }
          aggregate: {
            args: Prisma.PincodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePincode>
          }
          groupBy: {
            args: Prisma.PincodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PincodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PincodeCountArgs<ExtArgs>
            result: $Utils.Optional<PincodeCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      State: {
        payload: Prisma.$StatePayload<ExtArgs>
        fields: Prisma.StateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          findFirst: {
            args: Prisma.StateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          findMany: {
            args: Prisma.StateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>[]
          }
          create: {
            args: Prisma.StateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          createMany: {
            args: Prisma.StateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>[]
          }
          delete: {
            args: Prisma.StateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          update: {
            args: Prisma.StateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          deleteMany: {
            args: Prisma.StateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          aggregate: {
            args: Prisma.StateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateState>
          }
          groupBy: {
            args: Prisma.StateGroupByArgs<ExtArgs>
            result: $Utils.Optional<StateGroupByOutputType>[]
          }
          count: {
            args: Prisma.StateCountArgs<ExtArgs>
            result: $Utils.Optional<StateCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserSubscriptionCountOutputType
   */

  export type UserSubscriptionCountOutputType = {
    users: number
  }

  export type UserSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserSubscriptionCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * UserSubscriptionCountOutputType without action
   */
  export type UserSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscriptionCountOutputType
     */
    select?: UserSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserSubscriptionCountOutputType without action
   */
  export type UserSubscriptionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    contacts: number
    addresses: number
    bookings: number
    chats: number
    reviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    chats?: boolean | UserCountOutputTypeCountChatsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type BusinessSubscriptionCountOutputType
   */

  export type BusinessSubscriptionCountOutputType = {
    businesses: number
  }

  export type BusinessSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businesses?: boolean | BusinessSubscriptionCountOutputTypeCountBusinessesArgs
  }

  // Custom InputTypes
  /**
   * BusinessSubscriptionCountOutputType without action
   */
  export type BusinessSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscriptionCountOutputType
     */
    select?: BusinessSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessSubscriptionCountOutputType without action
   */
  export type BusinessSubscriptionCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    primaryContacts: number
    chats: number
    bookings: number
    reviews: number
    businessSupportingDocuments: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryContacts?: boolean | BusinessCountOutputTypeCountPrimaryContactsArgs
    chats?: boolean | BusinessCountOutputTypeCountChatsArgs
    bookings?: boolean | BusinessCountOutputTypeCountBookingsArgs
    reviews?: boolean | BusinessCountOutputTypeCountReviewsArgs
    businessSupportingDocuments?: boolean | BusinessCountOutputTypeCountBusinessSupportingDocumentsArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountPrimaryContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessPrimaryContactWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountBusinessSupportingDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessSupportingDocumentsWhereInput
  }


  /**
   * Count Type BusinessDetailsCountOutputType
   */

  export type BusinessDetailsCountOutputType = {
    websites: number
    images: number
    language: number
    proficiency: number
    court: number
    tags: number
    addresses: number
  }

  export type BusinessDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    websites?: boolean | BusinessDetailsCountOutputTypeCountWebsitesArgs
    images?: boolean | BusinessDetailsCountOutputTypeCountImagesArgs
    language?: boolean | BusinessDetailsCountOutputTypeCountLanguageArgs
    proficiency?: boolean | BusinessDetailsCountOutputTypeCountProficiencyArgs
    court?: boolean | BusinessDetailsCountOutputTypeCountCourtArgs
    tags?: boolean | BusinessDetailsCountOutputTypeCountTagsArgs
    addresses?: boolean | BusinessDetailsCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetailsCountOutputType
     */
    select?: BusinessDetailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeCountWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWebsiteWhereInput
  }

  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessImageWhereInput
  }

  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeCountLanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
  }

  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeCountProficiencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProficiencyWhereInput
  }

  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeCountCourtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
  }

  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * BusinessDetailsCountOutputType without action
   */
  export type BusinessDetailsCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessAddressWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    businessDetails: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | LanguageCountOutputTypeCountBusinessDetailsArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountBusinessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDetailsWhereInput
  }


  /**
   * Count Type ProficiencyCountOutputType
   */

  export type ProficiencyCountOutputType = {
    businessDetails: number
  }

  export type ProficiencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | ProficiencyCountOutputTypeCountBusinessDetailsArgs
  }

  // Custom InputTypes
  /**
   * ProficiencyCountOutputType without action
   */
  export type ProficiencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProficiencyCountOutputType
     */
    select?: ProficiencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProficiencyCountOutputType without action
   */
  export type ProficiencyCountOutputTypeCountBusinessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDetailsWhereInput
  }


  /**
   * Count Type CourtCountOutputType
   */

  export type CourtCountOutputType = {
    businessDetails: number
  }

  export type CourtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | CourtCountOutputTypeCountBusinessDetailsArgs
  }

  // Custom InputTypes
  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCountOutputType
     */
    select?: CourtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountBusinessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDetailsWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    businessesDetails: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessesDetails?: boolean | CategoryCountOutputTypeCountBusinessesDetailsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBusinessesDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDetailsWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    BusinessDetails: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BusinessDetails?: boolean | TagCountOutputTypeCountBusinessDetailsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountBusinessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDetailsWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    Message: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Message?: boolean | ChatCountOutputTypeCountMessageArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    pincodes: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pincodes?: boolean | CityCountOutputTypeCountPincodesArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountPincodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PincodeWhereInput
  }


  /**
   * Count Type StateCountOutputType
   */

  export type StateCountOutputType = {
    cities: number
  }

  export type StateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | StateCountOutputTypeCountCitiesArgs
  }

  // Custom InputTypes
  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     */
    select?: StateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    state: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | CountryCountOutputTypeCountStateArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StateWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type UserSubscriptionSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    duration: number
    features: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserSubscriptionAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type UserSubscriptionSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type UserSubscriptionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    features?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _avg?: UserSubscriptionAvgAggregateInputType
    _sum?: UserSubscriptionSumAggregateInputType
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    duration: number
    features: string[]
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    users?: boolean | UserSubscription$usersArgs<ExtArgs>
    _count?: boolean | UserSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserSubscription$usersArgs<ExtArgs>
    _count?: boolean | UserSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      duration: number
      features: string[]
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserSubscription$usersArgs<ExtArgs> = {}>(args?: Subset<T, UserSubscription$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */ 
  interface UserSubscriptionFieldRefs {
    readonly id: FieldRef<"UserSubscription", 'String'>
    readonly name: FieldRef<"UserSubscription", 'String'>
    readonly description: FieldRef<"UserSubscription", 'String'>
    readonly price: FieldRef<"UserSubscription", 'Float'>
    readonly duration: FieldRef<"UserSubscription", 'Int'>
    readonly features: FieldRef<"UserSubscription", 'String[]'>
    readonly createdAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly deletedAt: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription.users
   */
  export type UserSubscription$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    password: string | null
    salt: string | null
    hideDetails: boolean | null
    avatar: string | null
    subscriptionId: string | null
    subscriptionExpire: Date | null
    paymentVerification: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    password: string | null
    salt: string | null
    hideDetails: boolean | null
    avatar: string | null
    subscriptionId: string | null
    subscriptionExpire: Date | null
    paymentVerification: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    password: number
    salt: number
    hideDetails: number
    avatar: number
    subscriptionId: number
    subscriptionExpire: number
    paymentVerification: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    password?: true
    salt?: true
    hideDetails?: true
    avatar?: true
    subscriptionId?: true
    subscriptionExpire?: true
    paymentVerification?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    password?: true
    salt?: true
    hideDetails?: true
    avatar?: true
    subscriptionId?: true
    subscriptionExpire?: true
    paymentVerification?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    password?: true
    salt?: true
    hideDetails?: true
    avatar?: true
    subscriptionId?: true
    subscriptionExpire?: true
    paymentVerification?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    password: string | null
    salt: string | null
    hideDetails: boolean
    avatar: string | null
    subscriptionId: string | null
    subscriptionExpire: Date | null
    paymentVerification: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    password?: boolean
    salt?: boolean
    hideDetails?: boolean
    avatar?: boolean
    subscriptionId?: boolean
    subscriptionExpire?: boolean
    paymentVerification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    contacts?: boolean | User$contactsArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    password?: boolean
    salt?: boolean
    hideDetails?: boolean
    avatar?: boolean
    subscriptionId?: boolean
    subscriptionExpire?: boolean
    paymentVerification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    password?: boolean
    salt?: boolean
    hideDetails?: boolean
    avatar?: boolean
    subscriptionId?: boolean
    subscriptionExpire?: boolean
    paymentVerification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | User$contactsArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      contacts: Prisma.$UserContactPayload<ExtArgs>[]
      addresses: Prisma.$UserAddressPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      subscription: Prisma.$UserSubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      password: string | null
      salt: string | null
      hideDetails: boolean
      avatar: string | null
      subscriptionId: string | null
      subscriptionExpire: Date | null
      paymentVerification: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findMany"> | Null>
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    chats<T extends User$chatsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly slug: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly salt: FieldRef<"User", 'String'>
    readonly hideDetails: FieldRef<"User", 'Boolean'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly subscriptionId: FieldRef<"User", 'String'>
    readonly subscriptionExpire: FieldRef<"User", 'DateTime'>
    readonly paymentVerification: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    where?: UserContactWhereInput
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    cursor?: UserContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.chats
   */
  export type User$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserContact
   */

  export type AggregateUserContact = {
    _count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  export type UserContactAvgAggregateOutputType = {
    order: number | null
  }

  export type UserContactSumAggregateOutputType = {
    order: number | null
  }

  export type UserContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ContactType | null
    value: string | null
    isVerified: boolean | null
    isPrimary: boolean | null
    order: number | null
    verifiedAt: Date | null
    otp: string | null
    otpExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ContactType | null
    value: string | null
    isVerified: boolean | null
    isPrimary: boolean | null
    order: number | null
    verifiedAt: Date | null
    otp: string | null
    otpExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserContactCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    value: number
    isVerified: number
    isPrimary: number
    order: number
    verifiedAt: number
    otp: number
    otpExpiresAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserContactAvgAggregateInputType = {
    order?: true
  }

  export type UserContactSumAggregateInputType = {
    order?: true
  }

  export type UserContactMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    value?: true
    isVerified?: true
    isPrimary?: true
    order?: true
    verifiedAt?: true
    otp?: true
    otpExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserContactMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    value?: true
    isVerified?: true
    isPrimary?: true
    order?: true
    verifiedAt?: true
    otp?: true
    otpExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserContactCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    value?: true
    isVerified?: true
    isPrimary?: true
    order?: true
    verifiedAt?: true
    otp?: true
    otpExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserContact to aggregate.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserContacts
    **/
    _count?: true | UserContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserContactMaxAggregateInputType
  }

  export type GetUserContactAggregateType<T extends UserContactAggregateArgs> = {
        [P in keyof T & keyof AggregateUserContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserContact[P]>
      : GetScalarType<T[P], AggregateUserContact[P]>
  }




  export type UserContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserContactWhereInput
    orderBy?: UserContactOrderByWithAggregationInput | UserContactOrderByWithAggregationInput[]
    by: UserContactScalarFieldEnum[] | UserContactScalarFieldEnum
    having?: UserContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserContactCountAggregateInputType | true
    _avg?: UserContactAvgAggregateInputType
    _sum?: UserContactSumAggregateInputType
    _min?: UserContactMinAggregateInputType
    _max?: UserContactMaxAggregateInputType
  }

  export type UserContactGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ContactType
    value: string
    isVerified: boolean
    isPrimary: boolean
    order: number | null
    verifiedAt: Date | null
    otp: string | null
    otpExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  type GetUserContactGroupByPayload<T extends UserContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserContactGroupByOutputType[P]>
            : GetScalarType<T[P], UserContactGroupByOutputType[P]>
        }
      >
    >


  export type UserContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    isVerified?: boolean
    isPrimary?: boolean
    order?: boolean
    verifiedAt?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userContact"]>

  export type UserContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    isVerified?: boolean
    isPrimary?: boolean
    order?: boolean
    verifiedAt?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userContact"]>

  export type UserContactSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    isVerified?: boolean
    isPrimary?: boolean
    order?: boolean
    verifiedAt?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserContact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ContactType
      value: string
      isVerified: boolean
      isPrimary: boolean
      order: number | null
      verifiedAt: Date | null
      otp: string | null
      otpExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["userContact"]>
    composites: {}
  }

  type UserContactGetPayload<S extends boolean | null | undefined | UserContactDefaultArgs> = $Result.GetResult<Prisma.$UserContactPayload, S>

  type UserContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserContactCountAggregateInputType | true
    }

  export interface UserContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserContact'], meta: { name: 'UserContact' } }
    /**
     * Find zero or one UserContact that matches the filter.
     * @param {UserContactFindUniqueArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserContactFindUniqueArgs>(args: SelectSubset<T, UserContactFindUniqueArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserContact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserContactFindUniqueOrThrowArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserContactFindUniqueOrThrowArgs>(args: SelectSubset<T, UserContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindFirstArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserContactFindFirstArgs>(args?: SelectSubset<T, UserContactFindFirstArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindFirstOrThrowArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserContactFindFirstOrThrowArgs>(args?: SelectSubset<T, UserContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserContacts
     * const userContacts = await prisma.userContact.findMany()
     * 
     * // Get first 10 UserContacts
     * const userContacts = await prisma.userContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userContactWithIdOnly = await prisma.userContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserContactFindManyArgs>(args?: SelectSubset<T, UserContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserContact.
     * @param {UserContactCreateArgs} args - Arguments to create a UserContact.
     * @example
     * // Create one UserContact
     * const UserContact = await prisma.userContact.create({
     *   data: {
     *     // ... data to create a UserContact
     *   }
     * })
     * 
     */
    create<T extends UserContactCreateArgs>(args: SelectSubset<T, UserContactCreateArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserContacts.
     * @param {UserContactCreateManyArgs} args - Arguments to create many UserContacts.
     * @example
     * // Create many UserContacts
     * const userContact = await prisma.userContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserContactCreateManyArgs>(args?: SelectSubset<T, UserContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserContacts and returns the data saved in the database.
     * @param {UserContactCreateManyAndReturnArgs} args - Arguments to create many UserContacts.
     * @example
     * // Create many UserContacts
     * const userContact = await prisma.userContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserContacts and only return the `id`
     * const userContactWithIdOnly = await prisma.userContact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserContactCreateManyAndReturnArgs>(args?: SelectSubset<T, UserContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserContact.
     * @param {UserContactDeleteArgs} args - Arguments to delete one UserContact.
     * @example
     * // Delete one UserContact
     * const UserContact = await prisma.userContact.delete({
     *   where: {
     *     // ... filter to delete one UserContact
     *   }
     * })
     * 
     */
    delete<T extends UserContactDeleteArgs>(args: SelectSubset<T, UserContactDeleteArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserContact.
     * @param {UserContactUpdateArgs} args - Arguments to update one UserContact.
     * @example
     * // Update one UserContact
     * const userContact = await prisma.userContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserContactUpdateArgs>(args: SelectSubset<T, UserContactUpdateArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserContacts.
     * @param {UserContactDeleteManyArgs} args - Arguments to filter UserContacts to delete.
     * @example
     * // Delete a few UserContacts
     * const { count } = await prisma.userContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserContactDeleteManyArgs>(args?: SelectSubset<T, UserContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserContacts
     * const userContact = await prisma.userContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserContactUpdateManyArgs>(args: SelectSubset<T, UserContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserContact.
     * @param {UserContactUpsertArgs} args - Arguments to update or create a UserContact.
     * @example
     * // Update or create a UserContact
     * const userContact = await prisma.userContact.upsert({
     *   create: {
     *     // ... data to create a UserContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserContact we want to update
     *   }
     * })
     */
    upsert<T extends UserContactUpsertArgs>(args: SelectSubset<T, UserContactUpsertArgs<ExtArgs>>): Prisma__UserContactClient<$Result.GetResult<Prisma.$UserContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactCountArgs} args - Arguments to filter UserContacts to count.
     * @example
     * // Count the number of UserContacts
     * const count = await prisma.userContact.count({
     *   where: {
     *     // ... the filter for the UserContacts we want to count
     *   }
     * })
    **/
    count<T extends UserContactCountArgs>(
      args?: Subset<T, UserContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserContactAggregateArgs>(args: Subset<T, UserContactAggregateArgs>): Prisma.PrismaPromise<GetUserContactAggregateType<T>>

    /**
     * Group by UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserContactGroupByArgs['orderBy'] }
        : { orderBy?: UserContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserContact model
   */
  readonly fields: UserContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserContact model
   */ 
  interface UserContactFieldRefs {
    readonly id: FieldRef<"UserContact", 'String'>
    readonly userId: FieldRef<"UserContact", 'String'>
    readonly type: FieldRef<"UserContact", 'ContactType'>
    readonly value: FieldRef<"UserContact", 'String'>
    readonly isVerified: FieldRef<"UserContact", 'Boolean'>
    readonly isPrimary: FieldRef<"UserContact", 'Boolean'>
    readonly order: FieldRef<"UserContact", 'Int'>
    readonly verifiedAt: FieldRef<"UserContact", 'DateTime'>
    readonly otp: FieldRef<"UserContact", 'String'>
    readonly otpExpiresAt: FieldRef<"UserContact", 'DateTime'>
    readonly createdAt: FieldRef<"UserContact", 'DateTime'>
    readonly updatedAt: FieldRef<"UserContact", 'DateTime'>
    readonly deletedAt: FieldRef<"UserContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserContact findUnique
   */
  export type UserContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact findUniqueOrThrow
   */
  export type UserContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact findFirst
   */
  export type UserContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContacts.
     */
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * UserContact findFirstOrThrow
   */
  export type UserContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContacts.
     */
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * UserContact findMany
   */
  export type UserContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContacts to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: UserContactOrderByWithRelationInput | UserContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    distinct?: UserContactScalarFieldEnum | UserContactScalarFieldEnum[]
  }

  /**
   * UserContact create
   */
  export type UserContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The data needed to create a UserContact.
     */
    data: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
  }

  /**
   * UserContact createMany
   */
  export type UserContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserContacts.
     */
    data: UserContactCreateManyInput | UserContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserContact createManyAndReturn
   */
  export type UserContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserContacts.
     */
    data: UserContactCreateManyInput | UserContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserContact update
   */
  export type UserContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The data needed to update a UserContact.
     */
    data: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
    /**
     * Choose, which UserContact to update.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact updateMany
   */
  export type UserContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserContacts.
     */
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyInput>
    /**
     * Filter which UserContacts to update
     */
    where?: UserContactWhereInput
  }

  /**
   * UserContact upsert
   */
  export type UserContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The filter to search for the UserContact to update in case it exists.
     */
    where: UserContactWhereUniqueInput
    /**
     * In case the UserContact found by the `where` argument doesn't exist, create a new UserContact with this data.
     */
    create: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
    /**
     * In case the UserContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
  }

  /**
   * UserContact delete
   */
  export type UserContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter which UserContact to delete.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact deleteMany
   */
  export type UserContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserContacts to delete
     */
    where?: UserContactWhereInput
  }

  /**
   * UserContact without action
   */
  export type UserContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserContactInclude<ExtArgs> | null
  }


  /**
   * Model UserAddress
   */

  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressAvgAggregateOutputType = {
    order: number | null
  }

  export type UserAddressSumAggregateOutputType = {
    order: number | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    order: number | null
    street: string | null
    city: string | null
    country: string | null
    pincode: string | null
    state: string | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    order: number | null
    street: string | null
    city: string | null
    country: string | null
    pincode: string | null
    state: string | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    order: number
    street: number
    city: number
    country: number
    pincode: number
    state: number
    _all: number
  }


  export type UserAddressAvgAggregateInputType = {
    order?: true
  }

  export type UserAddressSumAggregateInputType = {
    order?: true
  }

  export type UserAddressMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    order?: true
    street?: true
    city?: true
    country?: true
    pincode?: true
    state?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    order?: true
    street?: true
    city?: true
    country?: true
    pincode?: true
    state?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    order?: true
    street?: true
    city?: true
    country?: true
    pincode?: true
    state?: true
    _all?: true
  }

  export type UserAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddress to aggregate.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithAggregationInput | UserAddressOrderByWithAggregationInput[]
    by: UserAddressScalarFieldEnum[] | UserAddressScalarFieldEnum
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _avg?: UserAddressAvgAggregateInputType
    _sum?: UserAddressSumAggregateInputType
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }

  export type UserAddressGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    order: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    order?: boolean
    street?: boolean
    city?: boolean
    country?: boolean
    pincode?: boolean
    state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    order?: boolean
    street?: boolean
    city?: boolean
    country?: boolean
    pincode?: boolean
    state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    order?: boolean
    street?: boolean
    city?: boolean
    country?: boolean
    pincode?: boolean
    state?: boolean
  }

  export type UserAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAddress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
      order: number | null
      street: string
      city: string
      country: string
      pincode: string
      state: string
    }, ExtArgs["result"]["userAddress"]>
    composites: {}
  }

  type UserAddressGetPayload<S extends boolean | null | undefined | UserAddressDefaultArgs> = $Result.GetResult<Prisma.$UserAddressPayload, S>

  type UserAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAddressCountAggregateInputType | true
    }

  export interface UserAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAddress'], meta: { name: 'UserAddress' } }
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAddressFindUniqueArgs>(args: SelectSubset<T, UserAddressFindUniqueArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAddress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAddressFindFirstArgs>(args?: SelectSubset<T, UserAddressFindFirstArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAddressFindManyArgs>(args?: SelectSubset<T, UserAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
     */
    create<T extends UserAddressCreateArgs>(args: SelectSubset<T, UserAddressCreateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAddresses.
     * @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     * @example
     * // Create many UserAddresses
     * const userAddress = await prisma.userAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAddressCreateManyArgs>(args?: SelectSubset<T, UserAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAddresses and returns the data saved in the database.
     * @param {UserAddressCreateManyAndReturnArgs} args - Arguments to create many UserAddresses.
     * @example
     * // Create many UserAddresses
     * const userAddress = await prisma.userAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAddresses and only return the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
     */
    delete<T extends UserAddressDeleteArgs>(args: SelectSubset<T, UserAddressDeleteArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAddressUpdateArgs>(args: SelectSubset<T, UserAddressUpdateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAddressDeleteManyArgs>(args?: SelectSubset<T, UserAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAddressUpdateManyArgs>(args: SelectSubset<T, UserAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
     */
    upsert<T extends UserAddressUpsertArgs>(args: SelectSubset<T, UserAddressUpsertArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): Prisma.PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAddress model
   */
  readonly fields: UserAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAddress model
   */ 
  interface UserAddressFieldRefs {
    readonly id: FieldRef<"UserAddress", 'String'>
    readonly userId: FieldRef<"UserAddress", 'String'>
    readonly createdAt: FieldRef<"UserAddress", 'DateTime'>
    readonly deletedAt: FieldRef<"UserAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAddress", 'DateTime'>
    readonly order: FieldRef<"UserAddress", 'Int'>
    readonly street: FieldRef<"UserAddress", 'String'>
    readonly city: FieldRef<"UserAddress", 'String'>
    readonly country: FieldRef<"UserAddress", 'String'>
    readonly pincode: FieldRef<"UserAddress", 'String'>
    readonly state: FieldRef<"UserAddress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAddress findUnique
   */
  export type UserAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findFirst
   */
  export type UserAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddresses to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAddress.
     */
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }

  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAddress createManyAndReturn
   */
  export type UserAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAddress.
     */
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
  }

  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     */
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     */
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }

  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter which UserAddress to delete.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddresses to delete
     */
    where?: UserAddressWhereInput
  }

  /**
   * UserAddress without action
   */
  export type UserAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
  }


  /**
   * Model BusinessSubscription
   */

  export type AggregateBusinessSubscription = {
    _count: BusinessSubscriptionCountAggregateOutputType | null
    _avg: BusinessSubscriptionAvgAggregateOutputType | null
    _sum: BusinessSubscriptionSumAggregateOutputType | null
    _min: BusinessSubscriptionMinAggregateOutputType | null
    _max: BusinessSubscriptionMaxAggregateOutputType | null
  }

  export type BusinessSubscriptionAvgAggregateOutputType = {
    price: number | null
    duration: number | null
    tierLevel: number | null
  }

  export type BusinessSubscriptionSumAggregateOutputType = {
    price: number | null
    duration: number | null
    tierLevel: number | null
  }

  export type BusinessSubscriptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.BusinessType | null
    price: number | null
    duration: number | null
    tierLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessSubscriptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.BusinessType | null
    price: number | null
    duration: number | null
    tierLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessSubscriptionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    price: number
    duration: number
    features: number
    tierLevel: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BusinessSubscriptionAvgAggregateInputType = {
    price?: true
    duration?: true
    tierLevel?: true
  }

  export type BusinessSubscriptionSumAggregateInputType = {
    price?: true
    duration?: true
    tierLevel?: true
  }

  export type BusinessSubscriptionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    price?: true
    duration?: true
    tierLevel?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessSubscriptionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    price?: true
    duration?: true
    tierLevel?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessSubscriptionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    price?: true
    duration?: true
    features?: true
    tierLevel?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BusinessSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessSubscription to aggregate.
     */
    where?: BusinessSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSubscriptions to fetch.
     */
    orderBy?: BusinessSubscriptionOrderByWithRelationInput | BusinessSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessSubscriptions
    **/
    _count?: true | BusinessSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessSubscriptionMaxAggregateInputType
  }

  export type GetBusinessSubscriptionAggregateType<T extends BusinessSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessSubscription[P]>
      : GetScalarType<T[P], AggregateBusinessSubscription[P]>
  }




  export type BusinessSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessSubscriptionWhereInput
    orderBy?: BusinessSubscriptionOrderByWithAggregationInput | BusinessSubscriptionOrderByWithAggregationInput[]
    by: BusinessSubscriptionScalarFieldEnum[] | BusinessSubscriptionScalarFieldEnum
    having?: BusinessSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessSubscriptionCountAggregateInputType | true
    _avg?: BusinessSubscriptionAvgAggregateInputType
    _sum?: BusinessSubscriptionSumAggregateInputType
    _min?: BusinessSubscriptionMinAggregateInputType
    _max?: BusinessSubscriptionMaxAggregateInputType
  }

  export type BusinessSubscriptionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.BusinessType
    price: number
    duration: number
    features: string[]
    tierLevel: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BusinessSubscriptionCountAggregateOutputType | null
    _avg: BusinessSubscriptionAvgAggregateOutputType | null
    _sum: BusinessSubscriptionSumAggregateOutputType | null
    _min: BusinessSubscriptionMinAggregateOutputType | null
    _max: BusinessSubscriptionMaxAggregateOutputType | null
  }

  type GetBusinessSubscriptionGroupByPayload<T extends BusinessSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    tierLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    businesses?: boolean | BusinessSubscription$businessesArgs<ExtArgs>
    _count?: boolean | BusinessSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessSubscription"]>

  export type BusinessSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    tierLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["businessSubscription"]>

  export type BusinessSubscriptionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    tierLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BusinessSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businesses?: boolean | BusinessSubscription$businessesArgs<ExtArgs>
    _count?: boolean | BusinessSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessSubscription"
    objects: {
      businesses: Prisma.$BusinessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.BusinessType
      price: number
      duration: number
      features: string[]
      tierLevel: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["businessSubscription"]>
    composites: {}
  }

  type BusinessSubscriptionGetPayload<S extends boolean | null | undefined | BusinessSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$BusinessSubscriptionPayload, S>

  type BusinessSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessSubscriptionCountAggregateInputType | true
    }

  export interface BusinessSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessSubscription'], meta: { name: 'BusinessSubscription' } }
    /**
     * Find zero or one BusinessSubscription that matches the filter.
     * @param {BusinessSubscriptionFindUniqueArgs} args - Arguments to find a BusinessSubscription
     * @example
     * // Get one BusinessSubscription
     * const businessSubscription = await prisma.businessSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessSubscriptionFindUniqueArgs>(args: SelectSubset<T, BusinessSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a BusinessSubscription
     * @example
     * // Get one BusinessSubscription
     * const businessSubscription = await prisma.businessSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSubscriptionFindFirstArgs} args - Arguments to find a BusinessSubscription
     * @example
     * // Get one BusinessSubscription
     * const businessSubscription = await prisma.businessSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessSubscriptionFindFirstArgs>(args?: SelectSubset<T, BusinessSubscriptionFindFirstArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSubscriptionFindFirstOrThrowArgs} args - Arguments to find a BusinessSubscription
     * @example
     * // Get one BusinessSubscription
     * const businessSubscription = await prisma.businessSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessSubscriptions
     * const businessSubscriptions = await prisma.businessSubscription.findMany()
     * 
     * // Get first 10 BusinessSubscriptions
     * const businessSubscriptions = await prisma.businessSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessSubscriptionWithIdOnly = await prisma.businessSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessSubscriptionFindManyArgs>(args?: SelectSubset<T, BusinessSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessSubscription.
     * @param {BusinessSubscriptionCreateArgs} args - Arguments to create a BusinessSubscription.
     * @example
     * // Create one BusinessSubscription
     * const BusinessSubscription = await prisma.businessSubscription.create({
     *   data: {
     *     // ... data to create a BusinessSubscription
     *   }
     * })
     * 
     */
    create<T extends BusinessSubscriptionCreateArgs>(args: SelectSubset<T, BusinessSubscriptionCreateArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessSubscriptions.
     * @param {BusinessSubscriptionCreateManyArgs} args - Arguments to create many BusinessSubscriptions.
     * @example
     * // Create many BusinessSubscriptions
     * const businessSubscription = await prisma.businessSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessSubscriptionCreateManyArgs>(args?: SelectSubset<T, BusinessSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessSubscriptions and returns the data saved in the database.
     * @param {BusinessSubscriptionCreateManyAndReturnArgs} args - Arguments to create many BusinessSubscriptions.
     * @example
     * // Create many BusinessSubscriptions
     * const businessSubscription = await prisma.businessSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessSubscriptions and only return the `id`
     * const businessSubscriptionWithIdOnly = await prisma.businessSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessSubscription.
     * @param {BusinessSubscriptionDeleteArgs} args - Arguments to delete one BusinessSubscription.
     * @example
     * // Delete one BusinessSubscription
     * const BusinessSubscription = await prisma.businessSubscription.delete({
     *   where: {
     *     // ... filter to delete one BusinessSubscription
     *   }
     * })
     * 
     */
    delete<T extends BusinessSubscriptionDeleteArgs>(args: SelectSubset<T, BusinessSubscriptionDeleteArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessSubscription.
     * @param {BusinessSubscriptionUpdateArgs} args - Arguments to update one BusinessSubscription.
     * @example
     * // Update one BusinessSubscription
     * const businessSubscription = await prisma.businessSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessSubscriptionUpdateArgs>(args: SelectSubset<T, BusinessSubscriptionUpdateArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessSubscriptions.
     * @param {BusinessSubscriptionDeleteManyArgs} args - Arguments to filter BusinessSubscriptions to delete.
     * @example
     * // Delete a few BusinessSubscriptions
     * const { count } = await prisma.businessSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessSubscriptionDeleteManyArgs>(args?: SelectSubset<T, BusinessSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessSubscriptions
     * const businessSubscription = await prisma.businessSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessSubscriptionUpdateManyArgs>(args: SelectSubset<T, BusinessSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessSubscription.
     * @param {BusinessSubscriptionUpsertArgs} args - Arguments to update or create a BusinessSubscription.
     * @example
     * // Update or create a BusinessSubscription
     * const businessSubscription = await prisma.businessSubscription.upsert({
     *   create: {
     *     // ... data to create a BusinessSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessSubscription we want to update
     *   }
     * })
     */
    upsert<T extends BusinessSubscriptionUpsertArgs>(args: SelectSubset<T, BusinessSubscriptionUpsertArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSubscriptionCountArgs} args - Arguments to filter BusinessSubscriptions to count.
     * @example
     * // Count the number of BusinessSubscriptions
     * const count = await prisma.businessSubscription.count({
     *   where: {
     *     // ... the filter for the BusinessSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends BusinessSubscriptionCountArgs>(
      args?: Subset<T, BusinessSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessSubscriptionAggregateArgs>(args: Subset<T, BusinessSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetBusinessSubscriptionAggregateType<T>>

    /**
     * Group by BusinessSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: BusinessSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessSubscription model
   */
  readonly fields: BusinessSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businesses<T extends BusinessSubscription$businessesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessSubscription$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessSubscription model
   */ 
  interface BusinessSubscriptionFieldRefs {
    readonly id: FieldRef<"BusinessSubscription", 'String'>
    readonly name: FieldRef<"BusinessSubscription", 'String'>
    readonly description: FieldRef<"BusinessSubscription", 'String'>
    readonly type: FieldRef<"BusinessSubscription", 'BusinessType'>
    readonly price: FieldRef<"BusinessSubscription", 'Float'>
    readonly duration: FieldRef<"BusinessSubscription", 'Int'>
    readonly features: FieldRef<"BusinessSubscription", 'String[]'>
    readonly tierLevel: FieldRef<"BusinessSubscription", 'Int'>
    readonly createdAt: FieldRef<"BusinessSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessSubscription", 'DateTime'>
    readonly deletedAt: FieldRef<"BusinessSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessSubscription findUnique
   */
  export type BusinessSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSubscription to fetch.
     */
    where: BusinessSubscriptionWhereUniqueInput
  }

  /**
   * BusinessSubscription findUniqueOrThrow
   */
  export type BusinessSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSubscription to fetch.
     */
    where: BusinessSubscriptionWhereUniqueInput
  }

  /**
   * BusinessSubscription findFirst
   */
  export type BusinessSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSubscription to fetch.
     */
    where?: BusinessSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSubscriptions to fetch.
     */
    orderBy?: BusinessSubscriptionOrderByWithRelationInput | BusinessSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessSubscriptions.
     */
    cursor?: BusinessSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessSubscriptions.
     */
    distinct?: BusinessSubscriptionScalarFieldEnum | BusinessSubscriptionScalarFieldEnum[]
  }

  /**
   * BusinessSubscription findFirstOrThrow
   */
  export type BusinessSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSubscription to fetch.
     */
    where?: BusinessSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSubscriptions to fetch.
     */
    orderBy?: BusinessSubscriptionOrderByWithRelationInput | BusinessSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessSubscriptions.
     */
    cursor?: BusinessSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessSubscriptions.
     */
    distinct?: BusinessSubscriptionScalarFieldEnum | BusinessSubscriptionScalarFieldEnum[]
  }

  /**
   * BusinessSubscription findMany
   */
  export type BusinessSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSubscriptions to fetch.
     */
    where?: BusinessSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSubscriptions to fetch.
     */
    orderBy?: BusinessSubscriptionOrderByWithRelationInput | BusinessSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessSubscriptions.
     */
    cursor?: BusinessSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSubscriptions.
     */
    skip?: number
    distinct?: BusinessSubscriptionScalarFieldEnum | BusinessSubscriptionScalarFieldEnum[]
  }

  /**
   * BusinessSubscription create
   */
  export type BusinessSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessSubscription.
     */
    data: XOR<BusinessSubscriptionCreateInput, BusinessSubscriptionUncheckedCreateInput>
  }

  /**
   * BusinessSubscription createMany
   */
  export type BusinessSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessSubscriptions.
     */
    data: BusinessSubscriptionCreateManyInput | BusinessSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessSubscription createManyAndReturn
   */
  export type BusinessSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessSubscriptions.
     */
    data: BusinessSubscriptionCreateManyInput | BusinessSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessSubscription update
   */
  export type BusinessSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessSubscription.
     */
    data: XOR<BusinessSubscriptionUpdateInput, BusinessSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which BusinessSubscription to update.
     */
    where: BusinessSubscriptionWhereUniqueInput
  }

  /**
   * BusinessSubscription updateMany
   */
  export type BusinessSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessSubscriptions.
     */
    data: XOR<BusinessSubscriptionUpdateManyMutationInput, BusinessSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which BusinessSubscriptions to update
     */
    where?: BusinessSubscriptionWhereInput
  }

  /**
   * BusinessSubscription upsert
   */
  export type BusinessSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessSubscription to update in case it exists.
     */
    where: BusinessSubscriptionWhereUniqueInput
    /**
     * In case the BusinessSubscription found by the `where` argument doesn't exist, create a new BusinessSubscription with this data.
     */
    create: XOR<BusinessSubscriptionCreateInput, BusinessSubscriptionUncheckedCreateInput>
    /**
     * In case the BusinessSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessSubscriptionUpdateInput, BusinessSubscriptionUncheckedUpdateInput>
  }

  /**
   * BusinessSubscription delete
   */
  export type BusinessSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which BusinessSubscription to delete.
     */
    where: BusinessSubscriptionWhereUniqueInput
  }

  /**
   * BusinessSubscription deleteMany
   */
  export type BusinessSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessSubscriptions to delete
     */
    where?: BusinessSubscriptionWhereInput
  }

  /**
   * BusinessSubscription.businesses
   */
  export type BusinessSubscription$businessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * BusinessSubscription without action
   */
  export type BusinessSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessAvgAggregateOutputType = {
    averageRating: number | null
    reviewCount: number | null
    price: number | null
  }

  export type BusinessSumAggregateOutputType = {
    averageRating: number | null
    reviewCount: number | null
    price: number | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    password: string | null
    salt: string | null
    isBusinessVerified: boolean | null
    type: $Enums.BusinessType | null
    subscriptionId: string | null
    subscriptionExpire: Date | null
    averageRating: number | null
    reviewCount: number | null
    isListed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    paymentVerification: boolean | null
    price: number | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    password: string | null
    salt: string | null
    isBusinessVerified: boolean | null
    type: $Enums.BusinessType | null
    subscriptionId: string | null
    subscriptionExpire: Date | null
    averageRating: number | null
    reviewCount: number | null
    isListed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    paymentVerification: boolean | null
    price: number | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    additionalContacts: number
    password: number
    salt: number
    isBusinessVerified: number
    type: number
    subscriptionId: number
    subscriptionExpire: number
    averageRating: number
    reviewCount: number
    isListed: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    paymentVerification: number
    price: number
    _all: number
  }


  export type BusinessAvgAggregateInputType = {
    averageRating?: true
    reviewCount?: true
    price?: true
  }

  export type BusinessSumAggregateInputType = {
    averageRating?: true
    reviewCount?: true
    price?: true
  }

  export type BusinessMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    password?: true
    salt?: true
    isBusinessVerified?: true
    type?: true
    subscriptionId?: true
    subscriptionExpire?: true
    averageRating?: true
    reviewCount?: true
    isListed?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    paymentVerification?: true
    price?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    password?: true
    salt?: true
    isBusinessVerified?: true
    type?: true
    subscriptionId?: true
    subscriptionExpire?: true
    averageRating?: true
    reviewCount?: true
    isListed?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    paymentVerification?: true
    price?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    additionalContacts?: true
    password?: true
    salt?: true
    isBusinessVerified?: true
    type?: true
    subscriptionId?: true
    subscriptionExpire?: true
    averageRating?: true
    reviewCount?: true
    isListed?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    paymentVerification?: true
    price?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _avg?: BusinessAvgAggregateInputType
    _sum?: BusinessSumAggregateInputType
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    name: string | null
    slug: string | null
    additionalContacts: string[]
    password: string | null
    salt: string | null
    isBusinessVerified: boolean
    type: $Enums.BusinessType
    subscriptionId: string | null
    subscriptionExpire: Date | null
    averageRating: number | null
    reviewCount: number
    isListed: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    paymentVerification: boolean
    price: number | null
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    additionalContacts?: boolean
    password?: boolean
    salt?: boolean
    isBusinessVerified?: boolean
    type?: boolean
    subscriptionId?: boolean
    subscriptionExpire?: boolean
    averageRating?: boolean
    reviewCount?: boolean
    isListed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    paymentVerification?: boolean
    price?: boolean
    primaryContacts?: boolean | Business$primaryContactsArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
    chats?: boolean | Business$chatsArgs<ExtArgs>
    bookings?: boolean | Business$bookingsArgs<ExtArgs>
    reviews?: boolean | Business$reviewsArgs<ExtArgs>
    businessSupportingDocuments?: boolean | Business$businessSupportingDocumentsArgs<ExtArgs>
    businessDetails?: boolean | Business$businessDetailsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    additionalContacts?: boolean
    password?: boolean
    salt?: boolean
    isBusinessVerified?: boolean
    type?: boolean
    subscriptionId?: boolean
    subscriptionExpire?: boolean
    averageRating?: boolean
    reviewCount?: boolean
    isListed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    paymentVerification?: boolean
    price?: boolean
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    additionalContacts?: boolean
    password?: boolean
    salt?: boolean
    isBusinessVerified?: boolean
    type?: boolean
    subscriptionId?: boolean
    subscriptionExpire?: boolean
    averageRating?: boolean
    reviewCount?: boolean
    isListed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    paymentVerification?: boolean
    price?: boolean
  }

  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryContacts?: boolean | Business$primaryContactsArgs<ExtArgs>
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
    chats?: boolean | Business$chatsArgs<ExtArgs>
    bookings?: boolean | Business$bookingsArgs<ExtArgs>
    reviews?: boolean | Business$reviewsArgs<ExtArgs>
    businessSupportingDocuments?: boolean | Business$businessSupportingDocumentsArgs<ExtArgs>
    businessDetails?: boolean | Business$businessDetailsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | Business$subscriptionArgs<ExtArgs>
  }

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      primaryContacts: Prisma.$BusinessPrimaryContactPayload<ExtArgs>[]
      subscription: Prisma.$BusinessSubscriptionPayload<ExtArgs> | null
      chats: Prisma.$ChatPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      businessSupportingDocuments: Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>[]
      businessDetails: Prisma.$BusinessDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      slug: string | null
      additionalContacts: string[]
      password: string | null
      salt: string | null
      isBusinessVerified: boolean
      type: $Enums.BusinessType
      subscriptionId: string | null
      subscriptionExpire: Date | null
      averageRating: number | null
      reviewCount: number
      isListed: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      paymentVerification: boolean
      price: number | null
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Businesses and returns the data saved in the database.
     * @param {BusinessCreateManyAndReturnArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    primaryContacts<T extends Business$primaryContactsArgs<ExtArgs> = {}>(args?: Subset<T, Business$primaryContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends Business$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Business$subscriptionArgs<ExtArgs>>): Prisma__BusinessSubscriptionClient<$Result.GetResult<Prisma.$BusinessSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chats<T extends Business$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Business$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Business$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Business$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Business$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Business$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    businessSupportingDocuments<T extends Business$businessSupportingDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Business$businessSupportingDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    businessDetails<T extends Business$businessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Business$businessDetailsArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */ 
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly name: FieldRef<"Business", 'String'>
    readonly slug: FieldRef<"Business", 'String'>
    readonly additionalContacts: FieldRef<"Business", 'String[]'>
    readonly password: FieldRef<"Business", 'String'>
    readonly salt: FieldRef<"Business", 'String'>
    readonly isBusinessVerified: FieldRef<"Business", 'Boolean'>
    readonly type: FieldRef<"Business", 'BusinessType'>
    readonly subscriptionId: FieldRef<"Business", 'String'>
    readonly subscriptionExpire: FieldRef<"Business", 'DateTime'>
    readonly averageRating: FieldRef<"Business", 'Float'>
    readonly reviewCount: FieldRef<"Business", 'Int'>
    readonly isListed: FieldRef<"Business", 'Boolean'>
    readonly createdAt: FieldRef<"Business", 'DateTime'>
    readonly updatedAt: FieldRef<"Business", 'DateTime'>
    readonly deletedAt: FieldRef<"Business", 'DateTime'>
    readonly paymentVerification: FieldRef<"Business", 'Boolean'>
    readonly price: FieldRef<"Business", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business createManyAndReturn
   */
  export type BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
  }

  /**
   * Business.primaryContacts
   */
  export type Business$primaryContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    where?: BusinessPrimaryContactWhereInput
    orderBy?: BusinessPrimaryContactOrderByWithRelationInput | BusinessPrimaryContactOrderByWithRelationInput[]
    cursor?: BusinessPrimaryContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessPrimaryContactScalarFieldEnum | BusinessPrimaryContactScalarFieldEnum[]
  }

  /**
   * Business.subscription
   */
  export type Business$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSubscription
     */
    select?: BusinessSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSubscriptionInclude<ExtArgs> | null
    where?: BusinessSubscriptionWhereInput
  }

  /**
   * Business.chats
   */
  export type Business$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Business.bookings
   */
  export type Business$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Business.reviews
   */
  export type Business$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Business.businessSupportingDocuments
   */
  export type Business$businessSupportingDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    where?: BusinessSupportingDocumentsWhereInput
    orderBy?: BusinessSupportingDocumentsOrderByWithRelationInput | BusinessSupportingDocumentsOrderByWithRelationInput[]
    cursor?: BusinessSupportingDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessSupportingDocumentsScalarFieldEnum | BusinessSupportingDocumentsScalarFieldEnum[]
  }

  /**
   * Business.businessDetails
   */
  export type Business$businessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model BusinessPrimaryContact
   */

  export type AggregateBusinessPrimaryContact = {
    _count: BusinessPrimaryContactCountAggregateOutputType | null
    _avg: BusinessPrimaryContactAvgAggregateOutputType | null
    _sum: BusinessPrimaryContactSumAggregateOutputType | null
    _min: BusinessPrimaryContactMinAggregateOutputType | null
    _max: BusinessPrimaryContactMaxAggregateOutputType | null
  }

  export type BusinessPrimaryContactAvgAggregateOutputType = {
    order: number | null
  }

  export type BusinessPrimaryContactSumAggregateOutputType = {
    order: number | null
  }

  export type BusinessPrimaryContactMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    type: $Enums.ContactType | null
    value: string | null
    isVerified: boolean | null
    isPrimary: boolean | null
    order: number | null
    verifiedAt: Date | null
    otp: string | null
    otpExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessPrimaryContactMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    type: $Enums.ContactType | null
    value: string | null
    isVerified: boolean | null
    isPrimary: boolean | null
    order: number | null
    verifiedAt: Date | null
    otp: string | null
    otpExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessPrimaryContactCountAggregateOutputType = {
    id: number
    businessId: number
    type: number
    value: number
    isVerified: number
    isPrimary: number
    order: number
    verifiedAt: number
    otp: number
    otpExpiresAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BusinessPrimaryContactAvgAggregateInputType = {
    order?: true
  }

  export type BusinessPrimaryContactSumAggregateInputType = {
    order?: true
  }

  export type BusinessPrimaryContactMinAggregateInputType = {
    id?: true
    businessId?: true
    type?: true
    value?: true
    isVerified?: true
    isPrimary?: true
    order?: true
    verifiedAt?: true
    otp?: true
    otpExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessPrimaryContactMaxAggregateInputType = {
    id?: true
    businessId?: true
    type?: true
    value?: true
    isVerified?: true
    isPrimary?: true
    order?: true
    verifiedAt?: true
    otp?: true
    otpExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessPrimaryContactCountAggregateInputType = {
    id?: true
    businessId?: true
    type?: true
    value?: true
    isVerified?: true
    isPrimary?: true
    order?: true
    verifiedAt?: true
    otp?: true
    otpExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BusinessPrimaryContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessPrimaryContact to aggregate.
     */
    where?: BusinessPrimaryContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPrimaryContacts to fetch.
     */
    orderBy?: BusinessPrimaryContactOrderByWithRelationInput | BusinessPrimaryContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessPrimaryContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPrimaryContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPrimaryContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessPrimaryContacts
    **/
    _count?: true | BusinessPrimaryContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessPrimaryContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessPrimaryContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessPrimaryContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessPrimaryContactMaxAggregateInputType
  }

  export type GetBusinessPrimaryContactAggregateType<T extends BusinessPrimaryContactAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessPrimaryContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessPrimaryContact[P]>
      : GetScalarType<T[P], AggregateBusinessPrimaryContact[P]>
  }




  export type BusinessPrimaryContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessPrimaryContactWhereInput
    orderBy?: BusinessPrimaryContactOrderByWithAggregationInput | BusinessPrimaryContactOrderByWithAggregationInput[]
    by: BusinessPrimaryContactScalarFieldEnum[] | BusinessPrimaryContactScalarFieldEnum
    having?: BusinessPrimaryContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessPrimaryContactCountAggregateInputType | true
    _avg?: BusinessPrimaryContactAvgAggregateInputType
    _sum?: BusinessPrimaryContactSumAggregateInputType
    _min?: BusinessPrimaryContactMinAggregateInputType
    _max?: BusinessPrimaryContactMaxAggregateInputType
  }

  export type BusinessPrimaryContactGroupByOutputType = {
    id: string
    businessId: string
    type: $Enums.ContactType
    value: string
    isVerified: boolean
    isPrimary: boolean
    order: number | null
    verifiedAt: Date | null
    otp: string | null
    otpExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BusinessPrimaryContactCountAggregateOutputType | null
    _avg: BusinessPrimaryContactAvgAggregateOutputType | null
    _sum: BusinessPrimaryContactSumAggregateOutputType | null
    _min: BusinessPrimaryContactMinAggregateOutputType | null
    _max: BusinessPrimaryContactMaxAggregateOutputType | null
  }

  type GetBusinessPrimaryContactGroupByPayload<T extends BusinessPrimaryContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessPrimaryContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessPrimaryContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessPrimaryContactGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessPrimaryContactGroupByOutputType[P]>
        }
      >
    >


  export type BusinessPrimaryContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    type?: boolean
    value?: boolean
    isVerified?: boolean
    isPrimary?: boolean
    order?: boolean
    verifiedAt?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessPrimaryContact"]>

  export type BusinessPrimaryContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    type?: boolean
    value?: boolean
    isVerified?: boolean
    isPrimary?: boolean
    order?: boolean
    verifiedAt?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessPrimaryContact"]>

  export type BusinessPrimaryContactSelectScalar = {
    id?: boolean
    businessId?: boolean
    type?: boolean
    value?: boolean
    isVerified?: boolean
    isPrimary?: boolean
    order?: boolean
    verifiedAt?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BusinessPrimaryContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type BusinessPrimaryContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $BusinessPrimaryContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessPrimaryContact"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      type: $Enums.ContactType
      value: string
      isVerified: boolean
      isPrimary: boolean
      order: number | null
      verifiedAt: Date | null
      otp: string | null
      otpExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["businessPrimaryContact"]>
    composites: {}
  }

  type BusinessPrimaryContactGetPayload<S extends boolean | null | undefined | BusinessPrimaryContactDefaultArgs> = $Result.GetResult<Prisma.$BusinessPrimaryContactPayload, S>

  type BusinessPrimaryContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessPrimaryContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessPrimaryContactCountAggregateInputType | true
    }

  export interface BusinessPrimaryContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessPrimaryContact'], meta: { name: 'BusinessPrimaryContact' } }
    /**
     * Find zero or one BusinessPrimaryContact that matches the filter.
     * @param {BusinessPrimaryContactFindUniqueArgs} args - Arguments to find a BusinessPrimaryContact
     * @example
     * // Get one BusinessPrimaryContact
     * const businessPrimaryContact = await prisma.businessPrimaryContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessPrimaryContactFindUniqueArgs>(args: SelectSubset<T, BusinessPrimaryContactFindUniqueArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessPrimaryContact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessPrimaryContactFindUniqueOrThrowArgs} args - Arguments to find a BusinessPrimaryContact
     * @example
     * // Get one BusinessPrimaryContact
     * const businessPrimaryContact = await prisma.businessPrimaryContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessPrimaryContactFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessPrimaryContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessPrimaryContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPrimaryContactFindFirstArgs} args - Arguments to find a BusinessPrimaryContact
     * @example
     * // Get one BusinessPrimaryContact
     * const businessPrimaryContact = await prisma.businessPrimaryContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessPrimaryContactFindFirstArgs>(args?: SelectSubset<T, BusinessPrimaryContactFindFirstArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessPrimaryContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPrimaryContactFindFirstOrThrowArgs} args - Arguments to find a BusinessPrimaryContact
     * @example
     * // Get one BusinessPrimaryContact
     * const businessPrimaryContact = await prisma.businessPrimaryContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessPrimaryContactFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessPrimaryContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessPrimaryContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPrimaryContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessPrimaryContacts
     * const businessPrimaryContacts = await prisma.businessPrimaryContact.findMany()
     * 
     * // Get first 10 BusinessPrimaryContacts
     * const businessPrimaryContacts = await prisma.businessPrimaryContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessPrimaryContactWithIdOnly = await prisma.businessPrimaryContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessPrimaryContactFindManyArgs>(args?: SelectSubset<T, BusinessPrimaryContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessPrimaryContact.
     * @param {BusinessPrimaryContactCreateArgs} args - Arguments to create a BusinessPrimaryContact.
     * @example
     * // Create one BusinessPrimaryContact
     * const BusinessPrimaryContact = await prisma.businessPrimaryContact.create({
     *   data: {
     *     // ... data to create a BusinessPrimaryContact
     *   }
     * })
     * 
     */
    create<T extends BusinessPrimaryContactCreateArgs>(args: SelectSubset<T, BusinessPrimaryContactCreateArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessPrimaryContacts.
     * @param {BusinessPrimaryContactCreateManyArgs} args - Arguments to create many BusinessPrimaryContacts.
     * @example
     * // Create many BusinessPrimaryContacts
     * const businessPrimaryContact = await prisma.businessPrimaryContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessPrimaryContactCreateManyArgs>(args?: SelectSubset<T, BusinessPrimaryContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessPrimaryContacts and returns the data saved in the database.
     * @param {BusinessPrimaryContactCreateManyAndReturnArgs} args - Arguments to create many BusinessPrimaryContacts.
     * @example
     * // Create many BusinessPrimaryContacts
     * const businessPrimaryContact = await prisma.businessPrimaryContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessPrimaryContacts and only return the `id`
     * const businessPrimaryContactWithIdOnly = await prisma.businessPrimaryContact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessPrimaryContactCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessPrimaryContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessPrimaryContact.
     * @param {BusinessPrimaryContactDeleteArgs} args - Arguments to delete one BusinessPrimaryContact.
     * @example
     * // Delete one BusinessPrimaryContact
     * const BusinessPrimaryContact = await prisma.businessPrimaryContact.delete({
     *   where: {
     *     // ... filter to delete one BusinessPrimaryContact
     *   }
     * })
     * 
     */
    delete<T extends BusinessPrimaryContactDeleteArgs>(args: SelectSubset<T, BusinessPrimaryContactDeleteArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessPrimaryContact.
     * @param {BusinessPrimaryContactUpdateArgs} args - Arguments to update one BusinessPrimaryContact.
     * @example
     * // Update one BusinessPrimaryContact
     * const businessPrimaryContact = await prisma.businessPrimaryContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessPrimaryContactUpdateArgs>(args: SelectSubset<T, BusinessPrimaryContactUpdateArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessPrimaryContacts.
     * @param {BusinessPrimaryContactDeleteManyArgs} args - Arguments to filter BusinessPrimaryContacts to delete.
     * @example
     * // Delete a few BusinessPrimaryContacts
     * const { count } = await prisma.businessPrimaryContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessPrimaryContactDeleteManyArgs>(args?: SelectSubset<T, BusinessPrimaryContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessPrimaryContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPrimaryContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessPrimaryContacts
     * const businessPrimaryContact = await prisma.businessPrimaryContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessPrimaryContactUpdateManyArgs>(args: SelectSubset<T, BusinessPrimaryContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessPrimaryContact.
     * @param {BusinessPrimaryContactUpsertArgs} args - Arguments to update or create a BusinessPrimaryContact.
     * @example
     * // Update or create a BusinessPrimaryContact
     * const businessPrimaryContact = await prisma.businessPrimaryContact.upsert({
     *   create: {
     *     // ... data to create a BusinessPrimaryContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessPrimaryContact we want to update
     *   }
     * })
     */
    upsert<T extends BusinessPrimaryContactUpsertArgs>(args: SelectSubset<T, BusinessPrimaryContactUpsertArgs<ExtArgs>>): Prisma__BusinessPrimaryContactClient<$Result.GetResult<Prisma.$BusinessPrimaryContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessPrimaryContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPrimaryContactCountArgs} args - Arguments to filter BusinessPrimaryContacts to count.
     * @example
     * // Count the number of BusinessPrimaryContacts
     * const count = await prisma.businessPrimaryContact.count({
     *   where: {
     *     // ... the filter for the BusinessPrimaryContacts we want to count
     *   }
     * })
    **/
    count<T extends BusinessPrimaryContactCountArgs>(
      args?: Subset<T, BusinessPrimaryContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessPrimaryContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessPrimaryContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPrimaryContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessPrimaryContactAggregateArgs>(args: Subset<T, BusinessPrimaryContactAggregateArgs>): Prisma.PrismaPromise<GetBusinessPrimaryContactAggregateType<T>>

    /**
     * Group by BusinessPrimaryContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPrimaryContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessPrimaryContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessPrimaryContactGroupByArgs['orderBy'] }
        : { orderBy?: BusinessPrimaryContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessPrimaryContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessPrimaryContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessPrimaryContact model
   */
  readonly fields: BusinessPrimaryContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessPrimaryContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessPrimaryContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessPrimaryContact model
   */ 
  interface BusinessPrimaryContactFieldRefs {
    readonly id: FieldRef<"BusinessPrimaryContact", 'String'>
    readonly businessId: FieldRef<"BusinessPrimaryContact", 'String'>
    readonly type: FieldRef<"BusinessPrimaryContact", 'ContactType'>
    readonly value: FieldRef<"BusinessPrimaryContact", 'String'>
    readonly isVerified: FieldRef<"BusinessPrimaryContact", 'Boolean'>
    readonly isPrimary: FieldRef<"BusinessPrimaryContact", 'Boolean'>
    readonly order: FieldRef<"BusinessPrimaryContact", 'Int'>
    readonly verifiedAt: FieldRef<"BusinessPrimaryContact", 'DateTime'>
    readonly otp: FieldRef<"BusinessPrimaryContact", 'String'>
    readonly otpExpiresAt: FieldRef<"BusinessPrimaryContact", 'DateTime'>
    readonly createdAt: FieldRef<"BusinessPrimaryContact", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessPrimaryContact", 'DateTime'>
    readonly deletedAt: FieldRef<"BusinessPrimaryContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessPrimaryContact findUnique
   */
  export type BusinessPrimaryContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPrimaryContact to fetch.
     */
    where: BusinessPrimaryContactWhereUniqueInput
  }

  /**
   * BusinessPrimaryContact findUniqueOrThrow
   */
  export type BusinessPrimaryContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPrimaryContact to fetch.
     */
    where: BusinessPrimaryContactWhereUniqueInput
  }

  /**
   * BusinessPrimaryContact findFirst
   */
  export type BusinessPrimaryContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPrimaryContact to fetch.
     */
    where?: BusinessPrimaryContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPrimaryContacts to fetch.
     */
    orderBy?: BusinessPrimaryContactOrderByWithRelationInput | BusinessPrimaryContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessPrimaryContacts.
     */
    cursor?: BusinessPrimaryContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPrimaryContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPrimaryContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessPrimaryContacts.
     */
    distinct?: BusinessPrimaryContactScalarFieldEnum | BusinessPrimaryContactScalarFieldEnum[]
  }

  /**
   * BusinessPrimaryContact findFirstOrThrow
   */
  export type BusinessPrimaryContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPrimaryContact to fetch.
     */
    where?: BusinessPrimaryContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPrimaryContacts to fetch.
     */
    orderBy?: BusinessPrimaryContactOrderByWithRelationInput | BusinessPrimaryContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessPrimaryContacts.
     */
    cursor?: BusinessPrimaryContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPrimaryContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPrimaryContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessPrimaryContacts.
     */
    distinct?: BusinessPrimaryContactScalarFieldEnum | BusinessPrimaryContactScalarFieldEnum[]
  }

  /**
   * BusinessPrimaryContact findMany
   */
  export type BusinessPrimaryContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPrimaryContacts to fetch.
     */
    where?: BusinessPrimaryContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPrimaryContacts to fetch.
     */
    orderBy?: BusinessPrimaryContactOrderByWithRelationInput | BusinessPrimaryContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessPrimaryContacts.
     */
    cursor?: BusinessPrimaryContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPrimaryContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPrimaryContacts.
     */
    skip?: number
    distinct?: BusinessPrimaryContactScalarFieldEnum | BusinessPrimaryContactScalarFieldEnum[]
  }

  /**
   * BusinessPrimaryContact create
   */
  export type BusinessPrimaryContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessPrimaryContact.
     */
    data: XOR<BusinessPrimaryContactCreateInput, BusinessPrimaryContactUncheckedCreateInput>
  }

  /**
   * BusinessPrimaryContact createMany
   */
  export type BusinessPrimaryContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessPrimaryContacts.
     */
    data: BusinessPrimaryContactCreateManyInput | BusinessPrimaryContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessPrimaryContact createManyAndReturn
   */
  export type BusinessPrimaryContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessPrimaryContacts.
     */
    data: BusinessPrimaryContactCreateManyInput | BusinessPrimaryContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessPrimaryContact update
   */
  export type BusinessPrimaryContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessPrimaryContact.
     */
    data: XOR<BusinessPrimaryContactUpdateInput, BusinessPrimaryContactUncheckedUpdateInput>
    /**
     * Choose, which BusinessPrimaryContact to update.
     */
    where: BusinessPrimaryContactWhereUniqueInput
  }

  /**
   * BusinessPrimaryContact updateMany
   */
  export type BusinessPrimaryContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessPrimaryContacts.
     */
    data: XOR<BusinessPrimaryContactUpdateManyMutationInput, BusinessPrimaryContactUncheckedUpdateManyInput>
    /**
     * Filter which BusinessPrimaryContacts to update
     */
    where?: BusinessPrimaryContactWhereInput
  }

  /**
   * BusinessPrimaryContact upsert
   */
  export type BusinessPrimaryContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessPrimaryContact to update in case it exists.
     */
    where: BusinessPrimaryContactWhereUniqueInput
    /**
     * In case the BusinessPrimaryContact found by the `where` argument doesn't exist, create a new BusinessPrimaryContact with this data.
     */
    create: XOR<BusinessPrimaryContactCreateInput, BusinessPrimaryContactUncheckedCreateInput>
    /**
     * In case the BusinessPrimaryContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessPrimaryContactUpdateInput, BusinessPrimaryContactUncheckedUpdateInput>
  }

  /**
   * BusinessPrimaryContact delete
   */
  export type BusinessPrimaryContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
    /**
     * Filter which BusinessPrimaryContact to delete.
     */
    where: BusinessPrimaryContactWhereUniqueInput
  }

  /**
   * BusinessPrimaryContact deleteMany
   */
  export type BusinessPrimaryContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessPrimaryContacts to delete
     */
    where?: BusinessPrimaryContactWhereInput
  }

  /**
   * BusinessPrimaryContact without action
   */
  export type BusinessPrimaryContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPrimaryContact
     */
    select?: BusinessPrimaryContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPrimaryContactInclude<ExtArgs> | null
  }


  /**
   * Model BusinessAddress
   */

  export type AggregateBusinessAddress = {
    _count: BusinessAddressCountAggregateOutputType | null
    _avg: BusinessAddressAvgAggregateOutputType | null
    _sum: BusinessAddressSumAggregateOutputType | null
    _min: BusinessAddressMinAggregateOutputType | null
    _max: BusinessAddressMaxAggregateOutputType | null
  }

  export type BusinessAddressAvgAggregateOutputType = {
    order: number | null
  }

  export type BusinessAddressSumAggregateOutputType = {
    order: number | null
  }

  export type BusinessAddressMinAggregateOutputType = {
    id: string | null
    businessDetailsId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    order: number | null
    street: string | null
    city: string | null
    country: string | null
    pincode: string | null
    state: string | null
  }

  export type BusinessAddressMaxAggregateOutputType = {
    id: string | null
    businessDetailsId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    order: number | null
    street: string | null
    city: string | null
    country: string | null
    pincode: string | null
    state: string | null
  }

  export type BusinessAddressCountAggregateOutputType = {
    id: number
    businessDetailsId: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    order: number
    street: number
    city: number
    country: number
    pincode: number
    state: number
    _all: number
  }


  export type BusinessAddressAvgAggregateInputType = {
    order?: true
  }

  export type BusinessAddressSumAggregateInputType = {
    order?: true
  }

  export type BusinessAddressMinAggregateInputType = {
    id?: true
    businessDetailsId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    order?: true
    street?: true
    city?: true
    country?: true
    pincode?: true
    state?: true
  }

  export type BusinessAddressMaxAggregateInputType = {
    id?: true
    businessDetailsId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    order?: true
    street?: true
    city?: true
    country?: true
    pincode?: true
    state?: true
  }

  export type BusinessAddressCountAggregateInputType = {
    id?: true
    businessDetailsId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    order?: true
    street?: true
    city?: true
    country?: true
    pincode?: true
    state?: true
    _all?: true
  }

  export type BusinessAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessAddress to aggregate.
     */
    where?: BusinessAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAddresses to fetch.
     */
    orderBy?: BusinessAddressOrderByWithRelationInput | BusinessAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessAddresses
    **/
    _count?: true | BusinessAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessAddressMaxAggregateInputType
  }

  export type GetBusinessAddressAggregateType<T extends BusinessAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessAddress[P]>
      : GetScalarType<T[P], AggregateBusinessAddress[P]>
  }




  export type BusinessAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessAddressWhereInput
    orderBy?: BusinessAddressOrderByWithAggregationInput | BusinessAddressOrderByWithAggregationInput[]
    by: BusinessAddressScalarFieldEnum[] | BusinessAddressScalarFieldEnum
    having?: BusinessAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessAddressCountAggregateInputType | true
    _avg?: BusinessAddressAvgAggregateInputType
    _sum?: BusinessAddressSumAggregateInputType
    _min?: BusinessAddressMinAggregateInputType
    _max?: BusinessAddressMaxAggregateInputType
  }

  export type BusinessAddressGroupByOutputType = {
    id: string
    businessDetailsId: string | null
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    order: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
    _count: BusinessAddressCountAggregateOutputType | null
    _avg: BusinessAddressAvgAggregateOutputType | null
    _sum: BusinessAddressSumAggregateOutputType | null
    _min: BusinessAddressMinAggregateOutputType | null
    _max: BusinessAddressMaxAggregateOutputType | null
  }

  type GetBusinessAddressGroupByPayload<T extends BusinessAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessAddressGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessAddressGroupByOutputType[P]>
        }
      >
    >


  export type BusinessAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessDetailsId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    order?: boolean
    street?: boolean
    city?: boolean
    country?: boolean
    pincode?: boolean
    state?: boolean
    businessDetails?: boolean | BusinessAddress$businessDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["businessAddress"]>

  export type BusinessAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessDetailsId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    order?: boolean
    street?: boolean
    city?: boolean
    country?: boolean
    pincode?: boolean
    state?: boolean
    businessDetails?: boolean | BusinessAddress$businessDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["businessAddress"]>

  export type BusinessAddressSelectScalar = {
    id?: boolean
    businessDetailsId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    order?: boolean
    street?: boolean
    city?: boolean
    country?: boolean
    pincode?: boolean
    state?: boolean
  }

  export type BusinessAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | BusinessAddress$businessDetailsArgs<ExtArgs>
  }
  export type BusinessAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | BusinessAddress$businessDetailsArgs<ExtArgs>
  }

  export type $BusinessAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessAddress"
    objects: {
      businessDetails: Prisma.$BusinessDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessDetailsId: string | null
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
      order: number | null
      street: string
      city: string
      country: string
      pincode: string
      state: string
    }, ExtArgs["result"]["businessAddress"]>
    composites: {}
  }

  type BusinessAddressGetPayload<S extends boolean | null | undefined | BusinessAddressDefaultArgs> = $Result.GetResult<Prisma.$BusinessAddressPayload, S>

  type BusinessAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessAddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessAddressCountAggregateInputType | true
    }

  export interface BusinessAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessAddress'], meta: { name: 'BusinessAddress' } }
    /**
     * Find zero or one BusinessAddress that matches the filter.
     * @param {BusinessAddressFindUniqueArgs} args - Arguments to find a BusinessAddress
     * @example
     * // Get one BusinessAddress
     * const businessAddress = await prisma.businessAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessAddressFindUniqueArgs>(args: SelectSubset<T, BusinessAddressFindUniqueArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessAddress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessAddressFindUniqueOrThrowArgs} args - Arguments to find a BusinessAddress
     * @example
     * // Get one BusinessAddress
     * const businessAddress = await prisma.businessAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAddressFindFirstArgs} args - Arguments to find a BusinessAddress
     * @example
     * // Get one BusinessAddress
     * const businessAddress = await prisma.businessAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessAddressFindFirstArgs>(args?: SelectSubset<T, BusinessAddressFindFirstArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAddressFindFirstOrThrowArgs} args - Arguments to find a BusinessAddress
     * @example
     * // Get one BusinessAddress
     * const businessAddress = await prisma.businessAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessAddresses
     * const businessAddresses = await prisma.businessAddress.findMany()
     * 
     * // Get first 10 BusinessAddresses
     * const businessAddresses = await prisma.businessAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessAddressWithIdOnly = await prisma.businessAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessAddressFindManyArgs>(args?: SelectSubset<T, BusinessAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessAddress.
     * @param {BusinessAddressCreateArgs} args - Arguments to create a BusinessAddress.
     * @example
     * // Create one BusinessAddress
     * const BusinessAddress = await prisma.businessAddress.create({
     *   data: {
     *     // ... data to create a BusinessAddress
     *   }
     * })
     * 
     */
    create<T extends BusinessAddressCreateArgs>(args: SelectSubset<T, BusinessAddressCreateArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessAddresses.
     * @param {BusinessAddressCreateManyArgs} args - Arguments to create many BusinessAddresses.
     * @example
     * // Create many BusinessAddresses
     * const businessAddress = await prisma.businessAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessAddressCreateManyArgs>(args?: SelectSubset<T, BusinessAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessAddresses and returns the data saved in the database.
     * @param {BusinessAddressCreateManyAndReturnArgs} args - Arguments to create many BusinessAddresses.
     * @example
     * // Create many BusinessAddresses
     * const businessAddress = await prisma.businessAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessAddresses and only return the `id`
     * const businessAddressWithIdOnly = await prisma.businessAddress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessAddress.
     * @param {BusinessAddressDeleteArgs} args - Arguments to delete one BusinessAddress.
     * @example
     * // Delete one BusinessAddress
     * const BusinessAddress = await prisma.businessAddress.delete({
     *   where: {
     *     // ... filter to delete one BusinessAddress
     *   }
     * })
     * 
     */
    delete<T extends BusinessAddressDeleteArgs>(args: SelectSubset<T, BusinessAddressDeleteArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessAddress.
     * @param {BusinessAddressUpdateArgs} args - Arguments to update one BusinessAddress.
     * @example
     * // Update one BusinessAddress
     * const businessAddress = await prisma.businessAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessAddressUpdateArgs>(args: SelectSubset<T, BusinessAddressUpdateArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessAddresses.
     * @param {BusinessAddressDeleteManyArgs} args - Arguments to filter BusinessAddresses to delete.
     * @example
     * // Delete a few BusinessAddresses
     * const { count } = await prisma.businessAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessAddressDeleteManyArgs>(args?: SelectSubset<T, BusinessAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessAddresses
     * const businessAddress = await prisma.businessAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessAddressUpdateManyArgs>(args: SelectSubset<T, BusinessAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessAddress.
     * @param {BusinessAddressUpsertArgs} args - Arguments to update or create a BusinessAddress.
     * @example
     * // Update or create a BusinessAddress
     * const businessAddress = await prisma.businessAddress.upsert({
     *   create: {
     *     // ... data to create a BusinessAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessAddress we want to update
     *   }
     * })
     */
    upsert<T extends BusinessAddressUpsertArgs>(args: SelectSubset<T, BusinessAddressUpsertArgs<ExtArgs>>): Prisma__BusinessAddressClient<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAddressCountArgs} args - Arguments to filter BusinessAddresses to count.
     * @example
     * // Count the number of BusinessAddresses
     * const count = await prisma.businessAddress.count({
     *   where: {
     *     // ... the filter for the BusinessAddresses we want to count
     *   }
     * })
    **/
    count<T extends BusinessAddressCountArgs>(
      args?: Subset<T, BusinessAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAddressAggregateArgs>(args: Subset<T, BusinessAddressAggregateArgs>): Prisma.PrismaPromise<GetBusinessAddressAggregateType<T>>

    /**
     * Group by BusinessAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessAddressGroupByArgs['orderBy'] }
        : { orderBy?: BusinessAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessAddress model
   */
  readonly fields: BusinessAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessDetails<T extends BusinessAddress$businessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessAddress$businessDetailsArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessAddress model
   */ 
  interface BusinessAddressFieldRefs {
    readonly id: FieldRef<"BusinessAddress", 'String'>
    readonly businessDetailsId: FieldRef<"BusinessAddress", 'String'>
    readonly createdAt: FieldRef<"BusinessAddress", 'DateTime'>
    readonly deletedAt: FieldRef<"BusinessAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessAddress", 'DateTime'>
    readonly order: FieldRef<"BusinessAddress", 'Int'>
    readonly street: FieldRef<"BusinessAddress", 'String'>
    readonly city: FieldRef<"BusinessAddress", 'String'>
    readonly country: FieldRef<"BusinessAddress", 'String'>
    readonly pincode: FieldRef<"BusinessAddress", 'String'>
    readonly state: FieldRef<"BusinessAddress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessAddress findUnique
   */
  export type BusinessAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAddress to fetch.
     */
    where: BusinessAddressWhereUniqueInput
  }

  /**
   * BusinessAddress findUniqueOrThrow
   */
  export type BusinessAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAddress to fetch.
     */
    where: BusinessAddressWhereUniqueInput
  }

  /**
   * BusinessAddress findFirst
   */
  export type BusinessAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAddress to fetch.
     */
    where?: BusinessAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAddresses to fetch.
     */
    orderBy?: BusinessAddressOrderByWithRelationInput | BusinessAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessAddresses.
     */
    cursor?: BusinessAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessAddresses.
     */
    distinct?: BusinessAddressScalarFieldEnum | BusinessAddressScalarFieldEnum[]
  }

  /**
   * BusinessAddress findFirstOrThrow
   */
  export type BusinessAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAddress to fetch.
     */
    where?: BusinessAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAddresses to fetch.
     */
    orderBy?: BusinessAddressOrderByWithRelationInput | BusinessAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessAddresses.
     */
    cursor?: BusinessAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessAddresses.
     */
    distinct?: BusinessAddressScalarFieldEnum | BusinessAddressScalarFieldEnum[]
  }

  /**
   * BusinessAddress findMany
   */
  export type BusinessAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * Filter, which BusinessAddresses to fetch.
     */
    where?: BusinessAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessAddresses to fetch.
     */
    orderBy?: BusinessAddressOrderByWithRelationInput | BusinessAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessAddresses.
     */
    cursor?: BusinessAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessAddresses.
     */
    skip?: number
    distinct?: BusinessAddressScalarFieldEnum | BusinessAddressScalarFieldEnum[]
  }

  /**
   * BusinessAddress create
   */
  export type BusinessAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessAddress.
     */
    data: XOR<BusinessAddressCreateInput, BusinessAddressUncheckedCreateInput>
  }

  /**
   * BusinessAddress createMany
   */
  export type BusinessAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessAddresses.
     */
    data: BusinessAddressCreateManyInput | BusinessAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessAddress createManyAndReturn
   */
  export type BusinessAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessAddresses.
     */
    data: BusinessAddressCreateManyInput | BusinessAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessAddress update
   */
  export type BusinessAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessAddress.
     */
    data: XOR<BusinessAddressUpdateInput, BusinessAddressUncheckedUpdateInput>
    /**
     * Choose, which BusinessAddress to update.
     */
    where: BusinessAddressWhereUniqueInput
  }

  /**
   * BusinessAddress updateMany
   */
  export type BusinessAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessAddresses.
     */
    data: XOR<BusinessAddressUpdateManyMutationInput, BusinessAddressUncheckedUpdateManyInput>
    /**
     * Filter which BusinessAddresses to update
     */
    where?: BusinessAddressWhereInput
  }

  /**
   * BusinessAddress upsert
   */
  export type BusinessAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessAddress to update in case it exists.
     */
    where: BusinessAddressWhereUniqueInput
    /**
     * In case the BusinessAddress found by the `where` argument doesn't exist, create a new BusinessAddress with this data.
     */
    create: XOR<BusinessAddressCreateInput, BusinessAddressUncheckedCreateInput>
    /**
     * In case the BusinessAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessAddressUpdateInput, BusinessAddressUncheckedUpdateInput>
  }

  /**
   * BusinessAddress delete
   */
  export type BusinessAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    /**
     * Filter which BusinessAddress to delete.
     */
    where: BusinessAddressWhereUniqueInput
  }

  /**
   * BusinessAddress deleteMany
   */
  export type BusinessAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessAddresses to delete
     */
    where?: BusinessAddressWhereInput
  }

  /**
   * BusinessAddress.businessDetails
   */
  export type BusinessAddress$businessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
  }

  /**
   * BusinessAddress without action
   */
  export type BusinessAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
  }


  /**
   * Model BusinessDetails
   */

  export type AggregateBusinessDetails = {
    _count: BusinessDetailsCountAggregateOutputType | null
    _avg: BusinessDetailsAvgAggregateOutputType | null
    _sum: BusinessDetailsSumAggregateOutputType | null
    _min: BusinessDetailsMinAggregateOutputType | null
    _max: BusinessDetailsMaxAggregateOutputType | null
  }

  export type BusinessDetailsAvgAggregateOutputType = {
    experience: number | null
    teamSize: number | null
    latitude: number | null
    longitude: number | null
  }

  export type BusinessDetailsSumAggregateOutputType = {
    experience: number | null
    teamSize: number | null
    latitude: number | null
    longitude: number | null
  }

  export type BusinessDetailsMinAggregateOutputType = {
    id: string | null
    registrationNumber: string | null
    license: string | null
    experience: number | null
    teamSize: number | null
    description: string | null
    latitude: number | null
    longitude: number | null
    gstNumber: string | null
    categoryId: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessDetailsMaxAggregateOutputType = {
    id: string | null
    registrationNumber: string | null
    license: string | null
    experience: number | null
    teamSize: number | null
    description: string | null
    latitude: number | null
    longitude: number | null
    gstNumber: string | null
    categoryId: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessDetailsCountAggregateOutputType = {
    id: number
    registrationNumber: number
    license: number
    experience: number
    teamSize: number
    description: number
    latitude: number
    longitude: number
    degree: number
    gstNumber: number
    categoryId: number
    logo: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BusinessDetailsAvgAggregateInputType = {
    experience?: true
    teamSize?: true
    latitude?: true
    longitude?: true
  }

  export type BusinessDetailsSumAggregateInputType = {
    experience?: true
    teamSize?: true
    latitude?: true
    longitude?: true
  }

  export type BusinessDetailsMinAggregateInputType = {
    id?: true
    registrationNumber?: true
    license?: true
    experience?: true
    teamSize?: true
    description?: true
    latitude?: true
    longitude?: true
    gstNumber?: true
    categoryId?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessDetailsMaxAggregateInputType = {
    id?: true
    registrationNumber?: true
    license?: true
    experience?: true
    teamSize?: true
    description?: true
    latitude?: true
    longitude?: true
    gstNumber?: true
    categoryId?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessDetailsCountAggregateInputType = {
    id?: true
    registrationNumber?: true
    license?: true
    experience?: true
    teamSize?: true
    description?: true
    latitude?: true
    longitude?: true
    degree?: true
    gstNumber?: true
    categoryId?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BusinessDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessDetails to aggregate.
     */
    where?: BusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDetails to fetch.
     */
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessDetails
    **/
    _count?: true | BusinessDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessDetailsMaxAggregateInputType
  }

  export type GetBusinessDetailsAggregateType<T extends BusinessDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessDetails[P]>
      : GetScalarType<T[P], AggregateBusinessDetails[P]>
  }




  export type BusinessDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDetailsWhereInput
    orderBy?: BusinessDetailsOrderByWithAggregationInput | BusinessDetailsOrderByWithAggregationInput[]
    by: BusinessDetailsScalarFieldEnum[] | BusinessDetailsScalarFieldEnum
    having?: BusinessDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessDetailsCountAggregateInputType | true
    _avg?: BusinessDetailsAvgAggregateInputType
    _sum?: BusinessDetailsSumAggregateInputType
    _min?: BusinessDetailsMinAggregateInputType
    _max?: BusinessDetailsMaxAggregateInputType
  }

  export type BusinessDetailsGroupByOutputType = {
    id: string
    registrationNumber: string | null
    license: string | null
    experience: number | null
    teamSize: number | null
    description: string | null
    latitude: number | null
    longitude: number | null
    degree: string[]
    gstNumber: string | null
    categoryId: string | null
    logo: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BusinessDetailsCountAggregateOutputType | null
    _avg: BusinessDetailsAvgAggregateOutputType | null
    _sum: BusinessDetailsSumAggregateOutputType | null
    _min: BusinessDetailsMinAggregateOutputType | null
    _max: BusinessDetailsMaxAggregateOutputType | null
  }

  type GetBusinessDetailsGroupByPayload<T extends BusinessDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessDetailsGroupByOutputType[P]>
        }
      >
    >


  export type BusinessDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registrationNumber?: boolean
    license?: boolean
    experience?: boolean
    teamSize?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    degree?: boolean
    gstNumber?: boolean
    categoryId?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    websites?: boolean | BusinessDetails$websitesArgs<ExtArgs>
    images?: boolean | BusinessDetails$imagesArgs<ExtArgs>
    language?: boolean | BusinessDetails$languageArgs<ExtArgs>
    proficiency?: boolean | BusinessDetails$proficiencyArgs<ExtArgs>
    court?: boolean | BusinessDetails$courtArgs<ExtArgs>
    category?: boolean | BusinessDetails$categoryArgs<ExtArgs>
    tags?: boolean | BusinessDetails$tagsArgs<ExtArgs>
    addresses?: boolean | BusinessDetails$addressesArgs<ExtArgs>
    _count?: boolean | BusinessDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessDetails"]>

  export type BusinessDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registrationNumber?: boolean
    license?: boolean
    experience?: boolean
    teamSize?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    degree?: boolean
    gstNumber?: boolean
    categoryId?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | BusinessDetails$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["businessDetails"]>

  export type BusinessDetailsSelectScalar = {
    id?: boolean
    registrationNumber?: boolean
    license?: boolean
    experience?: boolean
    teamSize?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    degree?: boolean
    gstNumber?: boolean
    categoryId?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BusinessDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    websites?: boolean | BusinessDetails$websitesArgs<ExtArgs>
    images?: boolean | BusinessDetails$imagesArgs<ExtArgs>
    language?: boolean | BusinessDetails$languageArgs<ExtArgs>
    proficiency?: boolean | BusinessDetails$proficiencyArgs<ExtArgs>
    court?: boolean | BusinessDetails$courtArgs<ExtArgs>
    category?: boolean | BusinessDetails$categoryArgs<ExtArgs>
    tags?: boolean | BusinessDetails$tagsArgs<ExtArgs>
    addresses?: boolean | BusinessDetails$addressesArgs<ExtArgs>
    _count?: boolean | BusinessDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | BusinessDetails$categoryArgs<ExtArgs>
  }

  export type $BusinessDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessDetails"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      websites: Prisma.$BusinessWebsitePayload<ExtArgs>[]
      images: Prisma.$BusinessImagePayload<ExtArgs>[]
      language: Prisma.$LanguagePayload<ExtArgs>[]
      proficiency: Prisma.$ProficiencyPayload<ExtArgs>[]
      court: Prisma.$CourtPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      tags: Prisma.$TagPayload<ExtArgs>[]
      addresses: Prisma.$BusinessAddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      registrationNumber: string | null
      license: string | null
      experience: number | null
      teamSize: number | null
      description: string | null
      latitude: number | null
      longitude: number | null
      degree: string[]
      gstNumber: string | null
      categoryId: string | null
      logo: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["businessDetails"]>
    composites: {}
  }

  type BusinessDetailsGetPayload<S extends boolean | null | undefined | BusinessDetailsDefaultArgs> = $Result.GetResult<Prisma.$BusinessDetailsPayload, S>

  type BusinessDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessDetailsCountAggregateInputType | true
    }

  export interface BusinessDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessDetails'], meta: { name: 'BusinessDetails' } }
    /**
     * Find zero or one BusinessDetails that matches the filter.
     * @param {BusinessDetailsFindUniqueArgs} args - Arguments to find a BusinessDetails
     * @example
     * // Get one BusinessDetails
     * const businessDetails = await prisma.businessDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessDetailsFindUniqueArgs>(args: SelectSubset<T, BusinessDetailsFindUniqueArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessDetailsFindUniqueOrThrowArgs} args - Arguments to find a BusinessDetails
     * @example
     * // Get one BusinessDetails
     * const businessDetails = await prisma.businessDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDetailsFindFirstArgs} args - Arguments to find a BusinessDetails
     * @example
     * // Get one BusinessDetails
     * const businessDetails = await prisma.businessDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessDetailsFindFirstArgs>(args?: SelectSubset<T, BusinessDetailsFindFirstArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDetailsFindFirstOrThrowArgs} args - Arguments to find a BusinessDetails
     * @example
     * // Get one BusinessDetails
     * const businessDetails = await prisma.businessDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessDetails
     * const businessDetails = await prisma.businessDetails.findMany()
     * 
     * // Get first 10 BusinessDetails
     * const businessDetails = await prisma.businessDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessDetailsWithIdOnly = await prisma.businessDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessDetailsFindManyArgs>(args?: SelectSubset<T, BusinessDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessDetails.
     * @param {BusinessDetailsCreateArgs} args - Arguments to create a BusinessDetails.
     * @example
     * // Create one BusinessDetails
     * const BusinessDetails = await prisma.businessDetails.create({
     *   data: {
     *     // ... data to create a BusinessDetails
     *   }
     * })
     * 
     */
    create<T extends BusinessDetailsCreateArgs>(args: SelectSubset<T, BusinessDetailsCreateArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessDetails.
     * @param {BusinessDetailsCreateManyArgs} args - Arguments to create many BusinessDetails.
     * @example
     * // Create many BusinessDetails
     * const businessDetails = await prisma.businessDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessDetailsCreateManyArgs>(args?: SelectSubset<T, BusinessDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessDetails and returns the data saved in the database.
     * @param {BusinessDetailsCreateManyAndReturnArgs} args - Arguments to create many BusinessDetails.
     * @example
     * // Create many BusinessDetails
     * const businessDetails = await prisma.businessDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessDetails and only return the `id`
     * const businessDetailsWithIdOnly = await prisma.businessDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessDetails.
     * @param {BusinessDetailsDeleteArgs} args - Arguments to delete one BusinessDetails.
     * @example
     * // Delete one BusinessDetails
     * const BusinessDetails = await prisma.businessDetails.delete({
     *   where: {
     *     // ... filter to delete one BusinessDetails
     *   }
     * })
     * 
     */
    delete<T extends BusinessDetailsDeleteArgs>(args: SelectSubset<T, BusinessDetailsDeleteArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessDetails.
     * @param {BusinessDetailsUpdateArgs} args - Arguments to update one BusinessDetails.
     * @example
     * // Update one BusinessDetails
     * const businessDetails = await prisma.businessDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessDetailsUpdateArgs>(args: SelectSubset<T, BusinessDetailsUpdateArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessDetails.
     * @param {BusinessDetailsDeleteManyArgs} args - Arguments to filter BusinessDetails to delete.
     * @example
     * // Delete a few BusinessDetails
     * const { count } = await prisma.businessDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDetailsDeleteManyArgs>(args?: SelectSubset<T, BusinessDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessDetails
     * const businessDetails = await prisma.businessDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessDetailsUpdateManyArgs>(args: SelectSubset<T, BusinessDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessDetails.
     * @param {BusinessDetailsUpsertArgs} args - Arguments to update or create a BusinessDetails.
     * @example
     * // Update or create a BusinessDetails
     * const businessDetails = await prisma.businessDetails.upsert({
     *   create: {
     *     // ... data to create a BusinessDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessDetails we want to update
     *   }
     * })
     */
    upsert<T extends BusinessDetailsUpsertArgs>(args: SelectSubset<T, BusinessDetailsUpsertArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDetailsCountArgs} args - Arguments to filter BusinessDetails to count.
     * @example
     * // Count the number of BusinessDetails
     * const count = await prisma.businessDetails.count({
     *   where: {
     *     // ... the filter for the BusinessDetails we want to count
     *   }
     * })
    **/
    count<T extends BusinessDetailsCountArgs>(
      args?: Subset<T, BusinessDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessDetailsAggregateArgs>(args: Subset<T, BusinessDetailsAggregateArgs>): Prisma.PrismaPromise<GetBusinessDetailsAggregateType<T>>

    /**
     * Group by BusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessDetailsGroupByArgs['orderBy'] }
        : { orderBy?: BusinessDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessDetails model
   */
  readonly fields: BusinessDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    websites<T extends BusinessDetails$websitesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$websitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends BusinessDetails$imagesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "findMany"> | Null>
    language<T extends BusinessDetails$languageArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$languageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany"> | Null>
    proficiency<T extends BusinessDetails$proficiencyArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$proficiencyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "findMany"> | Null>
    court<T extends BusinessDetails$courtArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$courtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends BusinessDetails$categoryArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tags<T extends BusinessDetails$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    addresses<T extends BusinessDetails$addressesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDetails$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessAddressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessDetails model
   */ 
  interface BusinessDetailsFieldRefs {
    readonly id: FieldRef<"BusinessDetails", 'String'>
    readonly registrationNumber: FieldRef<"BusinessDetails", 'String'>
    readonly license: FieldRef<"BusinessDetails", 'String'>
    readonly experience: FieldRef<"BusinessDetails", 'Int'>
    readonly teamSize: FieldRef<"BusinessDetails", 'Int'>
    readonly description: FieldRef<"BusinessDetails", 'String'>
    readonly latitude: FieldRef<"BusinessDetails", 'Float'>
    readonly longitude: FieldRef<"BusinessDetails", 'Float'>
    readonly degree: FieldRef<"BusinessDetails", 'String[]'>
    readonly gstNumber: FieldRef<"BusinessDetails", 'String'>
    readonly categoryId: FieldRef<"BusinessDetails", 'String'>
    readonly logo: FieldRef<"BusinessDetails", 'String'>
    readonly createdAt: FieldRef<"BusinessDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessDetails", 'DateTime'>
    readonly deletedAt: FieldRef<"BusinessDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessDetails findUnique
   */
  export type BusinessDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDetails to fetch.
     */
    where: BusinessDetailsWhereUniqueInput
  }

  /**
   * BusinessDetails findUniqueOrThrow
   */
  export type BusinessDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDetails to fetch.
     */
    where: BusinessDetailsWhereUniqueInput
  }

  /**
   * BusinessDetails findFirst
   */
  export type BusinessDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDetails to fetch.
     */
    where?: BusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDetails to fetch.
     */
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessDetails.
     */
    cursor?: BusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessDetails.
     */
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * BusinessDetails findFirstOrThrow
   */
  export type BusinessDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDetails to fetch.
     */
    where?: BusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDetails to fetch.
     */
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessDetails.
     */
    cursor?: BusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessDetails.
     */
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * BusinessDetails findMany
   */
  export type BusinessDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDetails to fetch.
     */
    where?: BusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDetails to fetch.
     */
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessDetails.
     */
    cursor?: BusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDetails.
     */
    skip?: number
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * BusinessDetails create
   */
  export type BusinessDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessDetails.
     */
    data: XOR<BusinessDetailsCreateInput, BusinessDetailsUncheckedCreateInput>
  }

  /**
   * BusinessDetails createMany
   */
  export type BusinessDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessDetails.
     */
    data: BusinessDetailsCreateManyInput | BusinessDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessDetails createManyAndReturn
   */
  export type BusinessDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessDetails.
     */
    data: BusinessDetailsCreateManyInput | BusinessDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessDetails update
   */
  export type BusinessDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessDetails.
     */
    data: XOR<BusinessDetailsUpdateInput, BusinessDetailsUncheckedUpdateInput>
    /**
     * Choose, which BusinessDetails to update.
     */
    where: BusinessDetailsWhereUniqueInput
  }

  /**
   * BusinessDetails updateMany
   */
  export type BusinessDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessDetails.
     */
    data: XOR<BusinessDetailsUpdateManyMutationInput, BusinessDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BusinessDetails to update
     */
    where?: BusinessDetailsWhereInput
  }

  /**
   * BusinessDetails upsert
   */
  export type BusinessDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessDetails to update in case it exists.
     */
    where: BusinessDetailsWhereUniqueInput
    /**
     * In case the BusinessDetails found by the `where` argument doesn't exist, create a new BusinessDetails with this data.
     */
    create: XOR<BusinessDetailsCreateInput, BusinessDetailsUncheckedCreateInput>
    /**
     * In case the BusinessDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessDetailsUpdateInput, BusinessDetailsUncheckedUpdateInput>
  }

  /**
   * BusinessDetails delete
   */
  export type BusinessDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter which BusinessDetails to delete.
     */
    where: BusinessDetailsWhereUniqueInput
  }

  /**
   * BusinessDetails deleteMany
   */
  export type BusinessDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessDetails to delete
     */
    where?: BusinessDetailsWhereInput
  }

  /**
   * BusinessDetails.websites
   */
  export type BusinessDetails$websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    where?: BusinessWebsiteWhereInput
    orderBy?: BusinessWebsiteOrderByWithRelationInput | BusinessWebsiteOrderByWithRelationInput[]
    cursor?: BusinessWebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessWebsiteScalarFieldEnum | BusinessWebsiteScalarFieldEnum[]
  }

  /**
   * BusinessDetails.images
   */
  export type BusinessDetails$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    where?: BusinessImageWhereInput
    orderBy?: BusinessImageOrderByWithRelationInput | BusinessImageOrderByWithRelationInput[]
    cursor?: BusinessImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessImageScalarFieldEnum | BusinessImageScalarFieldEnum[]
  }

  /**
   * BusinessDetails.language
   */
  export type BusinessDetails$languageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    cursor?: LanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * BusinessDetails.proficiency
   */
  export type BusinessDetails$proficiencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    where?: ProficiencyWhereInput
    orderBy?: ProficiencyOrderByWithRelationInput | ProficiencyOrderByWithRelationInput[]
    cursor?: ProficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProficiencyScalarFieldEnum | ProficiencyScalarFieldEnum[]
  }

  /**
   * BusinessDetails.court
   */
  export type BusinessDetails$courtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    cursor?: CourtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * BusinessDetails.category
   */
  export type BusinessDetails$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * BusinessDetails.tags
   */
  export type BusinessDetails$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * BusinessDetails.addresses
   */
  export type BusinessDetails$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessAddress
     */
    select?: BusinessAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessAddressInclude<ExtArgs> | null
    where?: BusinessAddressWhereInput
    orderBy?: BusinessAddressOrderByWithRelationInput | BusinessAddressOrderByWithRelationInput[]
    cursor?: BusinessAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessAddressScalarFieldEnum | BusinessAddressScalarFieldEnum[]
  }

  /**
   * BusinessDetails without action
   */
  export type BusinessDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
  }


  /**
   * Model BusinessSupportingDocuments
   */

  export type AggregateBusinessSupportingDocuments = {
    _count: BusinessSupportingDocumentsCountAggregateOutputType | null
    _min: BusinessSupportingDocumentsMinAggregateOutputType | null
    _max: BusinessSupportingDocumentsMaxAggregateOutputType | null
  }

  export type BusinessSupportingDocumentsMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessSupportingDocumentsMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BusinessSupportingDocumentsCountAggregateOutputType = {
    id: number
    businessId: number
    type: number
    url: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BusinessSupportingDocumentsMinAggregateInputType = {
    id?: true
    businessId?: true
    type?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessSupportingDocumentsMaxAggregateInputType = {
    id?: true
    businessId?: true
    type?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BusinessSupportingDocumentsCountAggregateInputType = {
    id?: true
    businessId?: true
    type?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BusinessSupportingDocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessSupportingDocuments to aggregate.
     */
    where?: BusinessSupportingDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSupportingDocuments to fetch.
     */
    orderBy?: BusinessSupportingDocumentsOrderByWithRelationInput | BusinessSupportingDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessSupportingDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSupportingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSupportingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessSupportingDocuments
    **/
    _count?: true | BusinessSupportingDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessSupportingDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessSupportingDocumentsMaxAggregateInputType
  }

  export type GetBusinessSupportingDocumentsAggregateType<T extends BusinessSupportingDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessSupportingDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessSupportingDocuments[P]>
      : GetScalarType<T[P], AggregateBusinessSupportingDocuments[P]>
  }




  export type BusinessSupportingDocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessSupportingDocumentsWhereInput
    orderBy?: BusinessSupportingDocumentsOrderByWithAggregationInput | BusinessSupportingDocumentsOrderByWithAggregationInput[]
    by: BusinessSupportingDocumentsScalarFieldEnum[] | BusinessSupportingDocumentsScalarFieldEnum
    having?: BusinessSupportingDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessSupportingDocumentsCountAggregateInputType | true
    _min?: BusinessSupportingDocumentsMinAggregateInputType
    _max?: BusinessSupportingDocumentsMaxAggregateInputType
  }

  export type BusinessSupportingDocumentsGroupByOutputType = {
    id: string
    businessId: string
    type: string
    url: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BusinessSupportingDocumentsCountAggregateOutputType | null
    _min: BusinessSupportingDocumentsMinAggregateOutputType | null
    _max: BusinessSupportingDocumentsMaxAggregateOutputType | null
  }

  type GetBusinessSupportingDocumentsGroupByPayload<T extends BusinessSupportingDocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessSupportingDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessSupportingDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessSupportingDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessSupportingDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSupportingDocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessSupportingDocuments"]>

  export type BusinessSupportingDocumentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessSupportingDocuments"]>

  export type BusinessSupportingDocumentsSelectScalar = {
    id?: boolean
    businessId?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BusinessSupportingDocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type BusinessSupportingDocumentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $BusinessSupportingDocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessSupportingDocuments"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      type: string
      url: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["businessSupportingDocuments"]>
    composites: {}
  }

  type BusinessSupportingDocumentsGetPayload<S extends boolean | null | undefined | BusinessSupportingDocumentsDefaultArgs> = $Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload, S>

  type BusinessSupportingDocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessSupportingDocumentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessSupportingDocumentsCountAggregateInputType | true
    }

  export interface BusinessSupportingDocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessSupportingDocuments'], meta: { name: 'BusinessSupportingDocuments' } }
    /**
     * Find zero or one BusinessSupportingDocuments that matches the filter.
     * @param {BusinessSupportingDocumentsFindUniqueArgs} args - Arguments to find a BusinessSupportingDocuments
     * @example
     * // Get one BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessSupportingDocumentsFindUniqueArgs>(args: SelectSubset<T, BusinessSupportingDocumentsFindUniqueArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessSupportingDocuments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessSupportingDocumentsFindUniqueOrThrowArgs} args - Arguments to find a BusinessSupportingDocuments
     * @example
     * // Get one BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessSupportingDocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessSupportingDocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessSupportingDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSupportingDocumentsFindFirstArgs} args - Arguments to find a BusinessSupportingDocuments
     * @example
     * // Get one BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessSupportingDocumentsFindFirstArgs>(args?: SelectSubset<T, BusinessSupportingDocumentsFindFirstArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessSupportingDocuments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSupportingDocumentsFindFirstOrThrowArgs} args - Arguments to find a BusinessSupportingDocuments
     * @example
     * // Get one BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessSupportingDocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessSupportingDocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessSupportingDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSupportingDocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.findMany()
     * 
     * // Get first 10 BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessSupportingDocumentsWithIdOnly = await prisma.businessSupportingDocuments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessSupportingDocumentsFindManyArgs>(args?: SelectSubset<T, BusinessSupportingDocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessSupportingDocuments.
     * @param {BusinessSupportingDocumentsCreateArgs} args - Arguments to create a BusinessSupportingDocuments.
     * @example
     * // Create one BusinessSupportingDocuments
     * const BusinessSupportingDocuments = await prisma.businessSupportingDocuments.create({
     *   data: {
     *     // ... data to create a BusinessSupportingDocuments
     *   }
     * })
     * 
     */
    create<T extends BusinessSupportingDocumentsCreateArgs>(args: SelectSubset<T, BusinessSupportingDocumentsCreateArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessSupportingDocuments.
     * @param {BusinessSupportingDocumentsCreateManyArgs} args - Arguments to create many BusinessSupportingDocuments.
     * @example
     * // Create many BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessSupportingDocumentsCreateManyArgs>(args?: SelectSubset<T, BusinessSupportingDocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessSupportingDocuments and returns the data saved in the database.
     * @param {BusinessSupportingDocumentsCreateManyAndReturnArgs} args - Arguments to create many BusinessSupportingDocuments.
     * @example
     * // Create many BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessSupportingDocuments and only return the `id`
     * const businessSupportingDocumentsWithIdOnly = await prisma.businessSupportingDocuments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessSupportingDocumentsCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessSupportingDocumentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessSupportingDocuments.
     * @param {BusinessSupportingDocumentsDeleteArgs} args - Arguments to delete one BusinessSupportingDocuments.
     * @example
     * // Delete one BusinessSupportingDocuments
     * const BusinessSupportingDocuments = await prisma.businessSupportingDocuments.delete({
     *   where: {
     *     // ... filter to delete one BusinessSupportingDocuments
     *   }
     * })
     * 
     */
    delete<T extends BusinessSupportingDocumentsDeleteArgs>(args: SelectSubset<T, BusinessSupportingDocumentsDeleteArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessSupportingDocuments.
     * @param {BusinessSupportingDocumentsUpdateArgs} args - Arguments to update one BusinessSupportingDocuments.
     * @example
     * // Update one BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessSupportingDocumentsUpdateArgs>(args: SelectSubset<T, BusinessSupportingDocumentsUpdateArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessSupportingDocuments.
     * @param {BusinessSupportingDocumentsDeleteManyArgs} args - Arguments to filter BusinessSupportingDocuments to delete.
     * @example
     * // Delete a few BusinessSupportingDocuments
     * const { count } = await prisma.businessSupportingDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessSupportingDocumentsDeleteManyArgs>(args?: SelectSubset<T, BusinessSupportingDocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessSupportingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSupportingDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessSupportingDocumentsUpdateManyArgs>(args: SelectSubset<T, BusinessSupportingDocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessSupportingDocuments.
     * @param {BusinessSupportingDocumentsUpsertArgs} args - Arguments to update or create a BusinessSupportingDocuments.
     * @example
     * // Update or create a BusinessSupportingDocuments
     * const businessSupportingDocuments = await prisma.businessSupportingDocuments.upsert({
     *   create: {
     *     // ... data to create a BusinessSupportingDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessSupportingDocuments we want to update
     *   }
     * })
     */
    upsert<T extends BusinessSupportingDocumentsUpsertArgs>(args: SelectSubset<T, BusinessSupportingDocumentsUpsertArgs<ExtArgs>>): Prisma__BusinessSupportingDocumentsClient<$Result.GetResult<Prisma.$BusinessSupportingDocumentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessSupportingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSupportingDocumentsCountArgs} args - Arguments to filter BusinessSupportingDocuments to count.
     * @example
     * // Count the number of BusinessSupportingDocuments
     * const count = await prisma.businessSupportingDocuments.count({
     *   where: {
     *     // ... the filter for the BusinessSupportingDocuments we want to count
     *   }
     * })
    **/
    count<T extends BusinessSupportingDocumentsCountArgs>(
      args?: Subset<T, BusinessSupportingDocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessSupportingDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessSupportingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSupportingDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessSupportingDocumentsAggregateArgs>(args: Subset<T, BusinessSupportingDocumentsAggregateArgs>): Prisma.PrismaPromise<GetBusinessSupportingDocumentsAggregateType<T>>

    /**
     * Group by BusinessSupportingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSupportingDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessSupportingDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessSupportingDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: BusinessSupportingDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessSupportingDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessSupportingDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessSupportingDocuments model
   */
  readonly fields: BusinessSupportingDocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessSupportingDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessSupportingDocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessSupportingDocuments model
   */ 
  interface BusinessSupportingDocumentsFieldRefs {
    readonly id: FieldRef<"BusinessSupportingDocuments", 'String'>
    readonly businessId: FieldRef<"BusinessSupportingDocuments", 'String'>
    readonly type: FieldRef<"BusinessSupportingDocuments", 'String'>
    readonly url: FieldRef<"BusinessSupportingDocuments", 'String'>
    readonly createdAt: FieldRef<"BusinessSupportingDocuments", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessSupportingDocuments", 'DateTime'>
    readonly deletedAt: FieldRef<"BusinessSupportingDocuments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessSupportingDocuments findUnique
   */
  export type BusinessSupportingDocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSupportingDocuments to fetch.
     */
    where: BusinessSupportingDocumentsWhereUniqueInput
  }

  /**
   * BusinessSupportingDocuments findUniqueOrThrow
   */
  export type BusinessSupportingDocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSupportingDocuments to fetch.
     */
    where: BusinessSupportingDocumentsWhereUniqueInput
  }

  /**
   * BusinessSupportingDocuments findFirst
   */
  export type BusinessSupportingDocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSupportingDocuments to fetch.
     */
    where?: BusinessSupportingDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSupportingDocuments to fetch.
     */
    orderBy?: BusinessSupportingDocumentsOrderByWithRelationInput | BusinessSupportingDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessSupportingDocuments.
     */
    cursor?: BusinessSupportingDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSupportingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSupportingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessSupportingDocuments.
     */
    distinct?: BusinessSupportingDocumentsScalarFieldEnum | BusinessSupportingDocumentsScalarFieldEnum[]
  }

  /**
   * BusinessSupportingDocuments findFirstOrThrow
   */
  export type BusinessSupportingDocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSupportingDocuments to fetch.
     */
    where?: BusinessSupportingDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSupportingDocuments to fetch.
     */
    orderBy?: BusinessSupportingDocumentsOrderByWithRelationInput | BusinessSupportingDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessSupportingDocuments.
     */
    cursor?: BusinessSupportingDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSupportingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSupportingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessSupportingDocuments.
     */
    distinct?: BusinessSupportingDocumentsScalarFieldEnum | BusinessSupportingDocumentsScalarFieldEnum[]
  }

  /**
   * BusinessSupportingDocuments findMany
   */
  export type BusinessSupportingDocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which BusinessSupportingDocuments to fetch.
     */
    where?: BusinessSupportingDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSupportingDocuments to fetch.
     */
    orderBy?: BusinessSupportingDocumentsOrderByWithRelationInput | BusinessSupportingDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessSupportingDocuments.
     */
    cursor?: BusinessSupportingDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSupportingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSupportingDocuments.
     */
    skip?: number
    distinct?: BusinessSupportingDocumentsScalarFieldEnum | BusinessSupportingDocumentsScalarFieldEnum[]
  }

  /**
   * BusinessSupportingDocuments create
   */
  export type BusinessSupportingDocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessSupportingDocuments.
     */
    data: XOR<BusinessSupportingDocumentsCreateInput, BusinessSupportingDocumentsUncheckedCreateInput>
  }

  /**
   * BusinessSupportingDocuments createMany
   */
  export type BusinessSupportingDocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessSupportingDocuments.
     */
    data: BusinessSupportingDocumentsCreateManyInput | BusinessSupportingDocumentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessSupportingDocuments createManyAndReturn
   */
  export type BusinessSupportingDocumentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessSupportingDocuments.
     */
    data: BusinessSupportingDocumentsCreateManyInput | BusinessSupportingDocumentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessSupportingDocuments update
   */
  export type BusinessSupportingDocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessSupportingDocuments.
     */
    data: XOR<BusinessSupportingDocumentsUpdateInput, BusinessSupportingDocumentsUncheckedUpdateInput>
    /**
     * Choose, which BusinessSupportingDocuments to update.
     */
    where: BusinessSupportingDocumentsWhereUniqueInput
  }

  /**
   * BusinessSupportingDocuments updateMany
   */
  export type BusinessSupportingDocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessSupportingDocuments.
     */
    data: XOR<BusinessSupportingDocumentsUpdateManyMutationInput, BusinessSupportingDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which BusinessSupportingDocuments to update
     */
    where?: BusinessSupportingDocumentsWhereInput
  }

  /**
   * BusinessSupportingDocuments upsert
   */
  export type BusinessSupportingDocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessSupportingDocuments to update in case it exists.
     */
    where: BusinessSupportingDocumentsWhereUniqueInput
    /**
     * In case the BusinessSupportingDocuments found by the `where` argument doesn't exist, create a new BusinessSupportingDocuments with this data.
     */
    create: XOR<BusinessSupportingDocumentsCreateInput, BusinessSupportingDocumentsUncheckedCreateInput>
    /**
     * In case the BusinessSupportingDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessSupportingDocumentsUpdateInput, BusinessSupportingDocumentsUncheckedUpdateInput>
  }

  /**
   * BusinessSupportingDocuments delete
   */
  export type BusinessSupportingDocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
    /**
     * Filter which BusinessSupportingDocuments to delete.
     */
    where: BusinessSupportingDocumentsWhereUniqueInput
  }

  /**
   * BusinessSupportingDocuments deleteMany
   */
  export type BusinessSupportingDocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessSupportingDocuments to delete
     */
    where?: BusinessSupportingDocumentsWhereInput
  }

  /**
   * BusinessSupportingDocuments without action
   */
  export type BusinessSupportingDocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSupportingDocuments
     */
    select?: BusinessSupportingDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessSupportingDocumentsInclude<ExtArgs> | null
  }


  /**
   * Model BusinessImage
   */

  export type AggregateBusinessImage = {
    _count: BusinessImageCountAggregateOutputType | null
    _avg: BusinessImageAvgAggregateOutputType | null
    _sum: BusinessImageSumAggregateOutputType | null
    _min: BusinessImageMinAggregateOutputType | null
    _max: BusinessImageMaxAggregateOutputType | null
  }

  export type BusinessImageAvgAggregateOutputType = {
    order: number | null
  }

  export type BusinessImageSumAggregateOutputType = {
    order: number | null
  }

  export type BusinessImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    order: number | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    businessDetailsId: string | null
  }

  export type BusinessImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    order: number | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    businessDetailsId: string | null
  }

  export type BusinessImageCountAggregateOutputType = {
    id: number
    url: number
    order: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    businessDetailsId: number
    _all: number
  }


  export type BusinessImageAvgAggregateInputType = {
    order?: true
  }

  export type BusinessImageSumAggregateInputType = {
    order?: true
  }

  export type BusinessImageMinAggregateInputType = {
    id?: true
    url?: true
    order?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    businessDetailsId?: true
  }

  export type BusinessImageMaxAggregateInputType = {
    id?: true
    url?: true
    order?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    businessDetailsId?: true
  }

  export type BusinessImageCountAggregateInputType = {
    id?: true
    url?: true
    order?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    businessDetailsId?: true
    _all?: true
  }

  export type BusinessImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessImage to aggregate.
     */
    where?: BusinessImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessImages to fetch.
     */
    orderBy?: BusinessImageOrderByWithRelationInput | BusinessImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessImages
    **/
    _count?: true | BusinessImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessImageMaxAggregateInputType
  }

  export type GetBusinessImageAggregateType<T extends BusinessImageAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessImage[P]>
      : GetScalarType<T[P], AggregateBusinessImage[P]>
  }




  export type BusinessImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessImageWhereInput
    orderBy?: BusinessImageOrderByWithAggregationInput | BusinessImageOrderByWithAggregationInput[]
    by: BusinessImageScalarFieldEnum[] | BusinessImageScalarFieldEnum
    having?: BusinessImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessImageCountAggregateInputType | true
    _avg?: BusinessImageAvgAggregateInputType
    _sum?: BusinessImageSumAggregateInputType
    _min?: BusinessImageMinAggregateInputType
    _max?: BusinessImageMaxAggregateInputType
  }

  export type BusinessImageGroupByOutputType = {
    id: string
    url: string
    order: number | null
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    businessDetailsId: string | null
    _count: BusinessImageCountAggregateOutputType | null
    _avg: BusinessImageAvgAggregateOutputType | null
    _sum: BusinessImageSumAggregateOutputType | null
    _min: BusinessImageMinAggregateOutputType | null
    _max: BusinessImageMaxAggregateOutputType | null
  }

  type GetBusinessImageGroupByPayload<T extends BusinessImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessImageGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessImageGroupByOutputType[P]>
        }
      >
    >


  export type BusinessImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    order?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetailsId?: boolean
    businessDetails?: boolean | BusinessImage$businessDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["businessImage"]>

  export type BusinessImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    order?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetailsId?: boolean
    businessDetails?: boolean | BusinessImage$businessDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["businessImage"]>

  export type BusinessImageSelectScalar = {
    id?: boolean
    url?: boolean
    order?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetailsId?: boolean
  }

  export type BusinessImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | BusinessImage$businessDetailsArgs<ExtArgs>
  }
  export type BusinessImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | BusinessImage$businessDetailsArgs<ExtArgs>
  }

  export type $BusinessImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessImage"
    objects: {
      businessDetails: Prisma.$BusinessDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      order: number | null
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
      businessDetailsId: string | null
    }, ExtArgs["result"]["businessImage"]>
    composites: {}
  }

  type BusinessImageGetPayload<S extends boolean | null | undefined | BusinessImageDefaultArgs> = $Result.GetResult<Prisma.$BusinessImagePayload, S>

  type BusinessImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessImageCountAggregateInputType | true
    }

  export interface BusinessImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessImage'], meta: { name: 'BusinessImage' } }
    /**
     * Find zero or one BusinessImage that matches the filter.
     * @param {BusinessImageFindUniqueArgs} args - Arguments to find a BusinessImage
     * @example
     * // Get one BusinessImage
     * const businessImage = await prisma.businessImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessImageFindUniqueArgs>(args: SelectSubset<T, BusinessImageFindUniqueArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessImageFindUniqueOrThrowArgs} args - Arguments to find a BusinessImage
     * @example
     * // Get one BusinessImage
     * const businessImage = await prisma.businessImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessImageFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessImageFindFirstArgs} args - Arguments to find a BusinessImage
     * @example
     * // Get one BusinessImage
     * const businessImage = await prisma.businessImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessImageFindFirstArgs>(args?: SelectSubset<T, BusinessImageFindFirstArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessImageFindFirstOrThrowArgs} args - Arguments to find a BusinessImage
     * @example
     * // Get one BusinessImage
     * const businessImage = await prisma.businessImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessImageFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessImages
     * const businessImages = await prisma.businessImage.findMany()
     * 
     * // Get first 10 BusinessImages
     * const businessImages = await prisma.businessImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessImageWithIdOnly = await prisma.businessImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessImageFindManyArgs>(args?: SelectSubset<T, BusinessImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessImage.
     * @param {BusinessImageCreateArgs} args - Arguments to create a BusinessImage.
     * @example
     * // Create one BusinessImage
     * const BusinessImage = await prisma.businessImage.create({
     *   data: {
     *     // ... data to create a BusinessImage
     *   }
     * })
     * 
     */
    create<T extends BusinessImageCreateArgs>(args: SelectSubset<T, BusinessImageCreateArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessImages.
     * @param {BusinessImageCreateManyArgs} args - Arguments to create many BusinessImages.
     * @example
     * // Create many BusinessImages
     * const businessImage = await prisma.businessImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessImageCreateManyArgs>(args?: SelectSubset<T, BusinessImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessImages and returns the data saved in the database.
     * @param {BusinessImageCreateManyAndReturnArgs} args - Arguments to create many BusinessImages.
     * @example
     * // Create many BusinessImages
     * const businessImage = await prisma.businessImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessImages and only return the `id`
     * const businessImageWithIdOnly = await prisma.businessImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessImageCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessImage.
     * @param {BusinessImageDeleteArgs} args - Arguments to delete one BusinessImage.
     * @example
     * // Delete one BusinessImage
     * const BusinessImage = await prisma.businessImage.delete({
     *   where: {
     *     // ... filter to delete one BusinessImage
     *   }
     * })
     * 
     */
    delete<T extends BusinessImageDeleteArgs>(args: SelectSubset<T, BusinessImageDeleteArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessImage.
     * @param {BusinessImageUpdateArgs} args - Arguments to update one BusinessImage.
     * @example
     * // Update one BusinessImage
     * const businessImage = await prisma.businessImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessImageUpdateArgs>(args: SelectSubset<T, BusinessImageUpdateArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessImages.
     * @param {BusinessImageDeleteManyArgs} args - Arguments to filter BusinessImages to delete.
     * @example
     * // Delete a few BusinessImages
     * const { count } = await prisma.businessImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessImageDeleteManyArgs>(args?: SelectSubset<T, BusinessImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessImages
     * const businessImage = await prisma.businessImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessImageUpdateManyArgs>(args: SelectSubset<T, BusinessImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessImage.
     * @param {BusinessImageUpsertArgs} args - Arguments to update or create a BusinessImage.
     * @example
     * // Update or create a BusinessImage
     * const businessImage = await prisma.businessImage.upsert({
     *   create: {
     *     // ... data to create a BusinessImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessImage we want to update
     *   }
     * })
     */
    upsert<T extends BusinessImageUpsertArgs>(args: SelectSubset<T, BusinessImageUpsertArgs<ExtArgs>>): Prisma__BusinessImageClient<$Result.GetResult<Prisma.$BusinessImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessImageCountArgs} args - Arguments to filter BusinessImages to count.
     * @example
     * // Count the number of BusinessImages
     * const count = await prisma.businessImage.count({
     *   where: {
     *     // ... the filter for the BusinessImages we want to count
     *   }
     * })
    **/
    count<T extends BusinessImageCountArgs>(
      args?: Subset<T, BusinessImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessImageAggregateArgs>(args: Subset<T, BusinessImageAggregateArgs>): Prisma.PrismaPromise<GetBusinessImageAggregateType<T>>

    /**
     * Group by BusinessImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessImageGroupByArgs['orderBy'] }
        : { orderBy?: BusinessImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessImage model
   */
  readonly fields: BusinessImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessDetails<T extends BusinessImage$businessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessImage$businessDetailsArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessImage model
   */ 
  interface BusinessImageFieldRefs {
    readonly id: FieldRef<"BusinessImage", 'String'>
    readonly url: FieldRef<"BusinessImage", 'String'>
    readonly order: FieldRef<"BusinessImage", 'Int'>
    readonly createdAt: FieldRef<"BusinessImage", 'DateTime'>
    readonly deletedAt: FieldRef<"BusinessImage", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessImage", 'DateTime'>
    readonly businessDetailsId: FieldRef<"BusinessImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessImage findUnique
   */
  export type BusinessImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessImage to fetch.
     */
    where: BusinessImageWhereUniqueInput
  }

  /**
   * BusinessImage findUniqueOrThrow
   */
  export type BusinessImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessImage to fetch.
     */
    where: BusinessImageWhereUniqueInput
  }

  /**
   * BusinessImage findFirst
   */
  export type BusinessImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessImage to fetch.
     */
    where?: BusinessImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessImages to fetch.
     */
    orderBy?: BusinessImageOrderByWithRelationInput | BusinessImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessImages.
     */
    cursor?: BusinessImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessImages.
     */
    distinct?: BusinessImageScalarFieldEnum | BusinessImageScalarFieldEnum[]
  }

  /**
   * BusinessImage findFirstOrThrow
   */
  export type BusinessImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessImage to fetch.
     */
    where?: BusinessImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessImages to fetch.
     */
    orderBy?: BusinessImageOrderByWithRelationInput | BusinessImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessImages.
     */
    cursor?: BusinessImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessImages.
     */
    distinct?: BusinessImageScalarFieldEnum | BusinessImageScalarFieldEnum[]
  }

  /**
   * BusinessImage findMany
   */
  export type BusinessImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessImages to fetch.
     */
    where?: BusinessImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessImages to fetch.
     */
    orderBy?: BusinessImageOrderByWithRelationInput | BusinessImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessImages.
     */
    cursor?: BusinessImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessImages.
     */
    skip?: number
    distinct?: BusinessImageScalarFieldEnum | BusinessImageScalarFieldEnum[]
  }

  /**
   * BusinessImage create
   */
  export type BusinessImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessImage.
     */
    data: XOR<BusinessImageCreateInput, BusinessImageUncheckedCreateInput>
  }

  /**
   * BusinessImage createMany
   */
  export type BusinessImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessImages.
     */
    data: BusinessImageCreateManyInput | BusinessImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessImage createManyAndReturn
   */
  export type BusinessImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessImages.
     */
    data: BusinessImageCreateManyInput | BusinessImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessImage update
   */
  export type BusinessImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessImage.
     */
    data: XOR<BusinessImageUpdateInput, BusinessImageUncheckedUpdateInput>
    /**
     * Choose, which BusinessImage to update.
     */
    where: BusinessImageWhereUniqueInput
  }

  /**
   * BusinessImage updateMany
   */
  export type BusinessImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessImages.
     */
    data: XOR<BusinessImageUpdateManyMutationInput, BusinessImageUncheckedUpdateManyInput>
    /**
     * Filter which BusinessImages to update
     */
    where?: BusinessImageWhereInput
  }

  /**
   * BusinessImage upsert
   */
  export type BusinessImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessImage to update in case it exists.
     */
    where: BusinessImageWhereUniqueInput
    /**
     * In case the BusinessImage found by the `where` argument doesn't exist, create a new BusinessImage with this data.
     */
    create: XOR<BusinessImageCreateInput, BusinessImageUncheckedCreateInput>
    /**
     * In case the BusinessImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessImageUpdateInput, BusinessImageUncheckedUpdateInput>
  }

  /**
   * BusinessImage delete
   */
  export type BusinessImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
    /**
     * Filter which BusinessImage to delete.
     */
    where: BusinessImageWhereUniqueInput
  }

  /**
   * BusinessImage deleteMany
   */
  export type BusinessImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessImages to delete
     */
    where?: BusinessImageWhereInput
  }

  /**
   * BusinessImage.businessDetails
   */
  export type BusinessImage$businessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
  }

  /**
   * BusinessImage without action
   */
  export type BusinessImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessImage
     */
    select?: BusinessImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessImageInclude<ExtArgs> | null
  }


  /**
   * Model BusinessWebsite
   */

  export type AggregateBusinessWebsite = {
    _count: BusinessWebsiteCountAggregateOutputType | null
    _min: BusinessWebsiteMinAggregateOutputType | null
    _max: BusinessWebsiteMaxAggregateOutputType | null
  }

  export type BusinessWebsiteMinAggregateOutputType = {
    id: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    businessDetailsId: string | null
  }

  export type BusinessWebsiteMaxAggregateOutputType = {
    id: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
    businessDetailsId: string | null
  }

  export type BusinessWebsiteCountAggregateOutputType = {
    id: number
    type: number
    url: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    businessDetailsId: number
    _all: number
  }


  export type BusinessWebsiteMinAggregateInputType = {
    id?: true
    type?: true
    url?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    businessDetailsId?: true
  }

  export type BusinessWebsiteMaxAggregateInputType = {
    id?: true
    type?: true
    url?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    businessDetailsId?: true
  }

  export type BusinessWebsiteCountAggregateInputType = {
    id?: true
    type?: true
    url?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    businessDetailsId?: true
    _all?: true
  }

  export type BusinessWebsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessWebsite to aggregate.
     */
    where?: BusinessWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessWebsites to fetch.
     */
    orderBy?: BusinessWebsiteOrderByWithRelationInput | BusinessWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessWebsites
    **/
    _count?: true | BusinessWebsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessWebsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessWebsiteMaxAggregateInputType
  }

  export type GetBusinessWebsiteAggregateType<T extends BusinessWebsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessWebsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessWebsite[P]>
      : GetScalarType<T[P], AggregateBusinessWebsite[P]>
  }




  export type BusinessWebsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWebsiteWhereInput
    orderBy?: BusinessWebsiteOrderByWithAggregationInput | BusinessWebsiteOrderByWithAggregationInput[]
    by: BusinessWebsiteScalarFieldEnum[] | BusinessWebsiteScalarFieldEnum
    having?: BusinessWebsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessWebsiteCountAggregateInputType | true
    _min?: BusinessWebsiteMinAggregateInputType
    _max?: BusinessWebsiteMaxAggregateInputType
  }

  export type BusinessWebsiteGroupByOutputType = {
    id: string
    type: string
    url: string
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    businessDetailsId: string | null
    _count: BusinessWebsiteCountAggregateOutputType | null
    _min: BusinessWebsiteMinAggregateOutputType | null
    _max: BusinessWebsiteMaxAggregateOutputType | null
  }

  type GetBusinessWebsiteGroupByPayload<T extends BusinessWebsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessWebsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessWebsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessWebsiteGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessWebsiteGroupByOutputType[P]>
        }
      >
    >


  export type BusinessWebsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetailsId?: boolean
    businessDetails?: boolean | BusinessWebsite$businessDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["businessWebsite"]>

  export type BusinessWebsiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetailsId?: boolean
    businessDetails?: boolean | BusinessWebsite$businessDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["businessWebsite"]>

  export type BusinessWebsiteSelectScalar = {
    id?: boolean
    type?: boolean
    url?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetailsId?: boolean
  }

  export type BusinessWebsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | BusinessWebsite$businessDetailsArgs<ExtArgs>
  }
  export type BusinessWebsiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | BusinessWebsite$businessDetailsArgs<ExtArgs>
  }

  export type $BusinessWebsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessWebsite"
    objects: {
      businessDetails: Prisma.$BusinessDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      url: string
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
      businessDetailsId: string | null
    }, ExtArgs["result"]["businessWebsite"]>
    composites: {}
  }

  type BusinessWebsiteGetPayload<S extends boolean | null | undefined | BusinessWebsiteDefaultArgs> = $Result.GetResult<Prisma.$BusinessWebsitePayload, S>

  type BusinessWebsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessWebsiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessWebsiteCountAggregateInputType | true
    }

  export interface BusinessWebsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessWebsite'], meta: { name: 'BusinessWebsite' } }
    /**
     * Find zero or one BusinessWebsite that matches the filter.
     * @param {BusinessWebsiteFindUniqueArgs} args - Arguments to find a BusinessWebsite
     * @example
     * // Get one BusinessWebsite
     * const businessWebsite = await prisma.businessWebsite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessWebsiteFindUniqueArgs>(args: SelectSubset<T, BusinessWebsiteFindUniqueArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessWebsite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessWebsiteFindUniqueOrThrowArgs} args - Arguments to find a BusinessWebsite
     * @example
     * // Get one BusinessWebsite
     * const businessWebsite = await prisma.businessWebsite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessWebsiteFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessWebsiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessWebsite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessWebsiteFindFirstArgs} args - Arguments to find a BusinessWebsite
     * @example
     * // Get one BusinessWebsite
     * const businessWebsite = await prisma.businessWebsite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessWebsiteFindFirstArgs>(args?: SelectSubset<T, BusinessWebsiteFindFirstArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessWebsite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessWebsiteFindFirstOrThrowArgs} args - Arguments to find a BusinessWebsite
     * @example
     * // Get one BusinessWebsite
     * const businessWebsite = await prisma.businessWebsite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessWebsiteFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessWebsiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessWebsites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessWebsiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessWebsites
     * const businessWebsites = await prisma.businessWebsite.findMany()
     * 
     * // Get first 10 BusinessWebsites
     * const businessWebsites = await prisma.businessWebsite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWebsiteWithIdOnly = await prisma.businessWebsite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessWebsiteFindManyArgs>(args?: SelectSubset<T, BusinessWebsiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessWebsite.
     * @param {BusinessWebsiteCreateArgs} args - Arguments to create a BusinessWebsite.
     * @example
     * // Create one BusinessWebsite
     * const BusinessWebsite = await prisma.businessWebsite.create({
     *   data: {
     *     // ... data to create a BusinessWebsite
     *   }
     * })
     * 
     */
    create<T extends BusinessWebsiteCreateArgs>(args: SelectSubset<T, BusinessWebsiteCreateArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessWebsites.
     * @param {BusinessWebsiteCreateManyArgs} args - Arguments to create many BusinessWebsites.
     * @example
     * // Create many BusinessWebsites
     * const businessWebsite = await prisma.businessWebsite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessWebsiteCreateManyArgs>(args?: SelectSubset<T, BusinessWebsiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessWebsites and returns the data saved in the database.
     * @param {BusinessWebsiteCreateManyAndReturnArgs} args - Arguments to create many BusinessWebsites.
     * @example
     * // Create many BusinessWebsites
     * const businessWebsite = await prisma.businessWebsite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessWebsites and only return the `id`
     * const businessWebsiteWithIdOnly = await prisma.businessWebsite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessWebsiteCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessWebsiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessWebsite.
     * @param {BusinessWebsiteDeleteArgs} args - Arguments to delete one BusinessWebsite.
     * @example
     * // Delete one BusinessWebsite
     * const BusinessWebsite = await prisma.businessWebsite.delete({
     *   where: {
     *     // ... filter to delete one BusinessWebsite
     *   }
     * })
     * 
     */
    delete<T extends BusinessWebsiteDeleteArgs>(args: SelectSubset<T, BusinessWebsiteDeleteArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessWebsite.
     * @param {BusinessWebsiteUpdateArgs} args - Arguments to update one BusinessWebsite.
     * @example
     * // Update one BusinessWebsite
     * const businessWebsite = await prisma.businessWebsite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessWebsiteUpdateArgs>(args: SelectSubset<T, BusinessWebsiteUpdateArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessWebsites.
     * @param {BusinessWebsiteDeleteManyArgs} args - Arguments to filter BusinessWebsites to delete.
     * @example
     * // Delete a few BusinessWebsites
     * const { count } = await prisma.businessWebsite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessWebsiteDeleteManyArgs>(args?: SelectSubset<T, BusinessWebsiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessWebsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessWebsites
     * const businessWebsite = await prisma.businessWebsite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessWebsiteUpdateManyArgs>(args: SelectSubset<T, BusinessWebsiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessWebsite.
     * @param {BusinessWebsiteUpsertArgs} args - Arguments to update or create a BusinessWebsite.
     * @example
     * // Update or create a BusinessWebsite
     * const businessWebsite = await prisma.businessWebsite.upsert({
     *   create: {
     *     // ... data to create a BusinessWebsite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessWebsite we want to update
     *   }
     * })
     */
    upsert<T extends BusinessWebsiteUpsertArgs>(args: SelectSubset<T, BusinessWebsiteUpsertArgs<ExtArgs>>): Prisma__BusinessWebsiteClient<$Result.GetResult<Prisma.$BusinessWebsitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessWebsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessWebsiteCountArgs} args - Arguments to filter BusinessWebsites to count.
     * @example
     * // Count the number of BusinessWebsites
     * const count = await prisma.businessWebsite.count({
     *   where: {
     *     // ... the filter for the BusinessWebsites we want to count
     *   }
     * })
    **/
    count<T extends BusinessWebsiteCountArgs>(
      args?: Subset<T, BusinessWebsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessWebsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessWebsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessWebsiteAggregateArgs>(args: Subset<T, BusinessWebsiteAggregateArgs>): Prisma.PrismaPromise<GetBusinessWebsiteAggregateType<T>>

    /**
     * Group by BusinessWebsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessWebsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessWebsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessWebsiteGroupByArgs['orderBy'] }
        : { orderBy?: BusinessWebsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessWebsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessWebsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessWebsite model
   */
  readonly fields: BusinessWebsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessWebsite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessWebsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessDetails<T extends BusinessWebsite$businessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessWebsite$businessDetailsArgs<ExtArgs>>): Prisma__BusinessDetailsClient<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessWebsite model
   */ 
  interface BusinessWebsiteFieldRefs {
    readonly id: FieldRef<"BusinessWebsite", 'String'>
    readonly type: FieldRef<"BusinessWebsite", 'String'>
    readonly url: FieldRef<"BusinessWebsite", 'String'>
    readonly createdAt: FieldRef<"BusinessWebsite", 'DateTime'>
    readonly deletedAt: FieldRef<"BusinessWebsite", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessWebsite", 'DateTime'>
    readonly businessDetailsId: FieldRef<"BusinessWebsite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessWebsite findUnique
   */
  export type BusinessWebsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which BusinessWebsite to fetch.
     */
    where: BusinessWebsiteWhereUniqueInput
  }

  /**
   * BusinessWebsite findUniqueOrThrow
   */
  export type BusinessWebsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which BusinessWebsite to fetch.
     */
    where: BusinessWebsiteWhereUniqueInput
  }

  /**
   * BusinessWebsite findFirst
   */
  export type BusinessWebsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which BusinessWebsite to fetch.
     */
    where?: BusinessWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessWebsites to fetch.
     */
    orderBy?: BusinessWebsiteOrderByWithRelationInput | BusinessWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessWebsites.
     */
    cursor?: BusinessWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessWebsites.
     */
    distinct?: BusinessWebsiteScalarFieldEnum | BusinessWebsiteScalarFieldEnum[]
  }

  /**
   * BusinessWebsite findFirstOrThrow
   */
  export type BusinessWebsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which BusinessWebsite to fetch.
     */
    where?: BusinessWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessWebsites to fetch.
     */
    orderBy?: BusinessWebsiteOrderByWithRelationInput | BusinessWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessWebsites.
     */
    cursor?: BusinessWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessWebsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessWebsites.
     */
    distinct?: BusinessWebsiteScalarFieldEnum | BusinessWebsiteScalarFieldEnum[]
  }

  /**
   * BusinessWebsite findMany
   */
  export type BusinessWebsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * Filter, which BusinessWebsites to fetch.
     */
    where?: BusinessWebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessWebsites to fetch.
     */
    orderBy?: BusinessWebsiteOrderByWithRelationInput | BusinessWebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessWebsites.
     */
    cursor?: BusinessWebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessWebsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessWebsites.
     */
    skip?: number
    distinct?: BusinessWebsiteScalarFieldEnum | BusinessWebsiteScalarFieldEnum[]
  }

  /**
   * BusinessWebsite create
   */
  export type BusinessWebsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessWebsite.
     */
    data: XOR<BusinessWebsiteCreateInput, BusinessWebsiteUncheckedCreateInput>
  }

  /**
   * BusinessWebsite createMany
   */
  export type BusinessWebsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessWebsites.
     */
    data: BusinessWebsiteCreateManyInput | BusinessWebsiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessWebsite createManyAndReturn
   */
  export type BusinessWebsiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessWebsites.
     */
    data: BusinessWebsiteCreateManyInput | BusinessWebsiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessWebsite update
   */
  export type BusinessWebsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessWebsite.
     */
    data: XOR<BusinessWebsiteUpdateInput, BusinessWebsiteUncheckedUpdateInput>
    /**
     * Choose, which BusinessWebsite to update.
     */
    where: BusinessWebsiteWhereUniqueInput
  }

  /**
   * BusinessWebsite updateMany
   */
  export type BusinessWebsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessWebsites.
     */
    data: XOR<BusinessWebsiteUpdateManyMutationInput, BusinessWebsiteUncheckedUpdateManyInput>
    /**
     * Filter which BusinessWebsites to update
     */
    where?: BusinessWebsiteWhereInput
  }

  /**
   * BusinessWebsite upsert
   */
  export type BusinessWebsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessWebsite to update in case it exists.
     */
    where: BusinessWebsiteWhereUniqueInput
    /**
     * In case the BusinessWebsite found by the `where` argument doesn't exist, create a new BusinessWebsite with this data.
     */
    create: XOR<BusinessWebsiteCreateInput, BusinessWebsiteUncheckedCreateInput>
    /**
     * In case the BusinessWebsite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessWebsiteUpdateInput, BusinessWebsiteUncheckedUpdateInput>
  }

  /**
   * BusinessWebsite delete
   */
  export type BusinessWebsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
    /**
     * Filter which BusinessWebsite to delete.
     */
    where: BusinessWebsiteWhereUniqueInput
  }

  /**
   * BusinessWebsite deleteMany
   */
  export type BusinessWebsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessWebsites to delete
     */
    where?: BusinessWebsiteWhereInput
  }

  /**
   * BusinessWebsite.businessDetails
   */
  export type BusinessWebsite$businessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
  }

  /**
   * BusinessWebsite without action
   */
  export type BusinessWebsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessWebsite
     */
    select?: BusinessWebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessWebsiteInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetails?: boolean | Language$businessDetailsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }

  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | Language$businessDetailsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      businessDetails: Prisma.$BusinessDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessDetails<T extends Language$businessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Language$businessDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
    readonly slug: FieldRef<"Language", 'String'>
    readonly createdAt: FieldRef<"Language", 'DateTime'>
    readonly deletedAt: FieldRef<"Language", 'DateTime'>
    readonly updatedAt: FieldRef<"Language", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }

  /**
   * Language.businessDetails
   */
  export type Language$businessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    cursor?: BusinessDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Proficiency
   */

  export type AggregateProficiency = {
    _count: ProficiencyCountAggregateOutputType | null
    _min: ProficiencyMinAggregateOutputType | null
    _max: ProficiencyMaxAggregateOutputType | null
  }

  export type ProficiencyMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type ProficiencyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type ProficiencyCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    _all: number
  }


  export type ProficiencyMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type ProficiencyMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type ProficiencyCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProficiencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proficiency to aggregate.
     */
    where?: ProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proficiencies to fetch.
     */
    orderBy?: ProficiencyOrderByWithRelationInput | ProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proficiencies
    **/
    _count?: true | ProficiencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProficiencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProficiencyMaxAggregateInputType
  }

  export type GetProficiencyAggregateType<T extends ProficiencyAggregateArgs> = {
        [P in keyof T & keyof AggregateProficiency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProficiency[P]>
      : GetScalarType<T[P], AggregateProficiency[P]>
  }




  export type ProficiencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProficiencyWhereInput
    orderBy?: ProficiencyOrderByWithAggregationInput | ProficiencyOrderByWithAggregationInput[]
    by: ProficiencyScalarFieldEnum[] | ProficiencyScalarFieldEnum
    having?: ProficiencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProficiencyCountAggregateInputType | true
    _min?: ProficiencyMinAggregateInputType
    _max?: ProficiencyMaxAggregateInputType
  }

  export type ProficiencyGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    _count: ProficiencyCountAggregateOutputType | null
    _min: ProficiencyMinAggregateOutputType | null
    _max: ProficiencyMaxAggregateOutputType | null
  }

  type GetProficiencyGroupByPayload<T extends ProficiencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProficiencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProficiencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProficiencyGroupByOutputType[P]>
            : GetScalarType<T[P], ProficiencyGroupByOutputType[P]>
        }
      >
    >


  export type ProficiencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetails?: boolean | Proficiency$businessDetailsArgs<ExtArgs>
    _count?: boolean | ProficiencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proficiency"]>

  export type ProficiencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proficiency"]>

  export type ProficiencySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }

  export type ProficiencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | Proficiency$businessDetailsArgs<ExtArgs>
    _count?: boolean | ProficiencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProficiencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProficiencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proficiency"
    objects: {
      businessDetails: Prisma.$BusinessDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["proficiency"]>
    composites: {}
  }

  type ProficiencyGetPayload<S extends boolean | null | undefined | ProficiencyDefaultArgs> = $Result.GetResult<Prisma.$ProficiencyPayload, S>

  type ProficiencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProficiencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProficiencyCountAggregateInputType | true
    }

  export interface ProficiencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proficiency'], meta: { name: 'Proficiency' } }
    /**
     * Find zero or one Proficiency that matches the filter.
     * @param {ProficiencyFindUniqueArgs} args - Arguments to find a Proficiency
     * @example
     * // Get one Proficiency
     * const proficiency = await prisma.proficiency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProficiencyFindUniqueArgs>(args: SelectSubset<T, ProficiencyFindUniqueArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proficiency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProficiencyFindUniqueOrThrowArgs} args - Arguments to find a Proficiency
     * @example
     * // Get one Proficiency
     * const proficiency = await prisma.proficiency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProficiencyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProficiencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proficiency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyFindFirstArgs} args - Arguments to find a Proficiency
     * @example
     * // Get one Proficiency
     * const proficiency = await prisma.proficiency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProficiencyFindFirstArgs>(args?: SelectSubset<T, ProficiencyFindFirstArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proficiency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyFindFirstOrThrowArgs} args - Arguments to find a Proficiency
     * @example
     * // Get one Proficiency
     * const proficiency = await prisma.proficiency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProficiencyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProficiencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Proficiencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proficiencies
     * const proficiencies = await prisma.proficiency.findMany()
     * 
     * // Get first 10 Proficiencies
     * const proficiencies = await prisma.proficiency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proficiencyWithIdOnly = await prisma.proficiency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProficiencyFindManyArgs>(args?: SelectSubset<T, ProficiencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proficiency.
     * @param {ProficiencyCreateArgs} args - Arguments to create a Proficiency.
     * @example
     * // Create one Proficiency
     * const Proficiency = await prisma.proficiency.create({
     *   data: {
     *     // ... data to create a Proficiency
     *   }
     * })
     * 
     */
    create<T extends ProficiencyCreateArgs>(args: SelectSubset<T, ProficiencyCreateArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Proficiencies.
     * @param {ProficiencyCreateManyArgs} args - Arguments to create many Proficiencies.
     * @example
     * // Create many Proficiencies
     * const proficiency = await prisma.proficiency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProficiencyCreateManyArgs>(args?: SelectSubset<T, ProficiencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proficiencies and returns the data saved in the database.
     * @param {ProficiencyCreateManyAndReturnArgs} args - Arguments to create many Proficiencies.
     * @example
     * // Create many Proficiencies
     * const proficiency = await prisma.proficiency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proficiencies and only return the `id`
     * const proficiencyWithIdOnly = await prisma.proficiency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProficiencyCreateManyAndReturnArgs>(args?: SelectSubset<T, ProficiencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proficiency.
     * @param {ProficiencyDeleteArgs} args - Arguments to delete one Proficiency.
     * @example
     * // Delete one Proficiency
     * const Proficiency = await prisma.proficiency.delete({
     *   where: {
     *     // ... filter to delete one Proficiency
     *   }
     * })
     * 
     */
    delete<T extends ProficiencyDeleteArgs>(args: SelectSubset<T, ProficiencyDeleteArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proficiency.
     * @param {ProficiencyUpdateArgs} args - Arguments to update one Proficiency.
     * @example
     * // Update one Proficiency
     * const proficiency = await prisma.proficiency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProficiencyUpdateArgs>(args: SelectSubset<T, ProficiencyUpdateArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Proficiencies.
     * @param {ProficiencyDeleteManyArgs} args - Arguments to filter Proficiencies to delete.
     * @example
     * // Delete a few Proficiencies
     * const { count } = await prisma.proficiency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProficiencyDeleteManyArgs>(args?: SelectSubset<T, ProficiencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proficiencies
     * const proficiency = await prisma.proficiency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProficiencyUpdateManyArgs>(args: SelectSubset<T, ProficiencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proficiency.
     * @param {ProficiencyUpsertArgs} args - Arguments to update or create a Proficiency.
     * @example
     * // Update or create a Proficiency
     * const proficiency = await prisma.proficiency.upsert({
     *   create: {
     *     // ... data to create a Proficiency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proficiency we want to update
     *   }
     * })
     */
    upsert<T extends ProficiencyUpsertArgs>(args: SelectSubset<T, ProficiencyUpsertArgs<ExtArgs>>): Prisma__ProficiencyClient<$Result.GetResult<Prisma.$ProficiencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Proficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyCountArgs} args - Arguments to filter Proficiencies to count.
     * @example
     * // Count the number of Proficiencies
     * const count = await prisma.proficiency.count({
     *   where: {
     *     // ... the filter for the Proficiencies we want to count
     *   }
     * })
    **/
    count<T extends ProficiencyCountArgs>(
      args?: Subset<T, ProficiencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProficiencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProficiencyAggregateArgs>(args: Subset<T, ProficiencyAggregateArgs>): Prisma.PrismaPromise<GetProficiencyAggregateType<T>>

    /**
     * Group by Proficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProficiencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProficiencyGroupByArgs['orderBy'] }
        : { orderBy?: ProficiencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProficiencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProficiencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proficiency model
   */
  readonly fields: ProficiencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proficiency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProficiencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessDetails<T extends Proficiency$businessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Proficiency$businessDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proficiency model
   */ 
  interface ProficiencyFieldRefs {
    readonly id: FieldRef<"Proficiency", 'String'>
    readonly name: FieldRef<"Proficiency", 'String'>
    readonly slug: FieldRef<"Proficiency", 'String'>
    readonly createdAt: FieldRef<"Proficiency", 'DateTime'>
    readonly deletedAt: FieldRef<"Proficiency", 'DateTime'>
    readonly updatedAt: FieldRef<"Proficiency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proficiency findUnique
   */
  export type ProficiencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Proficiency to fetch.
     */
    where: ProficiencyWhereUniqueInput
  }

  /**
   * Proficiency findUniqueOrThrow
   */
  export type ProficiencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Proficiency to fetch.
     */
    where: ProficiencyWhereUniqueInput
  }

  /**
   * Proficiency findFirst
   */
  export type ProficiencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Proficiency to fetch.
     */
    where?: ProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proficiencies to fetch.
     */
    orderBy?: ProficiencyOrderByWithRelationInput | ProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proficiencies.
     */
    cursor?: ProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proficiencies.
     */
    distinct?: ProficiencyScalarFieldEnum | ProficiencyScalarFieldEnum[]
  }

  /**
   * Proficiency findFirstOrThrow
   */
  export type ProficiencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Proficiency to fetch.
     */
    where?: ProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proficiencies to fetch.
     */
    orderBy?: ProficiencyOrderByWithRelationInput | ProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proficiencies.
     */
    cursor?: ProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proficiencies.
     */
    distinct?: ProficiencyScalarFieldEnum | ProficiencyScalarFieldEnum[]
  }

  /**
   * Proficiency findMany
   */
  export type ProficiencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Proficiencies to fetch.
     */
    where?: ProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proficiencies to fetch.
     */
    orderBy?: ProficiencyOrderByWithRelationInput | ProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proficiencies.
     */
    cursor?: ProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proficiencies.
     */
    skip?: number
    distinct?: ProficiencyScalarFieldEnum | ProficiencyScalarFieldEnum[]
  }

  /**
   * Proficiency create
   */
  export type ProficiencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Proficiency.
     */
    data: XOR<ProficiencyCreateInput, ProficiencyUncheckedCreateInput>
  }

  /**
   * Proficiency createMany
   */
  export type ProficiencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proficiencies.
     */
    data: ProficiencyCreateManyInput | ProficiencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proficiency createManyAndReturn
   */
  export type ProficiencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Proficiencies.
     */
    data: ProficiencyCreateManyInput | ProficiencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proficiency update
   */
  export type ProficiencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Proficiency.
     */
    data: XOR<ProficiencyUpdateInput, ProficiencyUncheckedUpdateInput>
    /**
     * Choose, which Proficiency to update.
     */
    where: ProficiencyWhereUniqueInput
  }

  /**
   * Proficiency updateMany
   */
  export type ProficiencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proficiencies.
     */
    data: XOR<ProficiencyUpdateManyMutationInput, ProficiencyUncheckedUpdateManyInput>
    /**
     * Filter which Proficiencies to update
     */
    where?: ProficiencyWhereInput
  }

  /**
   * Proficiency upsert
   */
  export type ProficiencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Proficiency to update in case it exists.
     */
    where: ProficiencyWhereUniqueInput
    /**
     * In case the Proficiency found by the `where` argument doesn't exist, create a new Proficiency with this data.
     */
    create: XOR<ProficiencyCreateInput, ProficiencyUncheckedCreateInput>
    /**
     * In case the Proficiency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProficiencyUpdateInput, ProficiencyUncheckedUpdateInput>
  }

  /**
   * Proficiency delete
   */
  export type ProficiencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
    /**
     * Filter which Proficiency to delete.
     */
    where: ProficiencyWhereUniqueInput
  }

  /**
   * Proficiency deleteMany
   */
  export type ProficiencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proficiencies to delete
     */
    where?: ProficiencyWhereInput
  }

  /**
   * Proficiency.businessDetails
   */
  export type Proficiency$businessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    cursor?: BusinessDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * Proficiency without action
   */
  export type ProficiencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proficiency
     */
    select?: ProficiencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProficiencyInclude<ExtArgs> | null
  }


  /**
   * Model Court
   */

  export type AggregateCourt = {
    _count: CourtCountAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  export type CourtMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type CourtMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type CourtCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    _all: number
  }


  export type CourtMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type CourtMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type CourtCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Court to aggregate.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courts
    **/
    _count?: true | CourtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourtMaxAggregateInputType
  }

  export type GetCourtAggregateType<T extends CourtAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt[P]>
      : GetScalarType<T[P], AggregateCourt[P]>
  }




  export type CourtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithAggregationInput | CourtOrderByWithAggregationInput[]
    by: CourtScalarFieldEnum[] | CourtScalarFieldEnum
    having?: CourtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourtCountAggregateInputType | true
    _min?: CourtMinAggregateInputType
    _max?: CourtMaxAggregateInputType
  }

  export type CourtGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    _count: CourtCountAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  type GetCourtGroupByPayload<T extends CourtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourtGroupByOutputType[P]>
            : GetScalarType<T[P], CourtGroupByOutputType[P]>
        }
      >
    >


  export type CourtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    businessDetails?: boolean | Court$businessDetailsArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["court"]>

  export type CourtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["court"]>

  export type CourtSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }

  export type CourtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessDetails?: boolean | Court$businessDetailsArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CourtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Court"
    objects: {
      businessDetails: Prisma.$BusinessDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["court"]>
    composites: {}
  }

  type CourtGetPayload<S extends boolean | null | undefined | CourtDefaultArgs> = $Result.GetResult<Prisma.$CourtPayload, S>

  type CourtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourtFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourtCountAggregateInputType | true
    }

  export interface CourtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Court'], meta: { name: 'Court' } }
    /**
     * Find zero or one Court that matches the filter.
     * @param {CourtFindUniqueArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourtFindUniqueArgs>(args: SelectSubset<T, CourtFindUniqueArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Court that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourtFindUniqueOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourtFindUniqueOrThrowArgs>(args: SelectSubset<T, CourtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Court that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourtFindFirstArgs>(args?: SelectSubset<T, CourtFindFirstArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Court that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourtFindFirstOrThrowArgs>(args?: SelectSubset<T, CourtFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courts
     * const courts = await prisma.court.findMany()
     * 
     * // Get first 10 Courts
     * const courts = await prisma.court.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courtWithIdOnly = await prisma.court.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourtFindManyArgs>(args?: SelectSubset<T, CourtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Court.
     * @param {CourtCreateArgs} args - Arguments to create a Court.
     * @example
     * // Create one Court
     * const Court = await prisma.court.create({
     *   data: {
     *     // ... data to create a Court
     *   }
     * })
     * 
     */
    create<T extends CourtCreateArgs>(args: SelectSubset<T, CourtCreateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courts.
     * @param {CourtCreateManyArgs} args - Arguments to create many Courts.
     * @example
     * // Create many Courts
     * const court = await prisma.court.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourtCreateManyArgs>(args?: SelectSubset<T, CourtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courts and returns the data saved in the database.
     * @param {CourtCreateManyAndReturnArgs} args - Arguments to create many Courts.
     * @example
     * // Create many Courts
     * const court = await prisma.court.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courts and only return the `id`
     * const courtWithIdOnly = await prisma.court.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourtCreateManyAndReturnArgs>(args?: SelectSubset<T, CourtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Court.
     * @param {CourtDeleteArgs} args - Arguments to delete one Court.
     * @example
     * // Delete one Court
     * const Court = await prisma.court.delete({
     *   where: {
     *     // ... filter to delete one Court
     *   }
     * })
     * 
     */
    delete<T extends CourtDeleteArgs>(args: SelectSubset<T, CourtDeleteArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Court.
     * @param {CourtUpdateArgs} args - Arguments to update one Court.
     * @example
     * // Update one Court
     * const court = await prisma.court.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourtUpdateArgs>(args: SelectSubset<T, CourtUpdateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courts.
     * @param {CourtDeleteManyArgs} args - Arguments to filter Courts to delete.
     * @example
     * // Delete a few Courts
     * const { count } = await prisma.court.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourtDeleteManyArgs>(args?: SelectSubset<T, CourtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courts
     * const court = await prisma.court.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourtUpdateManyArgs>(args: SelectSubset<T, CourtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court.
     * @param {CourtUpsertArgs} args - Arguments to update or create a Court.
     * @example
     * // Update or create a Court
     * const court = await prisma.court.upsert({
     *   create: {
     *     // ... data to create a Court
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court we want to update
     *   }
     * })
     */
    upsert<T extends CourtUpsertArgs>(args: SelectSubset<T, CourtUpsertArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCountArgs} args - Arguments to filter Courts to count.
     * @example
     * // Count the number of Courts
     * const count = await prisma.court.count({
     *   where: {
     *     // ... the filter for the Courts we want to count
     *   }
     * })
    **/
    count<T extends CourtCountArgs>(
      args?: Subset<T, CourtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourtAggregateArgs>(args: Subset<T, CourtAggregateArgs>): Prisma.PrismaPromise<GetCourtAggregateType<T>>

    /**
     * Group by Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourtGroupByArgs['orderBy'] }
        : { orderBy?: CourtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Court model
   */
  readonly fields: CourtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Court.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessDetails<T extends Court$businessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Court$businessDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Court model
   */ 
  interface CourtFieldRefs {
    readonly id: FieldRef<"Court", 'String'>
    readonly name: FieldRef<"Court", 'String'>
    readonly slug: FieldRef<"Court", 'String'>
    readonly createdAt: FieldRef<"Court", 'DateTime'>
    readonly deletedAt: FieldRef<"Court", 'DateTime'>
    readonly updatedAt: FieldRef<"Court", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Court findUnique
   */
  export type CourtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findUniqueOrThrow
   */
  export type CourtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findFirst
   */
  export type CourtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findFirstOrThrow
   */
  export type CourtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findMany
   */
  export type CourtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Courts to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court create
   */
  export type CourtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to create a Court.
     */
    data: XOR<CourtCreateInput, CourtUncheckedCreateInput>
  }

  /**
   * Court createMany
   */
  export type CourtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courts.
     */
    data: CourtCreateManyInput | CourtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Court createManyAndReturn
   */
  export type CourtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courts.
     */
    data: CourtCreateManyInput | CourtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Court update
   */
  export type CourtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to update a Court.
     */
    data: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
    /**
     * Choose, which Court to update.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court updateMany
   */
  export type CourtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courts.
     */
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyInput>
    /**
     * Filter which Courts to update
     */
    where?: CourtWhereInput
  }

  /**
   * Court upsert
   */
  export type CourtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The filter to search for the Court to update in case it exists.
     */
    where: CourtWhereUniqueInput
    /**
     * In case the Court found by the `where` argument doesn't exist, create a new Court with this data.
     */
    create: XOR<CourtCreateInput, CourtUncheckedCreateInput>
    /**
     * In case the Court was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
  }

  /**
   * Court delete
   */
  export type CourtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter which Court to delete.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court deleteMany
   */
  export type CourtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courts to delete
     */
    where?: CourtWhereInput
  }

  /**
   * Court.businessDetails
   */
  export type Court$businessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    cursor?: BusinessDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * Court without action
   */
  export type CourtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly deletedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    categoryImage: string | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    deletedAt: Date | null
    categoryImage: string | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    deletedAt: number
    categoryImage: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    categoryImage?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    categoryImage?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    deletedAt?: true
    categoryImage?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    createdAt: Date
    deletedAt: Date | null
    categoryImage: string | null
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    categoryImage?: boolean
    updatedAt?: boolean
    businessesDetails?: boolean | Category$businessesDetailsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    categoryImage?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    categoryImage?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessesDetails?: boolean | Category$businessesDetailsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      businessesDetails: Prisma.$BusinessDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      createdAt: Date
      deletedAt: Date | null
      categoryImage: string | null
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessesDetails<T extends Category$businessesDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Category$businessesDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly deletedAt: FieldRef<"Category", 'DateTime'>
    readonly categoryImage: FieldRef<"Category", 'String'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.businessesDetails
   */
  export type Category$businessesDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    cursor?: BusinessDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    BusinessDetails?: boolean | Tag$BusinessDetailsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BusinessDetails?: boolean | Tag$BusinessDetailsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      BusinessDetails: Prisma.$BusinessDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BusinessDetails<T extends Tag$BusinessDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$BusinessDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly deletedAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag.BusinessDetails
   */
  export type Tag$BusinessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDetails
     */
    select?: BusinessDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDetailsInclude<ExtArgs> | null
    where?: BusinessDetailsWhereInput
    orderBy?: BusinessDetailsOrderByWithRelationInput | BusinessDetailsOrderByWithRelationInput[]
    cursor?: BusinessDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessDetailsScalarFieldEnum | BusinessDetailsScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    businessId: string | null
    userId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    businessId: string | null
    userId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    rating: number
    comment: number
    businessId: number
    userId: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    businessId?: true
    userId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    businessId?: true
    userId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    businessId?: true
    userId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    rating: number
    comment: string | null
    businessId: string | null
    userId: string
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    businessId?: boolean
    userId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    business?: boolean | Review$businessArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    businessId?: boolean
    userId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    business?: boolean | Review$businessArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    rating?: boolean
    comment?: boolean
    businessId?: boolean
    userId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Review$businessArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Review$businessArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      comment: string | null
      businessId: string | null
      userId: string
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends Review$businessArgs<ExtArgs> = {}>(args?: Subset<T, Review$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Review$userArgs<ExtArgs> = {}>(args?: Subset<T, Review$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly businessId: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly deletedAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review.business
   */
  export type Review$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Review.user
   */
  export type Review$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    businessId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    businessId: string | null
    createdAt: Date | null
    deletedAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    date: number
    userId: number
    businessId: number
    createdAt: number
    deletedAt: number
    updatedAt: number
    _all: number
  }


  export type BookingMinAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    businessId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    businessId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    businessId?: true
    createdAt?: true
    deletedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    date: Date
    userId: string
    businessId: string
    createdAt: Date
    deletedAt: Date | null
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    businessId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    businessId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    date?: boolean
    userId?: boolean
    businessId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      userId: string
      businessId: string
      createdAt: Date
      deletedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly date: FieldRef<"Booking", 'DateTime'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly businessId: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly deletedAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    userId: number
    businessId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    userId?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    userId?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    userId?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    userId: string
    businessId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Business?: boolean | BusinessDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Message?: boolean | Chat$MessageArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Business?: boolean | BusinessDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    userId?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Business?: boolean | BusinessDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Message?: boolean | Chat$MessageArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Business?: boolean | BusinessDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      Business: Prisma.$BusinessPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      Message: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Message<T extends Chat$MessageArgs<ExtArgs> = {}>(args?: Subset<T, Chat$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly userId: FieldRef<"Chat", 'String'>
    readonly businessId: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
    readonly deletedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }

  /**
   * Chat.Message
   */
  export type Chat$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    senderType: $Enums.SenderType | null
    chatId: string | null
    createdAt: Date | null
    readAt: Date | null
    fileType: string | null
    fileUrl: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    senderType: $Enums.SenderType | null
    chatId: string | null
    createdAt: Date | null
    readAt: Date | null
    fileType: string | null
    fileUrl: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    senderType: number
    chatId: number
    createdAt: number
    readAt: number
    fileType: number
    fileUrl: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    senderType?: true
    chatId?: true
    createdAt?: true
    readAt?: true
    fileType?: true
    fileUrl?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    senderType?: true
    chatId?: true
    createdAt?: true
    readAt?: true
    fileType?: true
    fileUrl?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    senderType?: true
    chatId?: true
    createdAt?: true
    readAt?: true
    fileType?: true
    fileUrl?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    senderType: $Enums.SenderType
    chatId: string
    createdAt: Date
    readAt: Date | null
    fileType: string | null
    fileUrl: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderType?: boolean
    chatId?: boolean
    createdAt?: boolean
    readAt?: boolean
    fileType?: boolean
    fileUrl?: boolean
    chats?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderType?: boolean
    chatId?: boolean
    createdAt?: boolean
    readAt?: boolean
    fileType?: boolean
    fileUrl?: boolean
    chats?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    senderType?: boolean
    chatId?: boolean
    createdAt?: boolean
    readAt?: boolean
    fileType?: boolean
    fileUrl?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chats: Prisma.$ChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      senderType: $Enums.SenderType
      chatId: string
      createdAt: Date
      readAt: Date | null
      fileType: string | null
      fileUrl: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly senderType: FieldRef<"Message", 'SenderType'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly fileType: FieldRef<"Message", 'String'>
    readonly fileUrl: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Pincode
   */

  export type AggregatePincode = {
    _count: PincodeCountAggregateOutputType | null
    _min: PincodeMinAggregateOutputType | null
    _max: PincodeMaxAggregateOutputType | null
  }

  export type PincodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    slug: string | null
    cityId: string | null
  }

  export type PincodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    slug: string | null
    cityId: string | null
  }

  export type PincodeCountAggregateOutputType = {
    id: number
    code: number
    slug: number
    cityId: number
    _all: number
  }


  export type PincodeMinAggregateInputType = {
    id?: true
    code?: true
    slug?: true
    cityId?: true
  }

  export type PincodeMaxAggregateInputType = {
    id?: true
    code?: true
    slug?: true
    cityId?: true
  }

  export type PincodeCountAggregateInputType = {
    id?: true
    code?: true
    slug?: true
    cityId?: true
    _all?: true
  }

  export type PincodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pincode to aggregate.
     */
    where?: PincodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pincodes to fetch.
     */
    orderBy?: PincodeOrderByWithRelationInput | PincodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PincodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pincodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pincodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pincodes
    **/
    _count?: true | PincodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PincodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PincodeMaxAggregateInputType
  }

  export type GetPincodeAggregateType<T extends PincodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePincode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePincode[P]>
      : GetScalarType<T[P], AggregatePincode[P]>
  }




  export type PincodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PincodeWhereInput
    orderBy?: PincodeOrderByWithAggregationInput | PincodeOrderByWithAggregationInput[]
    by: PincodeScalarFieldEnum[] | PincodeScalarFieldEnum
    having?: PincodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PincodeCountAggregateInputType | true
    _min?: PincodeMinAggregateInputType
    _max?: PincodeMaxAggregateInputType
  }

  export type PincodeGroupByOutputType = {
    id: string
    code: string
    slug: string | null
    cityId: string
    _count: PincodeCountAggregateOutputType | null
    _min: PincodeMinAggregateOutputType | null
    _max: PincodeMaxAggregateOutputType | null
  }

  type GetPincodeGroupByPayload<T extends PincodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PincodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PincodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PincodeGroupByOutputType[P]>
            : GetScalarType<T[P], PincodeGroupByOutputType[P]>
        }
      >
    >


  export type PincodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    slug?: boolean
    cityId?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pincode"]>

  export type PincodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    slug?: boolean
    cityId?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pincode"]>

  export type PincodeSelectScalar = {
    id?: boolean
    code?: boolean
    slug?: boolean
    cityId?: boolean
  }

  export type PincodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type PincodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $PincodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pincode"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      slug: string | null
      cityId: string
    }, ExtArgs["result"]["pincode"]>
    composites: {}
  }

  type PincodeGetPayload<S extends boolean | null | undefined | PincodeDefaultArgs> = $Result.GetResult<Prisma.$PincodePayload, S>

  type PincodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PincodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PincodeCountAggregateInputType | true
    }

  export interface PincodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pincode'], meta: { name: 'Pincode' } }
    /**
     * Find zero or one Pincode that matches the filter.
     * @param {PincodeFindUniqueArgs} args - Arguments to find a Pincode
     * @example
     * // Get one Pincode
     * const pincode = await prisma.pincode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PincodeFindUniqueArgs>(args: SelectSubset<T, PincodeFindUniqueArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pincode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PincodeFindUniqueOrThrowArgs} args - Arguments to find a Pincode
     * @example
     * // Get one Pincode
     * const pincode = await prisma.pincode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PincodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PincodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pincode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PincodeFindFirstArgs} args - Arguments to find a Pincode
     * @example
     * // Get one Pincode
     * const pincode = await prisma.pincode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PincodeFindFirstArgs>(args?: SelectSubset<T, PincodeFindFirstArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pincode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PincodeFindFirstOrThrowArgs} args - Arguments to find a Pincode
     * @example
     * // Get one Pincode
     * const pincode = await prisma.pincode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PincodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PincodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pincodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PincodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pincodes
     * const pincodes = await prisma.pincode.findMany()
     * 
     * // Get first 10 Pincodes
     * const pincodes = await prisma.pincode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pincodeWithIdOnly = await prisma.pincode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PincodeFindManyArgs>(args?: SelectSubset<T, PincodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pincode.
     * @param {PincodeCreateArgs} args - Arguments to create a Pincode.
     * @example
     * // Create one Pincode
     * const Pincode = await prisma.pincode.create({
     *   data: {
     *     // ... data to create a Pincode
     *   }
     * })
     * 
     */
    create<T extends PincodeCreateArgs>(args: SelectSubset<T, PincodeCreateArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pincodes.
     * @param {PincodeCreateManyArgs} args - Arguments to create many Pincodes.
     * @example
     * // Create many Pincodes
     * const pincode = await prisma.pincode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PincodeCreateManyArgs>(args?: SelectSubset<T, PincodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pincodes and returns the data saved in the database.
     * @param {PincodeCreateManyAndReturnArgs} args - Arguments to create many Pincodes.
     * @example
     * // Create many Pincodes
     * const pincode = await prisma.pincode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pincodes and only return the `id`
     * const pincodeWithIdOnly = await prisma.pincode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PincodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PincodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pincode.
     * @param {PincodeDeleteArgs} args - Arguments to delete one Pincode.
     * @example
     * // Delete one Pincode
     * const Pincode = await prisma.pincode.delete({
     *   where: {
     *     // ... filter to delete one Pincode
     *   }
     * })
     * 
     */
    delete<T extends PincodeDeleteArgs>(args: SelectSubset<T, PincodeDeleteArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pincode.
     * @param {PincodeUpdateArgs} args - Arguments to update one Pincode.
     * @example
     * // Update one Pincode
     * const pincode = await prisma.pincode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PincodeUpdateArgs>(args: SelectSubset<T, PincodeUpdateArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pincodes.
     * @param {PincodeDeleteManyArgs} args - Arguments to filter Pincodes to delete.
     * @example
     * // Delete a few Pincodes
     * const { count } = await prisma.pincode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PincodeDeleteManyArgs>(args?: SelectSubset<T, PincodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pincodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PincodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pincodes
     * const pincode = await prisma.pincode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PincodeUpdateManyArgs>(args: SelectSubset<T, PincodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pincode.
     * @param {PincodeUpsertArgs} args - Arguments to update or create a Pincode.
     * @example
     * // Update or create a Pincode
     * const pincode = await prisma.pincode.upsert({
     *   create: {
     *     // ... data to create a Pincode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pincode we want to update
     *   }
     * })
     */
    upsert<T extends PincodeUpsertArgs>(args: SelectSubset<T, PincodeUpsertArgs<ExtArgs>>): Prisma__PincodeClient<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pincodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PincodeCountArgs} args - Arguments to filter Pincodes to count.
     * @example
     * // Count the number of Pincodes
     * const count = await prisma.pincode.count({
     *   where: {
     *     // ... the filter for the Pincodes we want to count
     *   }
     * })
    **/
    count<T extends PincodeCountArgs>(
      args?: Subset<T, PincodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PincodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pincode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PincodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PincodeAggregateArgs>(args: Subset<T, PincodeAggregateArgs>): Prisma.PrismaPromise<GetPincodeAggregateType<T>>

    /**
     * Group by Pincode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PincodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PincodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PincodeGroupByArgs['orderBy'] }
        : { orderBy?: PincodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PincodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPincodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pincode model
   */
  readonly fields: PincodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pincode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PincodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pincode model
   */ 
  interface PincodeFieldRefs {
    readonly id: FieldRef<"Pincode", 'String'>
    readonly code: FieldRef<"Pincode", 'String'>
    readonly slug: FieldRef<"Pincode", 'String'>
    readonly cityId: FieldRef<"Pincode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pincode findUnique
   */
  export type PincodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * Filter, which Pincode to fetch.
     */
    where: PincodeWhereUniqueInput
  }

  /**
   * Pincode findUniqueOrThrow
   */
  export type PincodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * Filter, which Pincode to fetch.
     */
    where: PincodeWhereUniqueInput
  }

  /**
   * Pincode findFirst
   */
  export type PincodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * Filter, which Pincode to fetch.
     */
    where?: PincodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pincodes to fetch.
     */
    orderBy?: PincodeOrderByWithRelationInput | PincodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pincodes.
     */
    cursor?: PincodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pincodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pincodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pincodes.
     */
    distinct?: PincodeScalarFieldEnum | PincodeScalarFieldEnum[]
  }

  /**
   * Pincode findFirstOrThrow
   */
  export type PincodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * Filter, which Pincode to fetch.
     */
    where?: PincodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pincodes to fetch.
     */
    orderBy?: PincodeOrderByWithRelationInput | PincodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pincodes.
     */
    cursor?: PincodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pincodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pincodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pincodes.
     */
    distinct?: PincodeScalarFieldEnum | PincodeScalarFieldEnum[]
  }

  /**
   * Pincode findMany
   */
  export type PincodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * Filter, which Pincodes to fetch.
     */
    where?: PincodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pincodes to fetch.
     */
    orderBy?: PincodeOrderByWithRelationInput | PincodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pincodes.
     */
    cursor?: PincodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pincodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pincodes.
     */
    skip?: number
    distinct?: PincodeScalarFieldEnum | PincodeScalarFieldEnum[]
  }

  /**
   * Pincode create
   */
  export type PincodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * The data needed to create a Pincode.
     */
    data: XOR<PincodeCreateInput, PincodeUncheckedCreateInput>
  }

  /**
   * Pincode createMany
   */
  export type PincodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pincodes.
     */
    data: PincodeCreateManyInput | PincodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pincode createManyAndReturn
   */
  export type PincodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pincodes.
     */
    data: PincodeCreateManyInput | PincodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pincode update
   */
  export type PincodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * The data needed to update a Pincode.
     */
    data: XOR<PincodeUpdateInput, PincodeUncheckedUpdateInput>
    /**
     * Choose, which Pincode to update.
     */
    where: PincodeWhereUniqueInput
  }

  /**
   * Pincode updateMany
   */
  export type PincodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pincodes.
     */
    data: XOR<PincodeUpdateManyMutationInput, PincodeUncheckedUpdateManyInput>
    /**
     * Filter which Pincodes to update
     */
    where?: PincodeWhereInput
  }

  /**
   * Pincode upsert
   */
  export type PincodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * The filter to search for the Pincode to update in case it exists.
     */
    where: PincodeWhereUniqueInput
    /**
     * In case the Pincode found by the `where` argument doesn't exist, create a new Pincode with this data.
     */
    create: XOR<PincodeCreateInput, PincodeUncheckedCreateInput>
    /**
     * In case the Pincode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PincodeUpdateInput, PincodeUncheckedUpdateInput>
  }

  /**
   * Pincode delete
   */
  export type PincodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    /**
     * Filter which Pincode to delete.
     */
    where: PincodeWhereUniqueInput
  }

  /**
   * Pincode deleteMany
   */
  export type PincodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pincodes to delete
     */
    where?: PincodeWhereInput
  }

  /**
   * Pincode without action
   */
  export type PincodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    stateId: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    stateId: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    stateId: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    stateId?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    stateId?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    stateId?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    stateId: string
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    stateId?: boolean
    state?: boolean | StateDefaultArgs<ExtArgs>
    pincodes?: boolean | City$pincodesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    stateId?: boolean
    state?: boolean | StateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    stateId?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | StateDefaultArgs<ExtArgs>
    pincodes?: boolean | City$pincodesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | StateDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      state: Prisma.$StatePayload<ExtArgs>
      pincodes: Prisma.$PincodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      stateId: string
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    state<T extends StateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StateDefaultArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pincodes<T extends City$pincodesArgs<ExtArgs> = {}>(args?: Subset<T, City$pincodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PincodePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly slug: FieldRef<"City", 'String'>
    readonly stateId: FieldRef<"City", 'String'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City.pincodes
   */
  export type City$pincodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pincode
     */
    select?: PincodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PincodeInclude<ExtArgs> | null
    where?: PincodeWhereInput
    orderBy?: PincodeOrderByWithRelationInput | PincodeOrderByWithRelationInput[]
    cursor?: PincodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PincodeScalarFieldEnum | PincodeScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model State
   */

  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    countryId: string | null
  }

  export type StateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    countryId: string | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    countryId: number
    _all: number
  }


  export type StateMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    countryId?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    countryId?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    countryId?: true
    _all?: true
  }

  export type StateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which State to aggregate.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StateWhereInput
    orderBy?: StateOrderByWithAggregationInput | StateOrderByWithAggregationInput[]
    by: StateScalarFieldEnum[] | StateScalarFieldEnum
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }

  export type StateGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    countryId: string
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    cities?: boolean | State$citiesArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["state"]>

  export type StateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["state"]>

  export type StateSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    countryId?: boolean
  }

  export type StateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    cities?: boolean | State$citiesArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $StatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "State"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      cities: Prisma.$CityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      countryId: string
    }, ExtArgs["result"]["state"]>
    composites: {}
  }

  type StateGetPayload<S extends boolean | null | undefined | StateDefaultArgs> = $Result.GetResult<Prisma.$StatePayload, S>

  type StateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StateCountAggregateInputType | true
    }

  export interface StateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['State'], meta: { name: 'State' } }
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StateFindUniqueArgs>(args: SelectSubset<T, StateFindUniqueArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one State that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs>(args: SelectSubset<T, StateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StateFindFirstArgs>(args?: SelectSubset<T, StateFindFirstArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first State that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StateFindFirstOrThrowArgs>(args?: SelectSubset<T, StateFindFirstOrThrowArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StateFindManyArgs>(args?: SelectSubset<T, StateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
     */
    create<T extends StateCreateArgs>(args: SelectSubset<T, StateCreateArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many States.
     * @param {StateCreateManyArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const state = await prisma.state.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StateCreateManyArgs>(args?: SelectSubset<T, StateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many States and returns the data saved in the database.
     * @param {StateCreateManyAndReturnArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const state = await prisma.state.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many States and only return the `id`
     * const stateWithIdOnly = await prisma.state.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StateCreateManyAndReturnArgs>(args?: SelectSubset<T, StateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
     */
    delete<T extends StateDeleteArgs>(args: SelectSubset<T, StateDeleteArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StateUpdateArgs>(args: SelectSubset<T, StateUpdateArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StateDeleteManyArgs>(args?: SelectSubset<T, StateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StateUpdateManyArgs>(args: SelectSubset<T, StateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
     */
    upsert<T extends StateUpsertArgs>(args: SelectSubset<T, StateUpsertArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): Prisma.PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the State model
   */
  readonly fields: StateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cities<T extends State$citiesArgs<ExtArgs> = {}>(args?: Subset<T, State$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the State model
   */ 
  interface StateFieldRefs {
    readonly id: FieldRef<"State", 'String'>
    readonly name: FieldRef<"State", 'String'>
    readonly slug: FieldRef<"State", 'String'>
    readonly countryId: FieldRef<"State", 'String'>
  }
    

  // Custom InputTypes
  /**
   * State findUnique
   */
  export type StateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State findUniqueOrThrow
   */
  export type StateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State findFirst
   */
  export type StateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * State findFirstOrThrow
   */
  export type StateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * State findMany
   */
  export type StateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * State create
   */
  export type StateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The data needed to create a State.
     */
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }

  /**
   * State createMany
   */
  export type StateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many States.
     */
    data: StateCreateManyInput | StateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * State createManyAndReturn
   */
  export type StateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many States.
     */
    data: StateCreateManyInput | StateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * State update
   */
  export type StateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The data needed to update a State.
     */
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State updateMany
   */
  export type StateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update States.
     */
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     */
    where?: StateWhereInput
  }

  /**
   * State upsert
   */
  export type StateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The filter to search for the State to update in case it exists.
     */
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     */
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }

  /**
   * State delete
   */
  export type StateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter which State to delete.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which States to delete
     */
    where?: StateWhereInput
  }

  /**
   * State.cities
   */
  export type State$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * State without action
   */
  export type StateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    state?: boolean | Country$stateArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | Country$stateArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      state: Prisma.$StatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    state<T extends Country$stateArgs<ExtArgs> = {}>(args?: Subset<T, Country$stateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly slug: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }

  /**
   * Country.state
   */
  export type Country$stateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    where?: StateWhereInput
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    cursor?: StateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserSubscriptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    duration: 'duration',
    features: 'features',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    password: 'password',
    salt: 'salt',
    hideDetails: 'hideDetails',
    avatar: 'avatar',
    subscriptionId: 'subscriptionId',
    subscriptionExpire: 'subscriptionExpire',
    paymentVerification: 'paymentVerification',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    value: 'value',
    isVerified: 'isVerified',
    isPrimary: 'isPrimary',
    order: 'order',
    verifiedAt: 'verifiedAt',
    otp: 'otp',
    otpExpiresAt: 'otpExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserContactScalarFieldEnum = (typeof UserContactScalarFieldEnum)[keyof typeof UserContactScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt',
    order: 'order',
    street: 'street',
    city: 'city',
    country: 'country',
    pincode: 'pincode',
    state: 'state'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const BusinessSubscriptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    price: 'price',
    duration: 'duration',
    features: 'features',
    tierLevel: 'tierLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BusinessSubscriptionScalarFieldEnum = (typeof BusinessSubscriptionScalarFieldEnum)[keyof typeof BusinessSubscriptionScalarFieldEnum]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    additionalContacts: 'additionalContacts',
    password: 'password',
    salt: 'salt',
    isBusinessVerified: 'isBusinessVerified',
    type: 'type',
    subscriptionId: 'subscriptionId',
    subscriptionExpire: 'subscriptionExpire',
    averageRating: 'averageRating',
    reviewCount: 'reviewCount',
    isListed: 'isListed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    paymentVerification: 'paymentVerification',
    price: 'price'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const BusinessPrimaryContactScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    type: 'type',
    value: 'value',
    isVerified: 'isVerified',
    isPrimary: 'isPrimary',
    order: 'order',
    verifiedAt: 'verifiedAt',
    otp: 'otp',
    otpExpiresAt: 'otpExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BusinessPrimaryContactScalarFieldEnum = (typeof BusinessPrimaryContactScalarFieldEnum)[keyof typeof BusinessPrimaryContactScalarFieldEnum]


  export const BusinessAddressScalarFieldEnum: {
    id: 'id',
    businessDetailsId: 'businessDetailsId',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt',
    order: 'order',
    street: 'street',
    city: 'city',
    country: 'country',
    pincode: 'pincode',
    state: 'state'
  };

  export type BusinessAddressScalarFieldEnum = (typeof BusinessAddressScalarFieldEnum)[keyof typeof BusinessAddressScalarFieldEnum]


  export const BusinessDetailsScalarFieldEnum: {
    id: 'id',
    registrationNumber: 'registrationNumber',
    license: 'license',
    experience: 'experience',
    teamSize: 'teamSize',
    description: 'description',
    latitude: 'latitude',
    longitude: 'longitude',
    degree: 'degree',
    gstNumber: 'gstNumber',
    categoryId: 'categoryId',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BusinessDetailsScalarFieldEnum = (typeof BusinessDetailsScalarFieldEnum)[keyof typeof BusinessDetailsScalarFieldEnum]


  export const BusinessSupportingDocumentsScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    type: 'type',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BusinessSupportingDocumentsScalarFieldEnum = (typeof BusinessSupportingDocumentsScalarFieldEnum)[keyof typeof BusinessSupportingDocumentsScalarFieldEnum]


  export const BusinessImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    order: 'order',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt',
    businessDetailsId: 'businessDetailsId'
  };

  export type BusinessImageScalarFieldEnum = (typeof BusinessImageScalarFieldEnum)[keyof typeof BusinessImageScalarFieldEnum]


  export const BusinessWebsiteScalarFieldEnum: {
    id: 'id',
    type: 'type',
    url: 'url',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt',
    businessDetailsId: 'businessDetailsId'
  };

  export type BusinessWebsiteScalarFieldEnum = (typeof BusinessWebsiteScalarFieldEnum)[keyof typeof BusinessWebsiteScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const ProficiencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt'
  };

  export type ProficiencyScalarFieldEnum = (typeof ProficiencyScalarFieldEnum)[keyof typeof ProficiencyScalarFieldEnum]


  export const CourtScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt'
  };

  export type CourtScalarFieldEnum = (typeof CourtScalarFieldEnum)[keyof typeof CourtScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    categoryImage: 'categoryImage',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    comment: 'comment',
    businessId: 'businessId',
    userId: 'userId',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    date: 'date',
    userId: 'userId',
    businessId: 'businessId',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessId: 'businessId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    senderType: 'senderType',
    chatId: 'chatId',
    createdAt: 'createdAt',
    readAt: 'readAt',
    fileType: 'fileType',
    fileUrl: 'fileUrl'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const PincodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    slug: 'slug',
    cityId: 'cityId'
  };

  export type PincodeScalarFieldEnum = (typeof PincodeScalarFieldEnum)[keyof typeof PincodeScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    stateId: 'stateId'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const StateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    countryId: 'countryId'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


  /**
   * Reference to a field of type 'BusinessType'
   */
  export type EnumBusinessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessType'>
    


  /**
   * Reference to a field of type 'BusinessType[]'
   */
  export type ListEnumBusinessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessType[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    name?: StringFilter<"UserSubscription"> | string
    description?: StringNullableFilter<"UserSubscription"> | string | null
    price?: FloatFilter<"UserSubscription"> | number
    duration?: IntFilter<"UserSubscription"> | number
    features?: StringNullableListFilter<"UserSubscription">
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    users?: UserListRelationFilter
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    name?: StringFilter<"UserSubscription"> | string
    description?: StringNullableFilter<"UserSubscription"> | string | null
    price?: FloatFilter<"UserSubscription"> | number
    duration?: IntFilter<"UserSubscription"> | number
    features?: StringNullableListFilter<"UserSubscription">
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    users?: UserListRelationFilter
  }, "id">

  export type UserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _avg?: UserSubscriptionAvgOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
    _sum?: UserSubscriptionSumOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSubscription"> | string
    name?: StringWithAggregatesFilter<"UserSubscription"> | string
    description?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    price?: FloatWithAggregatesFilter<"UserSubscription"> | number
    duration?: IntWithAggregatesFilter<"UserSubscription"> | number
    features?: StringNullableListFilter<"UserSubscription">
    createdAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    slug?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    hideDetails?: BoolFilter<"User"> | boolean
    avatar?: StringNullableFilter<"User"> | string | null
    subscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionExpire?: DateTimeNullableFilter<"User"> | Date | string | null
    paymentVerification?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    contacts?: UserContactListRelationFilter
    addresses?: UserAddressListRelationFilter
    bookings?: BookingListRelationFilter
    chats?: ChatListRelationFilter
    reviews?: ReviewListRelationFilter
    subscription?: XOR<UserSubscriptionNullableRelationFilter, UserSubscriptionWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    hideDetails?: SortOrder
    avatar?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionExpire?: SortOrderInput | SortOrder
    paymentVerification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    contacts?: UserContactOrderByRelationAggregateInput
    addresses?: UserAddressOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    subscription?: UserSubscriptionOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    hideDetails?: BoolFilter<"User"> | boolean
    avatar?: StringNullableFilter<"User"> | string | null
    subscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionExpire?: DateTimeNullableFilter<"User"> | Date | string | null
    paymentVerification?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    contacts?: UserContactListRelationFilter
    addresses?: UserAddressListRelationFilter
    bookings?: BookingListRelationFilter
    chats?: ChatListRelationFilter
    reviews?: ReviewListRelationFilter
    subscription?: XOR<UserSubscriptionNullableRelationFilter, UserSubscriptionWhereInput> | null
  }, "id" | "slug">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    hideDetails?: SortOrder
    avatar?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionExpire?: SortOrderInput | SortOrder
    paymentVerification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    slug?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    salt?: StringNullableWithAggregatesFilter<"User"> | string | null
    hideDetails?: BoolWithAggregatesFilter<"User"> | boolean
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionExpire?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    paymentVerification?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserContactWhereInput = {
    AND?: UserContactWhereInput | UserContactWhereInput[]
    OR?: UserContactWhereInput[]
    NOT?: UserContactWhereInput | UserContactWhereInput[]
    id?: StringFilter<"UserContact"> | string
    userId?: StringFilter<"UserContact"> | string
    type?: EnumContactTypeFilter<"UserContact"> | $Enums.ContactType
    value?: StringFilter<"UserContact"> | string
    isVerified?: BoolFilter<"UserContact"> | boolean
    isPrimary?: BoolFilter<"UserContact"> | boolean
    order?: IntNullableFilter<"UserContact"> | number | null
    verifiedAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    otp?: StringNullableFilter<"UserContact"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    createdAt?: DateTimeFilter<"UserContact"> | Date | string
    updatedAt?: DateTimeFilter<"UserContact"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    userId_type_isPrimary?: UserContactUserIdTypeIsPrimaryCompoundUniqueInput
    AND?: UserContactWhereInput | UserContactWhereInput[]
    OR?: UserContactWhereInput[]
    NOT?: UserContactWhereInput | UserContactWhereInput[]
    userId?: StringFilter<"UserContact"> | string
    type?: EnumContactTypeFilter<"UserContact"> | $Enums.ContactType
    isVerified?: BoolFilter<"UserContact"> | boolean
    isPrimary?: BoolFilter<"UserContact"> | boolean
    order?: IntNullableFilter<"UserContact"> | number | null
    verifiedAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    otp?: StringNullableFilter<"UserContact"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    createdAt?: DateTimeFilter<"UserContact"> | Date | string
    updatedAt?: DateTimeFilter<"UserContact"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "value" | "userId_type_isPrimary">

  export type UserContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserContactCountOrderByAggregateInput
    _avg?: UserContactAvgOrderByAggregateInput
    _max?: UserContactMaxOrderByAggregateInput
    _min?: UserContactMinOrderByAggregateInput
    _sum?: UserContactSumOrderByAggregateInput
  }

  export type UserContactScalarWhereWithAggregatesInput = {
    AND?: UserContactScalarWhereWithAggregatesInput | UserContactScalarWhereWithAggregatesInput[]
    OR?: UserContactScalarWhereWithAggregatesInput[]
    NOT?: UserContactScalarWhereWithAggregatesInput | UserContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserContact"> | string
    userId?: StringWithAggregatesFilter<"UserContact"> | string
    type?: EnumContactTypeWithAggregatesFilter<"UserContact"> | $Enums.ContactType
    value?: StringWithAggregatesFilter<"UserContact"> | string
    isVerified?: BoolWithAggregatesFilter<"UserContact"> | boolean
    isPrimary?: BoolWithAggregatesFilter<"UserContact"> | boolean
    order?: IntNullableWithAggregatesFilter<"UserContact"> | number | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"UserContact"> | Date | string | null
    otp?: StringNullableWithAggregatesFilter<"UserContact"> | string | null
    otpExpiresAt?: DateTimeNullableWithAggregatesFilter<"UserContact"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserContact"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserContact"> | Date | string | null
  }

  export type UserAddressWhereInput = {
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    id?: StringFilter<"UserAddress"> | string
    userId?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserAddress"> | Date | string | null
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    order?: IntNullableFilter<"UserAddress"> | number | null
    street?: StringFilter<"UserAddress"> | string
    city?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    pincode?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    order?: SortOrderInput | SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    userId?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserAddress"> | Date | string | null
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    order?: IntNullableFilter<"UserAddress"> | number | null
    street?: StringFilter<"UserAddress"> | string
    city?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    pincode?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    order?: SortOrderInput | SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _avg?: UserAddressAvgOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
    _sum?: UserAddressSumOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    OR?: UserAddressScalarWhereWithAggregatesInput[]
    NOT?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAddress"> | string
    userId?: StringWithAggregatesFilter<"UserAddress"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserAddress"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
    order?: IntNullableWithAggregatesFilter<"UserAddress"> | number | null
    street?: StringWithAggregatesFilter<"UserAddress"> | string
    city?: StringWithAggregatesFilter<"UserAddress"> | string
    country?: StringWithAggregatesFilter<"UserAddress"> | string
    pincode?: StringWithAggregatesFilter<"UserAddress"> | string
    state?: StringWithAggregatesFilter<"UserAddress"> | string
  }

  export type BusinessSubscriptionWhereInput = {
    AND?: BusinessSubscriptionWhereInput | BusinessSubscriptionWhereInput[]
    OR?: BusinessSubscriptionWhereInput[]
    NOT?: BusinessSubscriptionWhereInput | BusinessSubscriptionWhereInput[]
    id?: StringFilter<"BusinessSubscription"> | string
    name?: StringFilter<"BusinessSubscription"> | string
    description?: StringNullableFilter<"BusinessSubscription"> | string | null
    type?: EnumBusinessTypeFilter<"BusinessSubscription"> | $Enums.BusinessType
    price?: FloatFilter<"BusinessSubscription"> | number
    duration?: IntFilter<"BusinessSubscription"> | number
    features?: StringNullableListFilter<"BusinessSubscription">
    tierLevel?: IntFilter<"BusinessSubscription"> | number
    createdAt?: DateTimeFilter<"BusinessSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessSubscription"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessSubscription"> | Date | string | null
    businesses?: BusinessListRelationFilter
  }

  export type BusinessSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    tierLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    businesses?: BusinessOrderByRelationAggregateInput
  }

  export type BusinessSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessSubscriptionWhereInput | BusinessSubscriptionWhereInput[]
    OR?: BusinessSubscriptionWhereInput[]
    NOT?: BusinessSubscriptionWhereInput | BusinessSubscriptionWhereInput[]
    name?: StringFilter<"BusinessSubscription"> | string
    description?: StringNullableFilter<"BusinessSubscription"> | string | null
    type?: EnumBusinessTypeFilter<"BusinessSubscription"> | $Enums.BusinessType
    price?: FloatFilter<"BusinessSubscription"> | number
    duration?: IntFilter<"BusinessSubscription"> | number
    features?: StringNullableListFilter<"BusinessSubscription">
    tierLevel?: IntFilter<"BusinessSubscription"> | number
    createdAt?: DateTimeFilter<"BusinessSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessSubscription"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessSubscription"> | Date | string | null
    businesses?: BusinessListRelationFilter
  }, "id">

  export type BusinessSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    tierLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BusinessSubscriptionCountOrderByAggregateInput
    _avg?: BusinessSubscriptionAvgOrderByAggregateInput
    _max?: BusinessSubscriptionMaxOrderByAggregateInput
    _min?: BusinessSubscriptionMinOrderByAggregateInput
    _sum?: BusinessSubscriptionSumOrderByAggregateInput
  }

  export type BusinessSubscriptionScalarWhereWithAggregatesInput = {
    AND?: BusinessSubscriptionScalarWhereWithAggregatesInput | BusinessSubscriptionScalarWhereWithAggregatesInput[]
    OR?: BusinessSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: BusinessSubscriptionScalarWhereWithAggregatesInput | BusinessSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessSubscription"> | string
    name?: StringWithAggregatesFilter<"BusinessSubscription"> | string
    description?: StringNullableWithAggregatesFilter<"BusinessSubscription"> | string | null
    type?: EnumBusinessTypeWithAggregatesFilter<"BusinessSubscription"> | $Enums.BusinessType
    price?: FloatWithAggregatesFilter<"BusinessSubscription"> | number
    duration?: IntWithAggregatesFilter<"BusinessSubscription"> | number
    features?: StringNullableListFilter<"BusinessSubscription">
    tierLevel?: IntWithAggregatesFilter<"BusinessSubscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BusinessSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessSubscription"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BusinessSubscription"> | Date | string | null
  }

  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: StringFilter<"Business"> | string
    name?: StringNullableFilter<"Business"> | string | null
    slug?: StringNullableFilter<"Business"> | string | null
    additionalContacts?: StringNullableListFilter<"Business">
    password?: StringNullableFilter<"Business"> | string | null
    salt?: StringNullableFilter<"Business"> | string | null
    isBusinessVerified?: BoolFilter<"Business"> | boolean
    type?: EnumBusinessTypeFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableFilter<"Business"> | string | null
    subscriptionExpire?: DateTimeNullableFilter<"Business"> | Date | string | null
    averageRating?: FloatNullableFilter<"Business"> | number | null
    reviewCount?: IntFilter<"Business"> | number
    isListed?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    paymentVerification?: BoolFilter<"Business"> | boolean
    price?: FloatNullableFilter<"Business"> | number | null
    primaryContacts?: BusinessPrimaryContactListRelationFilter
    subscription?: XOR<BusinessSubscriptionNullableRelationFilter, BusinessSubscriptionWhereInput> | null
    chats?: ChatListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    businessSupportingDocuments?: BusinessSupportingDocumentsListRelationFilter
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    additionalContacts?: SortOrder
    password?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    isBusinessVerified?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionExpire?: SortOrderInput | SortOrder
    averageRating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    isListed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    paymentVerification?: SortOrder
    price?: SortOrderInput | SortOrder
    primaryContacts?: BusinessPrimaryContactOrderByRelationAggregateInput
    subscription?: BusinessSubscriptionOrderByWithRelationInput
    chats?: ChatOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    businessSupportingDocuments?: BusinessSupportingDocumentsOrderByRelationAggregateInput
    businessDetails?: BusinessDetailsOrderByWithRelationInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    name?: StringNullableFilter<"Business"> | string | null
    additionalContacts?: StringNullableListFilter<"Business">
    password?: StringNullableFilter<"Business"> | string | null
    salt?: StringNullableFilter<"Business"> | string | null
    isBusinessVerified?: BoolFilter<"Business"> | boolean
    type?: EnumBusinessTypeFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableFilter<"Business"> | string | null
    subscriptionExpire?: DateTimeNullableFilter<"Business"> | Date | string | null
    averageRating?: FloatNullableFilter<"Business"> | number | null
    reviewCount?: IntFilter<"Business"> | number
    isListed?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    paymentVerification?: BoolFilter<"Business"> | boolean
    price?: FloatNullableFilter<"Business"> | number | null
    primaryContacts?: BusinessPrimaryContactListRelationFilter
    subscription?: XOR<BusinessSubscriptionNullableRelationFilter, BusinessSubscriptionWhereInput> | null
    chats?: ChatListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    businessSupportingDocuments?: BusinessSupportingDocumentsListRelationFilter
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }, "id" | "slug">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    additionalContacts?: SortOrder
    password?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    isBusinessVerified?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionExpire?: SortOrderInput | SortOrder
    averageRating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    isListed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    paymentVerification?: SortOrder
    price?: SortOrderInput | SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _avg?: BusinessAvgOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
    _sum?: BusinessSumOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Business"> | string
    name?: StringNullableWithAggregatesFilter<"Business"> | string | null
    slug?: StringNullableWithAggregatesFilter<"Business"> | string | null
    additionalContacts?: StringNullableListFilter<"Business">
    password?: StringNullableWithAggregatesFilter<"Business"> | string | null
    salt?: StringNullableWithAggregatesFilter<"Business"> | string | null
    isBusinessVerified?: BoolWithAggregatesFilter<"Business"> | boolean
    type?: EnumBusinessTypeWithAggregatesFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableWithAggregatesFilter<"Business"> | string | null
    subscriptionExpire?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    averageRating?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    reviewCount?: IntWithAggregatesFilter<"Business"> | number
    isListed?: BoolWithAggregatesFilter<"Business"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    paymentVerification?: BoolWithAggregatesFilter<"Business"> | boolean
    price?: FloatNullableWithAggregatesFilter<"Business"> | number | null
  }

  export type BusinessPrimaryContactWhereInput = {
    AND?: BusinessPrimaryContactWhereInput | BusinessPrimaryContactWhereInput[]
    OR?: BusinessPrimaryContactWhereInput[]
    NOT?: BusinessPrimaryContactWhereInput | BusinessPrimaryContactWhereInput[]
    id?: StringFilter<"BusinessPrimaryContact"> | string
    businessId?: StringFilter<"BusinessPrimaryContact"> | string
    type?: EnumContactTypeFilter<"BusinessPrimaryContact"> | $Enums.ContactType
    value?: StringFilter<"BusinessPrimaryContact"> | string
    isVerified?: BoolFilter<"BusinessPrimaryContact"> | boolean
    isPrimary?: BoolFilter<"BusinessPrimaryContact"> | boolean
    order?: IntNullableFilter<"BusinessPrimaryContact"> | number | null
    verifiedAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    otp?: StringNullableFilter<"BusinessPrimaryContact"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    createdAt?: DateTimeFilter<"BusinessPrimaryContact"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessPrimaryContact"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type BusinessPrimaryContactOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type BusinessPrimaryContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    businessId_type_isPrimary?: BusinessPrimaryContactBusinessIdTypeIsPrimaryCompoundUniqueInput
    AND?: BusinessPrimaryContactWhereInput | BusinessPrimaryContactWhereInput[]
    OR?: BusinessPrimaryContactWhereInput[]
    NOT?: BusinessPrimaryContactWhereInput | BusinessPrimaryContactWhereInput[]
    businessId?: StringFilter<"BusinessPrimaryContact"> | string
    type?: EnumContactTypeFilter<"BusinessPrimaryContact"> | $Enums.ContactType
    isVerified?: BoolFilter<"BusinessPrimaryContact"> | boolean
    isPrimary?: BoolFilter<"BusinessPrimaryContact"> | boolean
    order?: IntNullableFilter<"BusinessPrimaryContact"> | number | null
    verifiedAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    otp?: StringNullableFilter<"BusinessPrimaryContact"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    createdAt?: DateTimeFilter<"BusinessPrimaryContact"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessPrimaryContact"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id" | "value" | "businessId_type_isPrimary">

  export type BusinessPrimaryContactOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BusinessPrimaryContactCountOrderByAggregateInput
    _avg?: BusinessPrimaryContactAvgOrderByAggregateInput
    _max?: BusinessPrimaryContactMaxOrderByAggregateInput
    _min?: BusinessPrimaryContactMinOrderByAggregateInput
    _sum?: BusinessPrimaryContactSumOrderByAggregateInput
  }

  export type BusinessPrimaryContactScalarWhereWithAggregatesInput = {
    AND?: BusinessPrimaryContactScalarWhereWithAggregatesInput | BusinessPrimaryContactScalarWhereWithAggregatesInput[]
    OR?: BusinessPrimaryContactScalarWhereWithAggregatesInput[]
    NOT?: BusinessPrimaryContactScalarWhereWithAggregatesInput | BusinessPrimaryContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessPrimaryContact"> | string
    businessId?: StringWithAggregatesFilter<"BusinessPrimaryContact"> | string
    type?: EnumContactTypeWithAggregatesFilter<"BusinessPrimaryContact"> | $Enums.ContactType
    value?: StringWithAggregatesFilter<"BusinessPrimaryContact"> | string
    isVerified?: BoolWithAggregatesFilter<"BusinessPrimaryContact"> | boolean
    isPrimary?: BoolWithAggregatesFilter<"BusinessPrimaryContact"> | boolean
    order?: IntNullableWithAggregatesFilter<"BusinessPrimaryContact"> | number | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"BusinessPrimaryContact"> | Date | string | null
    otp?: StringNullableWithAggregatesFilter<"BusinessPrimaryContact"> | string | null
    otpExpiresAt?: DateTimeNullableWithAggregatesFilter<"BusinessPrimaryContact"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessPrimaryContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessPrimaryContact"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BusinessPrimaryContact"> | Date | string | null
  }

  export type BusinessAddressWhereInput = {
    AND?: BusinessAddressWhereInput | BusinessAddressWhereInput[]
    OR?: BusinessAddressWhereInput[]
    NOT?: BusinessAddressWhereInput | BusinessAddressWhereInput[]
    id?: StringFilter<"BusinessAddress"> | string
    businessDetailsId?: StringNullableFilter<"BusinessAddress"> | string | null
    createdAt?: DateTimeFilter<"BusinessAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessAddress"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessAddress"> | Date | string
    order?: IntNullableFilter<"BusinessAddress"> | number | null
    street?: StringFilter<"BusinessAddress"> | string
    city?: StringFilter<"BusinessAddress"> | string
    country?: StringFilter<"BusinessAddress"> | string
    pincode?: StringFilter<"BusinessAddress"> | string
    state?: StringFilter<"BusinessAddress"> | string
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }

  export type BusinessAddressOrderByWithRelationInput = {
    id?: SortOrder
    businessDetailsId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    order?: SortOrderInput | SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
    businessDetails?: BusinessDetailsOrderByWithRelationInput
  }

  export type BusinessAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessAddressWhereInput | BusinessAddressWhereInput[]
    OR?: BusinessAddressWhereInput[]
    NOT?: BusinessAddressWhereInput | BusinessAddressWhereInput[]
    businessDetailsId?: StringNullableFilter<"BusinessAddress"> | string | null
    createdAt?: DateTimeFilter<"BusinessAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessAddress"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessAddress"> | Date | string
    order?: IntNullableFilter<"BusinessAddress"> | number | null
    street?: StringFilter<"BusinessAddress"> | string
    city?: StringFilter<"BusinessAddress"> | string
    country?: StringFilter<"BusinessAddress"> | string
    pincode?: StringFilter<"BusinessAddress"> | string
    state?: StringFilter<"BusinessAddress"> | string
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }, "id">

  export type BusinessAddressOrderByWithAggregationInput = {
    id?: SortOrder
    businessDetailsId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    order?: SortOrderInput | SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
    _count?: BusinessAddressCountOrderByAggregateInput
    _avg?: BusinessAddressAvgOrderByAggregateInput
    _max?: BusinessAddressMaxOrderByAggregateInput
    _min?: BusinessAddressMinOrderByAggregateInput
    _sum?: BusinessAddressSumOrderByAggregateInput
  }

  export type BusinessAddressScalarWhereWithAggregatesInput = {
    AND?: BusinessAddressScalarWhereWithAggregatesInput | BusinessAddressScalarWhereWithAggregatesInput[]
    OR?: BusinessAddressScalarWhereWithAggregatesInput[]
    NOT?: BusinessAddressScalarWhereWithAggregatesInput | BusinessAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessAddress"> | string
    businessDetailsId?: StringNullableWithAggregatesFilter<"BusinessAddress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessAddress"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BusinessAddress"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessAddress"> | Date | string
    order?: IntNullableWithAggregatesFilter<"BusinessAddress"> | number | null
    street?: StringWithAggregatesFilter<"BusinessAddress"> | string
    city?: StringWithAggregatesFilter<"BusinessAddress"> | string
    country?: StringWithAggregatesFilter<"BusinessAddress"> | string
    pincode?: StringWithAggregatesFilter<"BusinessAddress"> | string
    state?: StringWithAggregatesFilter<"BusinessAddress"> | string
  }

  export type BusinessDetailsWhereInput = {
    AND?: BusinessDetailsWhereInput | BusinessDetailsWhereInput[]
    OR?: BusinessDetailsWhereInput[]
    NOT?: BusinessDetailsWhereInput | BusinessDetailsWhereInput[]
    id?: StringFilter<"BusinessDetails"> | string
    registrationNumber?: StringNullableFilter<"BusinessDetails"> | string | null
    license?: StringNullableFilter<"BusinessDetails"> | string | null
    experience?: IntNullableFilter<"BusinessDetails"> | number | null
    teamSize?: IntNullableFilter<"BusinessDetails"> | number | null
    description?: StringNullableFilter<"BusinessDetails"> | string | null
    latitude?: FloatNullableFilter<"BusinessDetails"> | number | null
    longitude?: FloatNullableFilter<"BusinessDetails"> | number | null
    degree?: StringNullableListFilter<"BusinessDetails">
    gstNumber?: StringNullableFilter<"BusinessDetails"> | string | null
    categoryId?: StringNullableFilter<"BusinessDetails"> | string | null
    logo?: StringNullableFilter<"BusinessDetails"> | string | null
    createdAt?: DateTimeFilter<"BusinessDetails"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessDetails"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessDetails"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    websites?: BusinessWebsiteListRelationFilter
    images?: BusinessImageListRelationFilter
    language?: LanguageListRelationFilter
    proficiency?: ProficiencyListRelationFilter
    court?: CourtListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tags?: TagListRelationFilter
    addresses?: BusinessAddressListRelationFilter
  }

  export type BusinessDetailsOrderByWithRelationInput = {
    id?: SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    degree?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    websites?: BusinessWebsiteOrderByRelationAggregateInput
    images?: BusinessImageOrderByRelationAggregateInput
    language?: LanguageOrderByRelationAggregateInput
    proficiency?: ProficiencyOrderByRelationAggregateInput
    court?: CourtOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    addresses?: BusinessAddressOrderByRelationAggregateInput
  }

  export type BusinessDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessDetailsWhereInput | BusinessDetailsWhereInput[]
    OR?: BusinessDetailsWhereInput[]
    NOT?: BusinessDetailsWhereInput | BusinessDetailsWhereInput[]
    registrationNumber?: StringNullableFilter<"BusinessDetails"> | string | null
    license?: StringNullableFilter<"BusinessDetails"> | string | null
    experience?: IntNullableFilter<"BusinessDetails"> | number | null
    teamSize?: IntNullableFilter<"BusinessDetails"> | number | null
    description?: StringNullableFilter<"BusinessDetails"> | string | null
    latitude?: FloatNullableFilter<"BusinessDetails"> | number | null
    longitude?: FloatNullableFilter<"BusinessDetails"> | number | null
    degree?: StringNullableListFilter<"BusinessDetails">
    gstNumber?: StringNullableFilter<"BusinessDetails"> | string | null
    categoryId?: StringNullableFilter<"BusinessDetails"> | string | null
    logo?: StringNullableFilter<"BusinessDetails"> | string | null
    createdAt?: DateTimeFilter<"BusinessDetails"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessDetails"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessDetails"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    websites?: BusinessWebsiteListRelationFilter
    images?: BusinessImageListRelationFilter
    language?: LanguageListRelationFilter
    proficiency?: ProficiencyListRelationFilter
    court?: CourtListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tags?: TagListRelationFilter
    addresses?: BusinessAddressListRelationFilter
  }, "id">

  export type BusinessDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    degree?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BusinessDetailsCountOrderByAggregateInput
    _avg?: BusinessDetailsAvgOrderByAggregateInput
    _max?: BusinessDetailsMaxOrderByAggregateInput
    _min?: BusinessDetailsMinOrderByAggregateInput
    _sum?: BusinessDetailsSumOrderByAggregateInput
  }

  export type BusinessDetailsScalarWhereWithAggregatesInput = {
    AND?: BusinessDetailsScalarWhereWithAggregatesInput | BusinessDetailsScalarWhereWithAggregatesInput[]
    OR?: BusinessDetailsScalarWhereWithAggregatesInput[]
    NOT?: BusinessDetailsScalarWhereWithAggregatesInput | BusinessDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessDetails"> | string
    registrationNumber?: StringNullableWithAggregatesFilter<"BusinessDetails"> | string | null
    license?: StringNullableWithAggregatesFilter<"BusinessDetails"> | string | null
    experience?: IntNullableWithAggregatesFilter<"BusinessDetails"> | number | null
    teamSize?: IntNullableWithAggregatesFilter<"BusinessDetails"> | number | null
    description?: StringNullableWithAggregatesFilter<"BusinessDetails"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"BusinessDetails"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"BusinessDetails"> | number | null
    degree?: StringNullableListFilter<"BusinessDetails">
    gstNumber?: StringNullableWithAggregatesFilter<"BusinessDetails"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"BusinessDetails"> | string | null
    logo?: StringNullableWithAggregatesFilter<"BusinessDetails"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessDetails"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BusinessDetails"> | Date | string | null
  }

  export type BusinessSupportingDocumentsWhereInput = {
    AND?: BusinessSupportingDocumentsWhereInput | BusinessSupportingDocumentsWhereInput[]
    OR?: BusinessSupportingDocumentsWhereInput[]
    NOT?: BusinessSupportingDocumentsWhereInput | BusinessSupportingDocumentsWhereInput[]
    id?: StringFilter<"BusinessSupportingDocuments"> | string
    businessId?: StringFilter<"BusinessSupportingDocuments"> | string
    type?: StringFilter<"BusinessSupportingDocuments"> | string
    url?: StringFilter<"BusinessSupportingDocuments"> | string
    createdAt?: DateTimeFilter<"BusinessSupportingDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessSupportingDocuments"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessSupportingDocuments"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type BusinessSupportingDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type BusinessSupportingDocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessSupportingDocumentsWhereInput | BusinessSupportingDocumentsWhereInput[]
    OR?: BusinessSupportingDocumentsWhereInput[]
    NOT?: BusinessSupportingDocumentsWhereInput | BusinessSupportingDocumentsWhereInput[]
    businessId?: StringFilter<"BusinessSupportingDocuments"> | string
    type?: StringFilter<"BusinessSupportingDocuments"> | string
    url?: StringFilter<"BusinessSupportingDocuments"> | string
    createdAt?: DateTimeFilter<"BusinessSupportingDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessSupportingDocuments"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessSupportingDocuments"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id">

  export type BusinessSupportingDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BusinessSupportingDocumentsCountOrderByAggregateInput
    _max?: BusinessSupportingDocumentsMaxOrderByAggregateInput
    _min?: BusinessSupportingDocumentsMinOrderByAggregateInput
  }

  export type BusinessSupportingDocumentsScalarWhereWithAggregatesInput = {
    AND?: BusinessSupportingDocumentsScalarWhereWithAggregatesInput | BusinessSupportingDocumentsScalarWhereWithAggregatesInput[]
    OR?: BusinessSupportingDocumentsScalarWhereWithAggregatesInput[]
    NOT?: BusinessSupportingDocumentsScalarWhereWithAggregatesInput | BusinessSupportingDocumentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessSupportingDocuments"> | string
    businessId?: StringWithAggregatesFilter<"BusinessSupportingDocuments"> | string
    type?: StringWithAggregatesFilter<"BusinessSupportingDocuments"> | string
    url?: StringWithAggregatesFilter<"BusinessSupportingDocuments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessSupportingDocuments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessSupportingDocuments"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BusinessSupportingDocuments"> | Date | string | null
  }

  export type BusinessImageWhereInput = {
    AND?: BusinessImageWhereInput | BusinessImageWhereInput[]
    OR?: BusinessImageWhereInput[]
    NOT?: BusinessImageWhereInput | BusinessImageWhereInput[]
    id?: StringFilter<"BusinessImage"> | string
    url?: StringFilter<"BusinessImage"> | string
    order?: IntNullableFilter<"BusinessImage"> | number | null
    createdAt?: DateTimeFilter<"BusinessImage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessImage"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessImage"> | Date | string
    businessDetailsId?: StringNullableFilter<"BusinessImage"> | string | null
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }

  export type BusinessImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrderInput | SortOrder
    businessDetails?: BusinessDetailsOrderByWithRelationInput
  }

  export type BusinessImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessImageWhereInput | BusinessImageWhereInput[]
    OR?: BusinessImageWhereInput[]
    NOT?: BusinessImageWhereInput | BusinessImageWhereInput[]
    url?: StringFilter<"BusinessImage"> | string
    order?: IntNullableFilter<"BusinessImage"> | number | null
    createdAt?: DateTimeFilter<"BusinessImage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessImage"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessImage"> | Date | string
    businessDetailsId?: StringNullableFilter<"BusinessImage"> | string | null
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }, "id">

  export type BusinessImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrderInput | SortOrder
    _count?: BusinessImageCountOrderByAggregateInput
    _avg?: BusinessImageAvgOrderByAggregateInput
    _max?: BusinessImageMaxOrderByAggregateInput
    _min?: BusinessImageMinOrderByAggregateInput
    _sum?: BusinessImageSumOrderByAggregateInput
  }

  export type BusinessImageScalarWhereWithAggregatesInput = {
    AND?: BusinessImageScalarWhereWithAggregatesInput | BusinessImageScalarWhereWithAggregatesInput[]
    OR?: BusinessImageScalarWhereWithAggregatesInput[]
    NOT?: BusinessImageScalarWhereWithAggregatesInput | BusinessImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessImage"> | string
    url?: StringWithAggregatesFilter<"BusinessImage"> | string
    order?: IntNullableWithAggregatesFilter<"BusinessImage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessImage"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BusinessImage"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessImage"> | Date | string
    businessDetailsId?: StringNullableWithAggregatesFilter<"BusinessImage"> | string | null
  }

  export type BusinessWebsiteWhereInput = {
    AND?: BusinessWebsiteWhereInput | BusinessWebsiteWhereInput[]
    OR?: BusinessWebsiteWhereInput[]
    NOT?: BusinessWebsiteWhereInput | BusinessWebsiteWhereInput[]
    id?: StringFilter<"BusinessWebsite"> | string
    type?: StringFilter<"BusinessWebsite"> | string
    url?: StringFilter<"BusinessWebsite"> | string
    createdAt?: DateTimeFilter<"BusinessWebsite"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessWebsite"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessWebsite"> | Date | string
    businessDetailsId?: StringNullableFilter<"BusinessWebsite"> | string | null
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }

  export type BusinessWebsiteOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrderInput | SortOrder
    businessDetails?: BusinessDetailsOrderByWithRelationInput
  }

  export type BusinessWebsiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessWebsiteWhereInput | BusinessWebsiteWhereInput[]
    OR?: BusinessWebsiteWhereInput[]
    NOT?: BusinessWebsiteWhereInput | BusinessWebsiteWhereInput[]
    type?: StringFilter<"BusinessWebsite"> | string
    url?: StringFilter<"BusinessWebsite"> | string
    createdAt?: DateTimeFilter<"BusinessWebsite"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessWebsite"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessWebsite"> | Date | string
    businessDetailsId?: StringNullableFilter<"BusinessWebsite"> | string | null
    businessDetails?: XOR<BusinessDetailsNullableRelationFilter, BusinessDetailsWhereInput> | null
  }, "id">

  export type BusinessWebsiteOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrderInput | SortOrder
    _count?: BusinessWebsiteCountOrderByAggregateInput
    _max?: BusinessWebsiteMaxOrderByAggregateInput
    _min?: BusinessWebsiteMinOrderByAggregateInput
  }

  export type BusinessWebsiteScalarWhereWithAggregatesInput = {
    AND?: BusinessWebsiteScalarWhereWithAggregatesInput | BusinessWebsiteScalarWhereWithAggregatesInput[]
    OR?: BusinessWebsiteScalarWhereWithAggregatesInput[]
    NOT?: BusinessWebsiteScalarWhereWithAggregatesInput | BusinessWebsiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessWebsite"> | string
    type?: StringWithAggregatesFilter<"BusinessWebsite"> | string
    url?: StringWithAggregatesFilter<"BusinessWebsite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessWebsite"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BusinessWebsite"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessWebsite"> | Date | string
    businessDetailsId?: StringNullableWithAggregatesFilter<"BusinessWebsite"> | string | null
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    slug?: StringNullableFilter<"Language"> | string | null
    createdAt?: DateTimeFilter<"Language"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Language"> | Date | string | null
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    businessDetails?: BusinessDetailsListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessDetails?: BusinessDetailsOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    createdAt?: DateTimeFilter<"Language"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Language"> | Date | string | null
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    businessDetails?: BusinessDetailsListRelationFilter
  }, "id" | "name" | "slug">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
    slug?: StringNullableWithAggregatesFilter<"Language"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Language"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
  }

  export type ProficiencyWhereInput = {
    AND?: ProficiencyWhereInput | ProficiencyWhereInput[]
    OR?: ProficiencyWhereInput[]
    NOT?: ProficiencyWhereInput | ProficiencyWhereInput[]
    id?: StringFilter<"Proficiency"> | string
    name?: StringFilter<"Proficiency"> | string
    slug?: StringNullableFilter<"Proficiency"> | string | null
    createdAt?: DateTimeFilter<"Proficiency"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Proficiency"> | Date | string | null
    updatedAt?: DateTimeFilter<"Proficiency"> | Date | string
    businessDetails?: BusinessDetailsListRelationFilter
  }

  export type ProficiencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessDetails?: BusinessDetailsOrderByRelationAggregateInput
  }

  export type ProficiencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: ProficiencyWhereInput | ProficiencyWhereInput[]
    OR?: ProficiencyWhereInput[]
    NOT?: ProficiencyWhereInput | ProficiencyWhereInput[]
    createdAt?: DateTimeFilter<"Proficiency"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Proficiency"> | Date | string | null
    updatedAt?: DateTimeFilter<"Proficiency"> | Date | string
    businessDetails?: BusinessDetailsListRelationFilter
  }, "id" | "name" | "slug">

  export type ProficiencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: ProficiencyCountOrderByAggregateInput
    _max?: ProficiencyMaxOrderByAggregateInput
    _min?: ProficiencyMinOrderByAggregateInput
  }

  export type ProficiencyScalarWhereWithAggregatesInput = {
    AND?: ProficiencyScalarWhereWithAggregatesInput | ProficiencyScalarWhereWithAggregatesInput[]
    OR?: ProficiencyScalarWhereWithAggregatesInput[]
    NOT?: ProficiencyScalarWhereWithAggregatesInput | ProficiencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proficiency"> | string
    name?: StringWithAggregatesFilter<"Proficiency"> | string
    slug?: StringNullableWithAggregatesFilter<"Proficiency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Proficiency"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Proficiency"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Proficiency"> | Date | string
  }

  export type CourtWhereInput = {
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    id?: StringFilter<"Court"> | string
    name?: StringFilter<"Court"> | string
    slug?: StringNullableFilter<"Court"> | string | null
    createdAt?: DateTimeFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Court"> | Date | string | null
    updatedAt?: DateTimeFilter<"Court"> | Date | string
    businessDetails?: BusinessDetailsListRelationFilter
  }

  export type CourtOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessDetails?: BusinessDetailsOrderByRelationAggregateInput
  }

  export type CourtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    createdAt?: DateTimeFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Court"> | Date | string | null
    updatedAt?: DateTimeFilter<"Court"> | Date | string
    businessDetails?: BusinessDetailsListRelationFilter
  }, "id" | "name" | "slug">

  export type CourtOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: CourtCountOrderByAggregateInput
    _max?: CourtMaxOrderByAggregateInput
    _min?: CourtMinOrderByAggregateInput
  }

  export type CourtScalarWhereWithAggregatesInput = {
    AND?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    OR?: CourtScalarWhereWithAggregatesInput[]
    NOT?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Court"> | string
    name?: StringWithAggregatesFilter<"Court"> | string
    slug?: StringNullableWithAggregatesFilter<"Court"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Court"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Court"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Admin"> | Date | string | null
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    categoryImage?: StringNullableFilter<"Category"> | string | null
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    businessesDetails?: BusinessDetailsListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    categoryImage?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    businessesDetails?: BusinessDetailsOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    categoryImage?: StringNullableFilter<"Category"> | string | null
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    businessesDetails?: BusinessDetailsListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    categoryImage?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    categoryImage?: StringNullableWithAggregatesFilter<"Category"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    BusinessDetails?: BusinessDetailsListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    BusinessDetails?: BusinessDetailsOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    BusinessDetails?: BusinessDetailsListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    businessId?: StringNullableFilter<"Review"> | string | null
    userId?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    businessId?: StringNullableFilter<"Review"> | string | null
    userId?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    businessId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    userId?: StringWithAggregatesFilter<"Review"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    date?: DateTimeFilter<"Booking"> | Date | string
    userId?: StringFilter<"Booking"> | string
    businessId?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    date?: DateTimeFilter<"Booking"> | Date | string
    userId?: StringFilter<"Booking"> | string
    businessId?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    date?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    businessId?: StringWithAggregatesFilter<"Booking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    userId?: StringFilter<"Chat"> | string
    businessId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    Business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
    Message?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Business?: BusinessOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    Message?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_businessId?: ChatUserIdBusinessIdCompoundUniqueInput
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    userId?: StringFilter<"Chat"> | string
    businessId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    Business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
    Message?: MessageListRelationFilter
  }, "id" | "userId_businessId">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    userId?: StringWithAggregatesFilter<"Chat"> | string
    businessId?: StringWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    chatId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    fileType?: StringNullableFilter<"Message"> | string | null
    fileUrl?: StringNullableFilter<"Message"> | string | null
    chats?: XOR<ChatRelationFilter, ChatWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    senderType?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    chats?: ChatOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    chatId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    fileType?: StringNullableFilter<"Message"> | string | null
    fileUrl?: StringNullableFilter<"Message"> | string | null
    chats?: XOR<ChatRelationFilter, ChatWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    senderType?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    senderType?: EnumSenderTypeWithAggregatesFilter<"Message"> | $Enums.SenderType
    chatId?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    fileType?: StringNullableWithAggregatesFilter<"Message"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type PincodeWhereInput = {
    AND?: PincodeWhereInput | PincodeWhereInput[]
    OR?: PincodeWhereInput[]
    NOT?: PincodeWhereInput | PincodeWhereInput[]
    id?: StringFilter<"Pincode"> | string
    code?: StringFilter<"Pincode"> | string
    slug?: StringNullableFilter<"Pincode"> | string | null
    cityId?: StringFilter<"Pincode"> | string
    city?: XOR<CityRelationFilter, CityWhereInput>
  }

  export type PincodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    slug?: SortOrderInput | SortOrder
    cityId?: SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type PincodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    slug?: string
    AND?: PincodeWhereInput | PincodeWhereInput[]
    OR?: PincodeWhereInput[]
    NOT?: PincodeWhereInput | PincodeWhereInput[]
    cityId?: StringFilter<"Pincode"> | string
    city?: XOR<CityRelationFilter, CityWhereInput>
  }, "id" | "code" | "slug">

  export type PincodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    slug?: SortOrderInput | SortOrder
    cityId?: SortOrder
    _count?: PincodeCountOrderByAggregateInput
    _max?: PincodeMaxOrderByAggregateInput
    _min?: PincodeMinOrderByAggregateInput
  }

  export type PincodeScalarWhereWithAggregatesInput = {
    AND?: PincodeScalarWhereWithAggregatesInput | PincodeScalarWhereWithAggregatesInput[]
    OR?: PincodeScalarWhereWithAggregatesInput[]
    NOT?: PincodeScalarWhereWithAggregatesInput | PincodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pincode"> | string
    code?: StringWithAggregatesFilter<"Pincode"> | string
    slug?: StringNullableWithAggregatesFilter<"Pincode"> | string | null
    cityId?: StringWithAggregatesFilter<"Pincode"> | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    slug?: StringNullableFilter<"City"> | string | null
    stateId?: StringFilter<"City"> | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    pincodes?: PincodeListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    stateId?: SortOrder
    state?: StateOrderByWithRelationInput
    pincodes?: PincodeOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    stateId?: StringFilter<"City"> | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    pincodes?: PincodeListRelationFilter
  }, "id" | "slug">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    stateId?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    slug?: StringNullableWithAggregatesFilter<"City"> | string | null
    stateId?: StringWithAggregatesFilter<"City"> | string
  }

  export type StateWhereInput = {
    AND?: StateWhereInput | StateWhereInput[]
    OR?: StateWhereInput[]
    NOT?: StateWhereInput | StateWhereInput[]
    id?: StringFilter<"State"> | string
    name?: StringFilter<"State"> | string
    slug?: StringNullableFilter<"State"> | string | null
    countryId?: StringFilter<"State"> | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    cities?: CityListRelationFilter
  }

  export type StateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    countryId?: SortOrder
    country?: CountryOrderByWithRelationInput
    cities?: CityOrderByRelationAggregateInput
  }

  export type StateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: StateWhereInput | StateWhereInput[]
    OR?: StateWhereInput[]
    NOT?: StateWhereInput | StateWhereInput[]
    name?: StringFilter<"State"> | string
    countryId?: StringFilter<"State"> | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    cities?: CityListRelationFilter
  }, "id" | "slug">

  export type StateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    countryId?: SortOrder
    _count?: StateCountOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: StateScalarWhereWithAggregatesInput | StateScalarWhereWithAggregatesInput[]
    OR?: StateScalarWhereWithAggregatesInput[]
    NOT?: StateScalarWhereWithAggregatesInput | StateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"State"> | string
    name?: StringWithAggregatesFilter<"State"> | string
    slug?: StringNullableWithAggregatesFilter<"State"> | string | null
    countryId?: StringWithAggregatesFilter<"State"> | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    slug?: StringNullableFilter<"Country"> | string | null
    state?: StateListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    state?: StateOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    state?: StateListRelationFilter
  }, "id" | "slug">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    slug?: StringNullableWithAggregatesFilter<"Country"> | string | null
  }

  export type UserSubscriptionCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    features?: UserSubscriptionCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    features?: UserSubscriptionCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type UserSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: UserSubscriptionUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: UserSubscriptionUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    features?: UserSubscriptionCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: UserSubscriptionUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: UserSubscriptionUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactCreateNestedManyWithoutUserInput
    addresses?: UserAddressCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactCreateInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutContactsInput
  }

  export type UserContactUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
  }

  export type UserContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressCreateInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
    user: UserCreateNestedOneWithoutAddressesInput
  }

  export type UserAddressUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type UserAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type UserAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessSubscriptionCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.BusinessType
    price: number
    duration: number
    features?: BusinessSubscriptionCreatefeaturesInput | string[]
    tierLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    businesses?: BusinessCreateNestedManyWithoutSubscriptionInput
  }

  export type BusinessSubscriptionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.BusinessType
    price: number
    duration: number
    features?: BusinessSubscriptionCreatefeaturesInput | string[]
    tierLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type BusinessSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: BusinessSubscriptionUpdatefeaturesInput | string[]
    tierLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businesses?: BusinessUpdateManyWithoutSubscriptionNestedInput
  }

  export type BusinessSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: BusinessSubscriptionUpdatefeaturesInput | string[]
    tierLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businesses?: BusinessUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type BusinessSubscriptionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.BusinessType
    price: number
    duration: number
    features?: BusinessSubscriptionCreatefeaturesInput | string[]
    tierLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: BusinessSubscriptionUpdatefeaturesInput | string[]
    tierLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: BusinessSubscriptionUpdatefeaturesInput | string[]
    tierLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessCreateInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactCreateNestedManyWithoutBusinessInput
    subscription?: BusinessSubscriptionCreateNestedOneWithoutBusinessesInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
    bookings?: BookingCreateNestedManyWithoutBusinessInput
    reviews?: ReviewCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBusinessInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput
    subscription?: BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BusinessPrimaryContactCreateInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutPrimaryContactsInput
  }

  export type BusinessPrimaryContactUncheckedCreateInput = {
    id?: string
    businessId: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessPrimaryContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutPrimaryContactsNestedInput
  }

  export type BusinessPrimaryContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessPrimaryContactCreateManyInput = {
    id?: string
    businessId: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessPrimaryContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessPrimaryContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessAddressCreateInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
    businessDetails?: BusinessDetailsCreateNestedOneWithoutAddressesInput
  }

  export type BusinessAddressUncheckedCreateInput = {
    id?: string
    businessDetailsId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type BusinessAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    businessDetails?: BusinessDetailsUpdateOneWithoutAddressesNestedInput
  }

  export type BusinessAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessAddressCreateManyInput = {
    id?: string
    businessDetailsId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type BusinessAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessDetailsCreateInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUpdateInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsCreateManyInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessDetailsUpdateManyMutationInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessSupportingDocumentsCreateInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessSupportingDocumentsInput
  }

  export type BusinessSupportingDocumentsUncheckedCreateInput = {
    id?: string
    businessId: string
    type: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessSupportingDocumentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessSupportingDocumentsNestedInput
  }

  export type BusinessSupportingDocumentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessSupportingDocumentsCreateManyInput = {
    id?: string
    businessId: string
    type: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessSupportingDocumentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessSupportingDocumentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessImageCreateInput = {
    id?: string
    url: string
    order?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsCreateNestedOneWithoutImagesInput
  }

  export type BusinessImageUncheckedCreateInput = {
    id?: string
    url: string
    order?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetailsId?: string | null
  }

  export type BusinessImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUpdateOneWithoutImagesNestedInput
  }

  export type BusinessImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessImageCreateManyInput = {
    id?: string
    url: string
    order?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetailsId?: string | null
  }

  export type BusinessImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessWebsiteCreateInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsCreateNestedOneWithoutWebsitesInput
  }

  export type BusinessWebsiteUncheckedCreateInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetailsId?: string | null
  }

  export type BusinessWebsiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUpdateOneWithoutWebsitesNestedInput
  }

  export type BusinessWebsiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessWebsiteCreateManyInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetailsId?: string | null
  }

  export type BusinessWebsiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessWebsiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetailsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProficiencyCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsCreateNestedManyWithoutProficiencyInput
  }

  export type ProficiencyUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsUncheckedCreateNestedManyWithoutProficiencyInput
  }

  export type ProficiencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUpdateManyWithoutProficiencyNestedInput
  }

  export type ProficiencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUncheckedUpdateManyWithoutProficiencyNestedInput
  }

  export type ProficiencyCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ProficiencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProficiencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsCreateNestedManyWithoutCourtInput
  }

  export type CourtUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    businessDetails?: BusinessDetailsUncheckedCreateNestedManyWithoutCourtInput
  }

  export type CourtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessDetails?: BusinessDetailsUncheckedUpdateManyWithoutCourtNestedInput
  }

  export type CourtCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type CourtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    categoryImage?: string | null
    updatedAt?: Date | string
    businessesDetails?: BusinessDetailsCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    categoryImage?: string | null
    updatedAt?: Date | string
    businessesDetails?: BusinessDetailsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryImage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessesDetails?: BusinessDetailsUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryImage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessesDetails?: BusinessDetailsUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    categoryImage?: string | null
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryImage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryImage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    BusinessDetails?: BusinessDetailsCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    BusinessDetails?: BusinessDetailsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BusinessDetails?: BusinessDetailsUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BusinessDetails?: BusinessDetailsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    business?: BusinessCreateNestedOneWithoutReviewsInput
    user?: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    businessId?: string | null
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutReviewsNestedInput
    user?: UserUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    rating: number
    comment?: string | null
    businessId?: string | null
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    date: Date | string
    userId: string
    businessId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: string
    date: Date | string
    userId: string
    businessId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    Business: BusinessCreateNestedOneWithoutChatsInput
    User: UserCreateNestedOneWithoutChatsInput
    Message?: MessageCreateNestedManyWithoutChatsInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    userId: string
    businessId: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    Message?: MessageUncheckedCreateNestedManyWithoutChatsInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Business?: BusinessUpdateOneRequiredWithoutChatsNestedInput
    User?: UserUpdateOneRequiredWithoutChatsNestedInput
    Message?: MessageUpdateManyWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Message?: MessageUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    userId: string
    businessId: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    senderType: $Enums.SenderType
    createdAt?: Date | string
    readAt?: Date | string | null
    fileType?: string | null
    fileUrl?: string | null
    chats: ChatCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    senderType: $Enums.SenderType
    chatId: string
    createdAt?: Date | string
    readAt?: Date | string | null
    fileType?: string | null
    fileUrl?: string | null
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: ChatUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    senderType: $Enums.SenderType
    chatId: string
    createdAt?: Date | string
    readAt?: Date | string | null
    fileType?: string | null
    fileUrl?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PincodeCreateInput = {
    id?: string
    code: string
    slug?: string | null
    city: CityCreateNestedOneWithoutPincodesInput
  }

  export type PincodeUncheckedCreateInput = {
    id?: string
    code: string
    slug?: string | null
    cityId: string
  }

  export type PincodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    city?: CityUpdateOneRequiredWithoutPincodesNestedInput
  }

  export type PincodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
  }

  export type PincodeCreateManyInput = {
    id?: string
    code: string
    slug?: string | null
    cityId: string
  }

  export type PincodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PincodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    slug?: string | null
    state: StateCreateNestedOneWithoutCitiesInput
    pincodes?: PincodeCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    stateId: string
    pincodes?: PincodeUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    pincodes?: PincodeUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    pincodes?: PincodeUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    stateId: string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
  }

  export type StateCreateInput = {
    id?: string
    name: string
    slug?: string | null
    country: CountryCreateNestedOneWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    countryId: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    countryId: string
  }

  export type StateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    slug?: string | null
    state?: StateCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    state?: StateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StateUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserContactListRelationFilter = {
    every?: UserContactWhereInput
    some?: UserContactWhereInput
    none?: UserContactWhereInput
  }

  export type UserAddressListRelationFilter = {
    every?: UserAddressWhereInput
    some?: UserAddressWhereInput
    none?: UserAddressWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type UserSubscriptionNullableRelationFilter = {
    is?: UserSubscriptionWhereInput | null
    isNot?: UserSubscriptionWhereInput | null
  }

  export type UserContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    hideDetails?: SortOrder
    avatar?: SortOrder
    subscriptionId?: SortOrder
    subscriptionExpire?: SortOrder
    paymentVerification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    hideDetails?: SortOrder
    avatar?: SortOrder
    subscriptionId?: SortOrder
    subscriptionExpire?: SortOrder
    paymentVerification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    hideDetails?: SortOrder
    avatar?: SortOrder
    subscriptionId?: SortOrder
    subscriptionExpire?: SortOrder
    paymentVerification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserContactUserIdTypeIsPrimaryCompoundUniqueInput = {
    userId: string
    type: $Enums.ContactType
    isPrimary: boolean
  }

  export type UserContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrder
    verifiedAt?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserContactAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type UserContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrder
    verifiedAt?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrder
    verifiedAt?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserContactSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    order?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
  }

  export type UserAddressAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    order?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    order?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
  }

  export type UserAddressSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumBusinessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeFilter<$PrismaModel> | $Enums.BusinessType
  }

  export type BusinessListRelationFilter = {
    every?: BusinessWhereInput
    some?: BusinessWhereInput
    none?: BusinessWhereInput
  }

  export type BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    tierLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessSubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
    tierLevel?: SortOrder
  }

  export type BusinessSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    tierLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    tierLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessSubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
    tierLevel?: SortOrder
  }

  export type EnumBusinessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel> | $Enums.BusinessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessTypeFilter<$PrismaModel>
    _max?: NestedEnumBusinessTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BusinessPrimaryContactListRelationFilter = {
    every?: BusinessPrimaryContactWhereInput
    some?: BusinessPrimaryContactWhereInput
    none?: BusinessPrimaryContactWhereInput
  }

  export type BusinessSubscriptionNullableRelationFilter = {
    is?: BusinessSubscriptionWhereInput | null
    isNot?: BusinessSubscriptionWhereInput | null
  }

  export type BusinessSupportingDocumentsListRelationFilter = {
    every?: BusinessSupportingDocumentsWhereInput
    some?: BusinessSupportingDocumentsWhereInput
    none?: BusinessSupportingDocumentsWhereInput
  }

  export type BusinessDetailsNullableRelationFilter = {
    is?: BusinessDetailsWhereInput | null
    isNot?: BusinessDetailsWhereInput | null
  }

  export type BusinessPrimaryContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessSupportingDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    additionalContacts?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    isBusinessVerified?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    subscriptionExpire?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    isListed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    paymentVerification?: SortOrder
    price?: SortOrder
  }

  export type BusinessAvgOrderByAggregateInput = {
    averageRating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    isBusinessVerified?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    subscriptionExpire?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    isListed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    paymentVerification?: SortOrder
    price?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    isBusinessVerified?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    subscriptionExpire?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    isListed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    paymentVerification?: SortOrder
    price?: SortOrder
  }

  export type BusinessSumOrderByAggregateInput = {
    averageRating?: SortOrder
    reviewCount?: SortOrder
    price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BusinessRelationFilter = {
    is?: BusinessWhereInput
    isNot?: BusinessWhereInput
  }

  export type BusinessPrimaryContactBusinessIdTypeIsPrimaryCompoundUniqueInput = {
    businessId: string
    type: $Enums.ContactType
    isPrimary: boolean
  }

  export type BusinessPrimaryContactCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrder
    verifiedAt?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessPrimaryContactAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BusinessPrimaryContactMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrder
    verifiedAt?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessPrimaryContactMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isVerified?: SortOrder
    isPrimary?: SortOrder
    order?: SortOrder
    verifiedAt?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessPrimaryContactSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BusinessAddressCountOrderByAggregateInput = {
    id?: SortOrder
    businessDetailsId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    order?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
  }

  export type BusinessAddressAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BusinessAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    businessDetailsId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    order?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
  }

  export type BusinessAddressMinOrderByAggregateInput = {
    id?: SortOrder
    businessDetailsId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    order?: SortOrder
    street?: SortOrder
    city?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    state?: SortOrder
  }

  export type BusinessAddressSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BusinessWebsiteListRelationFilter = {
    every?: BusinessWebsiteWhereInput
    some?: BusinessWebsiteWhereInput
    none?: BusinessWebsiteWhereInput
  }

  export type BusinessImageListRelationFilter = {
    every?: BusinessImageWhereInput
    some?: BusinessImageWhereInput
    none?: BusinessImageWhereInput
  }

  export type LanguageListRelationFilter = {
    every?: LanguageWhereInput
    some?: LanguageWhereInput
    none?: LanguageWhereInput
  }

  export type ProficiencyListRelationFilter = {
    every?: ProficiencyWhereInput
    some?: ProficiencyWhereInput
    none?: ProficiencyWhereInput
  }

  export type CourtListRelationFilter = {
    every?: CourtWhereInput
    some?: CourtWhereInput
    none?: CourtWhereInput
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type BusinessAddressListRelationFilter = {
    every?: BusinessAddressWhereInput
    some?: BusinessAddressWhereInput
    none?: BusinessAddressWhereInput
  }

  export type BusinessWebsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProficiencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    registrationNumber?: SortOrder
    license?: SortOrder
    experience?: SortOrder
    teamSize?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    degree?: SortOrder
    gstNumber?: SortOrder
    categoryId?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessDetailsAvgOrderByAggregateInput = {
    experience?: SortOrder
    teamSize?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BusinessDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    registrationNumber?: SortOrder
    license?: SortOrder
    experience?: SortOrder
    teamSize?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gstNumber?: SortOrder
    categoryId?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    registrationNumber?: SortOrder
    license?: SortOrder
    experience?: SortOrder
    teamSize?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gstNumber?: SortOrder
    categoryId?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessDetailsSumOrderByAggregateInput = {
    experience?: SortOrder
    teamSize?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BusinessSupportingDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessSupportingDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessSupportingDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BusinessImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrder
  }

  export type BusinessImageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BusinessImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrder
  }

  export type BusinessImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrder
  }

  export type BusinessImageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BusinessWebsiteCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrder
  }

  export type BusinessWebsiteMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrder
  }

  export type BusinessWebsiteMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
    businessDetailsId?: SortOrder
  }

  export type BusinessDetailsListRelationFilter = {
    every?: BusinessDetailsWhereInput
    some?: BusinessDetailsWhereInput
    none?: BusinessDetailsWhereInput
  }

  export type BusinessDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProficiencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProficiencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProficiencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    categoryImage?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    categoryImage?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    categoryImage?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessNullableRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    businessId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    businessId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    businessId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatUserIdBusinessIdCompoundUniqueInput = {
    userId: string
    businessId: string
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderType?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    fileType?: SortOrder
    fileUrl?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderType?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    fileType?: SortOrder
    fileUrl?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderType?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    fileType?: SortOrder
    fileUrl?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type PincodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    slug?: SortOrder
    cityId?: SortOrder
  }

  export type PincodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    slug?: SortOrder
    cityId?: SortOrder
  }

  export type PincodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    slug?: SortOrder
    cityId?: SortOrder
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type PincodeListRelationFilter = {
    every?: PincodeWhereInput
    some?: PincodeWhereInput
    none?: PincodeWhereInput
  }

  export type PincodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    stateId?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    stateId?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    stateId?: SortOrder
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    countryId?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    countryId?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    countryId?: SortOrder
  }

  export type StateListRelationFilter = {
    every?: StateWhereInput
    some?: StateWhereInput
    none?: StateWhereInput
  }

  export type StateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type UserSubscriptionCreatefeaturesInput = {
    set: string[]
  }

  export type UserCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput> | UserCreateWithoutSubscriptionInput[] | UserUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput | UserCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UserCreateManySubscriptionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput> | UserCreateWithoutSubscriptionInput[] | UserUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput | UserCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UserCreateManySubscriptionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserSubscriptionUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput> | UserCreateWithoutSubscriptionInput[] | UserUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput | UserCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubscriptionInput | UserUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UserCreateManySubscriptionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubscriptionInput | UserUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubscriptionInput | UserUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput> | UserCreateWithoutSubscriptionInput[] | UserUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput | UserCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubscriptionInput | UserUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UserCreateManySubscriptionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubscriptionInput | UserUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubscriptionInput | UserUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserContactCreateNestedManyWithoutUserInput = {
    create?: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput> | UserContactCreateWithoutUserInput[] | UserContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutUserInput | UserContactCreateOrConnectWithoutUserInput[]
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
  }

  export type UserAddressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserSubscriptionCreateNestedOneWithoutUsersInput = {
    create?: XOR<UserSubscriptionCreateWithoutUsersInput, UserSubscriptionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUsersInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type UserContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput> | UserContactCreateWithoutUserInput[] | UserContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutUserInput | UserContactCreateOrConnectWithoutUserInput[]
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
  }

  export type UserAddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput> | UserContactCreateWithoutUserInput[] | UserContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutUserInput | UserContactCreateOrConnectWithoutUserInput[]
    upsert?: UserContactUpsertWithWhereUniqueWithoutUserInput | UserContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserContactCreateManyUserInputEnvelope
    set?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    disconnect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    delete?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    update?: UserContactUpdateWithWhereUniqueWithoutUserInput | UserContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserContactUpdateManyWithWhereWithoutUserInput | UserContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
  }

  export type UserAddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUserInput | UserAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUserInput | UserAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUserInput | UserAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserSubscriptionUpdateOneWithoutUsersNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUsersInput, UserSubscriptionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUsersInput
    upsert?: UserSubscriptionUpsertWithoutUsersInput
    disconnect?: UserSubscriptionWhereInput | boolean
    delete?: UserSubscriptionWhereInput | boolean
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUsersInput, UserSubscriptionUpdateWithoutUsersInput>, UserSubscriptionUncheckedUpdateWithoutUsersInput>
  }

  export type UserContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput> | UserContactCreateWithoutUserInput[] | UserContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserContactCreateOrConnectWithoutUserInput | UserContactCreateOrConnectWithoutUserInput[]
    upsert?: UserContactUpsertWithWhereUniqueWithoutUserInput | UserContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserContactCreateManyUserInputEnvelope
    set?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    disconnect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    delete?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    connect?: UserContactWhereUniqueInput | UserContactWhereUniqueInput[]
    update?: UserContactUpdateWithWhereUniqueWithoutUserInput | UserContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserContactUpdateManyWithWhereWithoutUserInput | UserContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
  }

  export type UserAddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUserInput | UserAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUserInput | UserAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUserInput | UserAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type BusinessSubscriptionCreatefeaturesInput = {
    set: string[]
  }

  export type BusinessCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type EnumBusinessTypeFieldUpdateOperationsInput = {
    set?: $Enums.BusinessType
  }

  export type BusinessSubscriptionUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BusinessUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutSubscriptionInput | BusinessUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutSubscriptionInput | BusinessUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutSubscriptionInput | BusinessUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput> | BusinessCreateWithoutSubscriptionInput[] | BusinessUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionInput | BusinessCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutSubscriptionInput | BusinessUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BusinessCreateManySubscriptionInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutSubscriptionInput | BusinessUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutSubscriptionInput | BusinessUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type BusinessCreateadditionalContactsInput = {
    set: string[]
  }

  export type BusinessPrimaryContactCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessPrimaryContactCreateWithoutBusinessInput, BusinessPrimaryContactUncheckedCreateWithoutBusinessInput> | BusinessPrimaryContactCreateWithoutBusinessInput[] | BusinessPrimaryContactUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessPrimaryContactCreateOrConnectWithoutBusinessInput | BusinessPrimaryContactCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessPrimaryContactCreateManyBusinessInputEnvelope
    connect?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
  }

  export type BusinessSubscriptionCreateNestedOneWithoutBusinessesInput = {
    create?: XOR<BusinessSubscriptionCreateWithoutBusinessesInput, BusinessSubscriptionUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: BusinessSubscriptionCreateOrConnectWithoutBusinessesInput
    connect?: BusinessSubscriptionWhereUniqueInput
  }

  export type ChatCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BookingCreateWithoutBusinessInput, BookingUncheckedCreateWithoutBusinessInput> | BookingCreateWithoutBusinessInput[] | BookingUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBusinessInput | BookingCreateOrConnectWithoutBusinessInput[]
    createMany?: BookingCreateManyBusinessInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ReviewCreateWithoutBusinessInput, ReviewUncheckedCreateWithoutBusinessInput> | ReviewCreateWithoutBusinessInput[] | ReviewUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBusinessInput | ReviewCreateOrConnectWithoutBusinessInput[]
    createMany?: ReviewCreateManyBusinessInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessSupportingDocumentsCreateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput> | BusinessSupportingDocumentsCreateWithoutBusinessInput[] | BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput | BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessSupportingDocumentsCreateManyBusinessInputEnvelope
    connect?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
  }

  export type BusinessDetailsCreateNestedOneWithoutBusinessInput = {
    create?: XOR<BusinessDetailsCreateWithoutBusinessInput, BusinessDetailsUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutBusinessInput
    connect?: BusinessDetailsWhereUniqueInput
  }

  export type BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessPrimaryContactCreateWithoutBusinessInput, BusinessPrimaryContactUncheckedCreateWithoutBusinessInput> | BusinessPrimaryContactCreateWithoutBusinessInput[] | BusinessPrimaryContactUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessPrimaryContactCreateOrConnectWithoutBusinessInput | BusinessPrimaryContactCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessPrimaryContactCreateManyBusinessInputEnvelope
    connect?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BookingCreateWithoutBusinessInput, BookingUncheckedCreateWithoutBusinessInput> | BookingCreateWithoutBusinessInput[] | BookingUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBusinessInput | BookingCreateOrConnectWithoutBusinessInput[]
    createMany?: BookingCreateManyBusinessInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ReviewCreateWithoutBusinessInput, ReviewUncheckedCreateWithoutBusinessInput> | ReviewCreateWithoutBusinessInput[] | ReviewUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBusinessInput | ReviewCreateOrConnectWithoutBusinessInput[]
    createMany?: ReviewCreateManyBusinessInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessSupportingDocumentsCreateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput> | BusinessSupportingDocumentsCreateWithoutBusinessInput[] | BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput | BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessSupportingDocumentsCreateManyBusinessInputEnvelope
    connect?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
  }

  export type BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput = {
    create?: XOR<BusinessDetailsCreateWithoutBusinessInput, BusinessDetailsUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutBusinessInput
    connect?: BusinessDetailsWhereUniqueInput
  }

  export type BusinessUpdateadditionalContactsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessPrimaryContactCreateWithoutBusinessInput, BusinessPrimaryContactUncheckedCreateWithoutBusinessInput> | BusinessPrimaryContactCreateWithoutBusinessInput[] | BusinessPrimaryContactUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessPrimaryContactCreateOrConnectWithoutBusinessInput | BusinessPrimaryContactCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessPrimaryContactUpsertWithWhereUniqueWithoutBusinessInput | BusinessPrimaryContactUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessPrimaryContactCreateManyBusinessInputEnvelope
    set?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    disconnect?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    delete?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    connect?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    update?: BusinessPrimaryContactUpdateWithWhereUniqueWithoutBusinessInput | BusinessPrimaryContactUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessPrimaryContactUpdateManyWithWhereWithoutBusinessInput | BusinessPrimaryContactUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessPrimaryContactScalarWhereInput | BusinessPrimaryContactScalarWhereInput[]
  }

  export type BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput = {
    create?: XOR<BusinessSubscriptionCreateWithoutBusinessesInput, BusinessSubscriptionUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: BusinessSubscriptionCreateOrConnectWithoutBusinessesInput
    upsert?: BusinessSubscriptionUpsertWithoutBusinessesInput
    disconnect?: BusinessSubscriptionWhereInput | boolean
    delete?: BusinessSubscriptionWhereInput | boolean
    connect?: BusinessSubscriptionWhereUniqueInput
    update?: XOR<XOR<BusinessSubscriptionUpdateToOneWithWhereWithoutBusinessesInput, BusinessSubscriptionUpdateWithoutBusinessesInput>, BusinessSubscriptionUncheckedUpdateWithoutBusinessesInput>
  }

  export type ChatUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutBusinessInput | ChatUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutBusinessInput | ChatUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutBusinessInput | ChatUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BookingCreateWithoutBusinessInput, BookingUncheckedCreateWithoutBusinessInput> | BookingCreateWithoutBusinessInput[] | BookingUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBusinessInput | BookingCreateOrConnectWithoutBusinessInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBusinessInput | BookingUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BookingCreateManyBusinessInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBusinessInput | BookingUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBusinessInput | BookingUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ReviewCreateWithoutBusinessInput, ReviewUncheckedCreateWithoutBusinessInput> | ReviewCreateWithoutBusinessInput[] | ReviewUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBusinessInput | ReviewCreateOrConnectWithoutBusinessInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBusinessInput | ReviewUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ReviewCreateManyBusinessInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBusinessInput | ReviewUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBusinessInput | ReviewUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessSupportingDocumentsCreateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput> | BusinessSupportingDocumentsCreateWithoutBusinessInput[] | BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput | BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessSupportingDocumentsUpsertWithWhereUniqueWithoutBusinessInput | BusinessSupportingDocumentsUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessSupportingDocumentsCreateManyBusinessInputEnvelope
    set?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    disconnect?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    delete?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    connect?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    update?: BusinessSupportingDocumentsUpdateWithWhereUniqueWithoutBusinessInput | BusinessSupportingDocumentsUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessSupportingDocumentsUpdateManyWithWhereWithoutBusinessInput | BusinessSupportingDocumentsUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessSupportingDocumentsScalarWhereInput | BusinessSupportingDocumentsScalarWhereInput[]
  }

  export type BusinessDetailsUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutBusinessInput, BusinessDetailsUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutBusinessInput
    upsert?: BusinessDetailsUpsertWithoutBusinessInput
    disconnect?: BusinessDetailsWhereInput | boolean
    delete?: BusinessDetailsWhereInput | boolean
    connect?: BusinessDetailsWhereUniqueInput
    update?: XOR<XOR<BusinessDetailsUpdateToOneWithWhereWithoutBusinessInput, BusinessDetailsUpdateWithoutBusinessInput>, BusinessDetailsUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessPrimaryContactCreateWithoutBusinessInput, BusinessPrimaryContactUncheckedCreateWithoutBusinessInput> | BusinessPrimaryContactCreateWithoutBusinessInput[] | BusinessPrimaryContactUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessPrimaryContactCreateOrConnectWithoutBusinessInput | BusinessPrimaryContactCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessPrimaryContactUpsertWithWhereUniqueWithoutBusinessInput | BusinessPrimaryContactUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessPrimaryContactCreateManyBusinessInputEnvelope
    set?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    disconnect?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    delete?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    connect?: BusinessPrimaryContactWhereUniqueInput | BusinessPrimaryContactWhereUniqueInput[]
    update?: BusinessPrimaryContactUpdateWithWhereUniqueWithoutBusinessInput | BusinessPrimaryContactUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessPrimaryContactUpdateManyWithWhereWithoutBusinessInput | BusinessPrimaryContactUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessPrimaryContactScalarWhereInput | BusinessPrimaryContactScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutBusinessInput | ChatUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutBusinessInput | ChatUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutBusinessInput | ChatUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BookingCreateWithoutBusinessInput, BookingUncheckedCreateWithoutBusinessInput> | BookingCreateWithoutBusinessInput[] | BookingUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBusinessInput | BookingCreateOrConnectWithoutBusinessInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBusinessInput | BookingUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BookingCreateManyBusinessInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBusinessInput | BookingUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBusinessInput | BookingUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ReviewCreateWithoutBusinessInput, ReviewUncheckedCreateWithoutBusinessInput> | ReviewCreateWithoutBusinessInput[] | ReviewUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBusinessInput | ReviewCreateOrConnectWithoutBusinessInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBusinessInput | ReviewUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ReviewCreateManyBusinessInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBusinessInput | ReviewUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBusinessInput | ReviewUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessSupportingDocumentsCreateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput> | BusinessSupportingDocumentsCreateWithoutBusinessInput[] | BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput | BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessSupportingDocumentsUpsertWithWhereUniqueWithoutBusinessInput | BusinessSupportingDocumentsUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessSupportingDocumentsCreateManyBusinessInputEnvelope
    set?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    disconnect?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    delete?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    connect?: BusinessSupportingDocumentsWhereUniqueInput | BusinessSupportingDocumentsWhereUniqueInput[]
    update?: BusinessSupportingDocumentsUpdateWithWhereUniqueWithoutBusinessInput | BusinessSupportingDocumentsUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessSupportingDocumentsUpdateManyWithWhereWithoutBusinessInput | BusinessSupportingDocumentsUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessSupportingDocumentsScalarWhereInput | BusinessSupportingDocumentsScalarWhereInput[]
  }

  export type BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutBusinessInput, BusinessDetailsUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutBusinessInput
    upsert?: BusinessDetailsUpsertWithoutBusinessInput
    disconnect?: BusinessDetailsWhereInput | boolean
    delete?: BusinessDetailsWhereInput | boolean
    connect?: BusinessDetailsWhereUniqueInput
    update?: XOR<XOR<BusinessDetailsUpdateToOneWithWhereWithoutBusinessInput, BusinessDetailsUpdateWithoutBusinessInput>, BusinessDetailsUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessCreateNestedOneWithoutPrimaryContactsInput = {
    create?: XOR<BusinessCreateWithoutPrimaryContactsInput, BusinessUncheckedCreateWithoutPrimaryContactsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPrimaryContactsInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutPrimaryContactsNestedInput = {
    create?: XOR<BusinessCreateWithoutPrimaryContactsInput, BusinessUncheckedCreateWithoutPrimaryContactsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPrimaryContactsInput
    upsert?: BusinessUpsertWithoutPrimaryContactsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutPrimaryContactsInput, BusinessUpdateWithoutPrimaryContactsInput>, BusinessUncheckedUpdateWithoutPrimaryContactsInput>
  }

  export type BusinessDetailsCreateNestedOneWithoutAddressesInput = {
    create?: XOR<BusinessDetailsCreateWithoutAddressesInput, BusinessDetailsUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutAddressesInput
    connect?: BusinessDetailsWhereUniqueInput
  }

  export type BusinessDetailsUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutAddressesInput, BusinessDetailsUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutAddressesInput
    upsert?: BusinessDetailsUpsertWithoutAddressesInput
    disconnect?: BusinessDetailsWhereInput | boolean
    delete?: BusinessDetailsWhereInput | boolean
    connect?: BusinessDetailsWhereUniqueInput
    update?: XOR<XOR<BusinessDetailsUpdateToOneWithWhereWithoutAddressesInput, BusinessDetailsUpdateWithoutAddressesInput>, BusinessDetailsUncheckedUpdateWithoutAddressesInput>
  }

  export type BusinessDetailsCreatedegreeInput = {
    set: string[]
  }

  export type BusinessCreateNestedOneWithoutBusinessDetailsInput = {
    create?: XOR<BusinessCreateWithoutBusinessDetailsInput, BusinessUncheckedCreateWithoutBusinessDetailsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBusinessDetailsInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<BusinessWebsiteCreateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput> | BusinessWebsiteCreateWithoutBusinessDetailsInput[] | BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput | BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput[]
    createMany?: BusinessWebsiteCreateManyBusinessDetailsInputEnvelope
    connect?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
  }

  export type BusinessImageCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<BusinessImageCreateWithoutBusinessDetailsInput, BusinessImageUncheckedCreateWithoutBusinessDetailsInput> | BusinessImageCreateWithoutBusinessDetailsInput[] | BusinessImageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessImageCreateOrConnectWithoutBusinessDetailsInput | BusinessImageCreateOrConnectWithoutBusinessDetailsInput[]
    createMany?: BusinessImageCreateManyBusinessDetailsInputEnvelope
    connect?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
  }

  export type LanguageCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<LanguageCreateWithoutBusinessDetailsInput, LanguageUncheckedCreateWithoutBusinessDetailsInput> | LanguageCreateWithoutBusinessDetailsInput[] | LanguageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutBusinessDetailsInput | LanguageCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type ProficiencyCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<ProficiencyCreateWithoutBusinessDetailsInput, ProficiencyUncheckedCreateWithoutBusinessDetailsInput> | ProficiencyCreateWithoutBusinessDetailsInput[] | ProficiencyUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: ProficiencyCreateOrConnectWithoutBusinessDetailsInput | ProficiencyCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
  }

  export type CourtCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<CourtCreateWithoutBusinessDetailsInput, CourtUncheckedCreateWithoutBusinessDetailsInput> | CourtCreateWithoutBusinessDetailsInput[] | CourtUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutBusinessDetailsInput | CourtCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutBusinessesDetailsInput = {
    create?: XOR<CategoryCreateWithoutBusinessesDetailsInput, CategoryUncheckedCreateWithoutBusinessesDetailsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBusinessesDetailsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<TagCreateWithoutBusinessDetailsInput, TagUncheckedCreateWithoutBusinessDetailsInput> | TagCreateWithoutBusinessDetailsInput[] | TagUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBusinessDetailsInput | TagCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type BusinessAddressCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<BusinessAddressCreateWithoutBusinessDetailsInput, BusinessAddressUncheckedCreateWithoutBusinessDetailsInput> | BusinessAddressCreateWithoutBusinessDetailsInput[] | BusinessAddressUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessAddressCreateOrConnectWithoutBusinessDetailsInput | BusinessAddressCreateOrConnectWithoutBusinessDetailsInput[]
    createMany?: BusinessAddressCreateManyBusinessDetailsInputEnvelope
    connect?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
  }

  export type BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<BusinessWebsiteCreateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput> | BusinessWebsiteCreateWithoutBusinessDetailsInput[] | BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput | BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput[]
    createMany?: BusinessWebsiteCreateManyBusinessDetailsInputEnvelope
    connect?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
  }

  export type BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<BusinessImageCreateWithoutBusinessDetailsInput, BusinessImageUncheckedCreateWithoutBusinessDetailsInput> | BusinessImageCreateWithoutBusinessDetailsInput[] | BusinessImageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessImageCreateOrConnectWithoutBusinessDetailsInput | BusinessImageCreateOrConnectWithoutBusinessDetailsInput[]
    createMany?: BusinessImageCreateManyBusinessDetailsInputEnvelope
    connect?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
  }

  export type LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<LanguageCreateWithoutBusinessDetailsInput, LanguageUncheckedCreateWithoutBusinessDetailsInput> | LanguageCreateWithoutBusinessDetailsInput[] | LanguageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutBusinessDetailsInput | LanguageCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<ProficiencyCreateWithoutBusinessDetailsInput, ProficiencyUncheckedCreateWithoutBusinessDetailsInput> | ProficiencyCreateWithoutBusinessDetailsInput[] | ProficiencyUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: ProficiencyCreateOrConnectWithoutBusinessDetailsInput | ProficiencyCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
  }

  export type CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<CourtCreateWithoutBusinessDetailsInput, CourtUncheckedCreateWithoutBusinessDetailsInput> | CourtCreateWithoutBusinessDetailsInput[] | CourtUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutBusinessDetailsInput | CourtCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<TagCreateWithoutBusinessDetailsInput, TagUncheckedCreateWithoutBusinessDetailsInput> | TagCreateWithoutBusinessDetailsInput[] | TagUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBusinessDetailsInput | TagCreateOrConnectWithoutBusinessDetailsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput = {
    create?: XOR<BusinessAddressCreateWithoutBusinessDetailsInput, BusinessAddressUncheckedCreateWithoutBusinessDetailsInput> | BusinessAddressCreateWithoutBusinessDetailsInput[] | BusinessAddressUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessAddressCreateOrConnectWithoutBusinessDetailsInput | BusinessAddressCreateOrConnectWithoutBusinessDetailsInput[]
    createMany?: BusinessAddressCreateManyBusinessDetailsInputEnvelope
    connect?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
  }

  export type BusinessDetailsUpdatedegreeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput = {
    create?: XOR<BusinessCreateWithoutBusinessDetailsInput, BusinessUncheckedCreateWithoutBusinessDetailsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBusinessDetailsInput
    upsert?: BusinessUpsertWithoutBusinessDetailsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutBusinessDetailsInput, BusinessUpdateWithoutBusinessDetailsInput>, BusinessUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<BusinessWebsiteCreateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput> | BusinessWebsiteCreateWithoutBusinessDetailsInput[] | BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput | BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: BusinessWebsiteUpsertWithWhereUniqueWithoutBusinessDetailsInput | BusinessWebsiteUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    createMany?: BusinessWebsiteCreateManyBusinessDetailsInputEnvelope
    set?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    disconnect?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    delete?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    connect?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    update?: BusinessWebsiteUpdateWithWhereUniqueWithoutBusinessDetailsInput | BusinessWebsiteUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: BusinessWebsiteUpdateManyWithWhereWithoutBusinessDetailsInput | BusinessWebsiteUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: BusinessWebsiteScalarWhereInput | BusinessWebsiteScalarWhereInput[]
  }

  export type BusinessImageUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<BusinessImageCreateWithoutBusinessDetailsInput, BusinessImageUncheckedCreateWithoutBusinessDetailsInput> | BusinessImageCreateWithoutBusinessDetailsInput[] | BusinessImageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessImageCreateOrConnectWithoutBusinessDetailsInput | BusinessImageCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: BusinessImageUpsertWithWhereUniqueWithoutBusinessDetailsInput | BusinessImageUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    createMany?: BusinessImageCreateManyBusinessDetailsInputEnvelope
    set?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    disconnect?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    delete?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    connect?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    update?: BusinessImageUpdateWithWhereUniqueWithoutBusinessDetailsInput | BusinessImageUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: BusinessImageUpdateManyWithWhereWithoutBusinessDetailsInput | BusinessImageUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: BusinessImageScalarWhereInput | BusinessImageScalarWhereInput[]
  }

  export type LanguageUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<LanguageCreateWithoutBusinessDetailsInput, LanguageUncheckedCreateWithoutBusinessDetailsInput> | LanguageCreateWithoutBusinessDetailsInput[] | LanguageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutBusinessDetailsInput | LanguageCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutBusinessDetailsInput | LanguageUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutBusinessDetailsInput | LanguageUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutBusinessDetailsInput | LanguageUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type ProficiencyUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<ProficiencyCreateWithoutBusinessDetailsInput, ProficiencyUncheckedCreateWithoutBusinessDetailsInput> | ProficiencyCreateWithoutBusinessDetailsInput[] | ProficiencyUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: ProficiencyCreateOrConnectWithoutBusinessDetailsInput | ProficiencyCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: ProficiencyUpsertWithWhereUniqueWithoutBusinessDetailsInput | ProficiencyUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    disconnect?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    delete?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    connect?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    update?: ProficiencyUpdateWithWhereUniqueWithoutBusinessDetailsInput | ProficiencyUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: ProficiencyUpdateManyWithWhereWithoutBusinessDetailsInput | ProficiencyUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: ProficiencyScalarWhereInput | ProficiencyScalarWhereInput[]
  }

  export type CourtUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<CourtCreateWithoutBusinessDetailsInput, CourtUncheckedCreateWithoutBusinessDetailsInput> | CourtCreateWithoutBusinessDetailsInput[] | CourtUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutBusinessDetailsInput | CourtCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutBusinessDetailsInput | CourtUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutBusinessDetailsInput | CourtUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutBusinessDetailsInput | CourtUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutBusinessesDetailsNestedInput = {
    create?: XOR<CategoryCreateWithoutBusinessesDetailsInput, CategoryUncheckedCreateWithoutBusinessesDetailsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBusinessesDetailsInput
    upsert?: CategoryUpsertWithoutBusinessesDetailsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutBusinessesDetailsInput, CategoryUpdateWithoutBusinessesDetailsInput>, CategoryUncheckedUpdateWithoutBusinessesDetailsInput>
  }

  export type TagUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<TagCreateWithoutBusinessDetailsInput, TagUncheckedCreateWithoutBusinessDetailsInput> | TagCreateWithoutBusinessDetailsInput[] | TagUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBusinessDetailsInput | TagCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutBusinessDetailsInput | TagUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutBusinessDetailsInput | TagUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutBusinessDetailsInput | TagUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<BusinessAddressCreateWithoutBusinessDetailsInput, BusinessAddressUncheckedCreateWithoutBusinessDetailsInput> | BusinessAddressCreateWithoutBusinessDetailsInput[] | BusinessAddressUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessAddressCreateOrConnectWithoutBusinessDetailsInput | BusinessAddressCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: BusinessAddressUpsertWithWhereUniqueWithoutBusinessDetailsInput | BusinessAddressUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    createMany?: BusinessAddressCreateManyBusinessDetailsInputEnvelope
    set?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    disconnect?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    delete?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    connect?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    update?: BusinessAddressUpdateWithWhereUniqueWithoutBusinessDetailsInput | BusinessAddressUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: BusinessAddressUpdateManyWithWhereWithoutBusinessDetailsInput | BusinessAddressUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: BusinessAddressScalarWhereInput | BusinessAddressScalarWhereInput[]
  }

  export type BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<BusinessWebsiteCreateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput> | BusinessWebsiteCreateWithoutBusinessDetailsInput[] | BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput | BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: BusinessWebsiteUpsertWithWhereUniqueWithoutBusinessDetailsInput | BusinessWebsiteUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    createMany?: BusinessWebsiteCreateManyBusinessDetailsInputEnvelope
    set?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    disconnect?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    delete?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    connect?: BusinessWebsiteWhereUniqueInput | BusinessWebsiteWhereUniqueInput[]
    update?: BusinessWebsiteUpdateWithWhereUniqueWithoutBusinessDetailsInput | BusinessWebsiteUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: BusinessWebsiteUpdateManyWithWhereWithoutBusinessDetailsInput | BusinessWebsiteUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: BusinessWebsiteScalarWhereInput | BusinessWebsiteScalarWhereInput[]
  }

  export type BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<BusinessImageCreateWithoutBusinessDetailsInput, BusinessImageUncheckedCreateWithoutBusinessDetailsInput> | BusinessImageCreateWithoutBusinessDetailsInput[] | BusinessImageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessImageCreateOrConnectWithoutBusinessDetailsInput | BusinessImageCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: BusinessImageUpsertWithWhereUniqueWithoutBusinessDetailsInput | BusinessImageUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    createMany?: BusinessImageCreateManyBusinessDetailsInputEnvelope
    set?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    disconnect?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    delete?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    connect?: BusinessImageWhereUniqueInput | BusinessImageWhereUniqueInput[]
    update?: BusinessImageUpdateWithWhereUniqueWithoutBusinessDetailsInput | BusinessImageUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: BusinessImageUpdateManyWithWhereWithoutBusinessDetailsInput | BusinessImageUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: BusinessImageScalarWhereInput | BusinessImageScalarWhereInput[]
  }

  export type LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<LanguageCreateWithoutBusinessDetailsInput, LanguageUncheckedCreateWithoutBusinessDetailsInput> | LanguageCreateWithoutBusinessDetailsInput[] | LanguageUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutBusinessDetailsInput | LanguageCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutBusinessDetailsInput | LanguageUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutBusinessDetailsInput | LanguageUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutBusinessDetailsInput | LanguageUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<ProficiencyCreateWithoutBusinessDetailsInput, ProficiencyUncheckedCreateWithoutBusinessDetailsInput> | ProficiencyCreateWithoutBusinessDetailsInput[] | ProficiencyUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: ProficiencyCreateOrConnectWithoutBusinessDetailsInput | ProficiencyCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: ProficiencyUpsertWithWhereUniqueWithoutBusinessDetailsInput | ProficiencyUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    disconnect?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    delete?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    connect?: ProficiencyWhereUniqueInput | ProficiencyWhereUniqueInput[]
    update?: ProficiencyUpdateWithWhereUniqueWithoutBusinessDetailsInput | ProficiencyUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: ProficiencyUpdateManyWithWhereWithoutBusinessDetailsInput | ProficiencyUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: ProficiencyScalarWhereInput | ProficiencyScalarWhereInput[]
  }

  export type CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<CourtCreateWithoutBusinessDetailsInput, CourtUncheckedCreateWithoutBusinessDetailsInput> | CourtCreateWithoutBusinessDetailsInput[] | CourtUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutBusinessDetailsInput | CourtCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutBusinessDetailsInput | CourtUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutBusinessDetailsInput | CourtUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutBusinessDetailsInput | CourtUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<TagCreateWithoutBusinessDetailsInput, TagUncheckedCreateWithoutBusinessDetailsInput> | TagCreateWithoutBusinessDetailsInput[] | TagUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBusinessDetailsInput | TagCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutBusinessDetailsInput | TagUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutBusinessDetailsInput | TagUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutBusinessDetailsInput | TagUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput = {
    create?: XOR<BusinessAddressCreateWithoutBusinessDetailsInput, BusinessAddressUncheckedCreateWithoutBusinessDetailsInput> | BusinessAddressCreateWithoutBusinessDetailsInput[] | BusinessAddressUncheckedCreateWithoutBusinessDetailsInput[]
    connectOrCreate?: BusinessAddressCreateOrConnectWithoutBusinessDetailsInput | BusinessAddressCreateOrConnectWithoutBusinessDetailsInput[]
    upsert?: BusinessAddressUpsertWithWhereUniqueWithoutBusinessDetailsInput | BusinessAddressUpsertWithWhereUniqueWithoutBusinessDetailsInput[]
    createMany?: BusinessAddressCreateManyBusinessDetailsInputEnvelope
    set?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    disconnect?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    delete?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    connect?: BusinessAddressWhereUniqueInput | BusinessAddressWhereUniqueInput[]
    update?: BusinessAddressUpdateWithWhereUniqueWithoutBusinessDetailsInput | BusinessAddressUpdateWithWhereUniqueWithoutBusinessDetailsInput[]
    updateMany?: BusinessAddressUpdateManyWithWhereWithoutBusinessDetailsInput | BusinessAddressUpdateManyWithWhereWithoutBusinessDetailsInput[]
    deleteMany?: BusinessAddressScalarWhereInput | BusinessAddressScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutBusinessSupportingDocumentsInput = {
    create?: XOR<BusinessCreateWithoutBusinessSupportingDocumentsInput, BusinessUncheckedCreateWithoutBusinessSupportingDocumentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBusinessSupportingDocumentsInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutBusinessSupportingDocumentsNestedInput = {
    create?: XOR<BusinessCreateWithoutBusinessSupportingDocumentsInput, BusinessUncheckedCreateWithoutBusinessSupportingDocumentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBusinessSupportingDocumentsInput
    upsert?: BusinessUpsertWithoutBusinessSupportingDocumentsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutBusinessSupportingDocumentsInput, BusinessUpdateWithoutBusinessSupportingDocumentsInput>, BusinessUncheckedUpdateWithoutBusinessSupportingDocumentsInput>
  }

  export type BusinessDetailsCreateNestedOneWithoutImagesInput = {
    create?: XOR<BusinessDetailsCreateWithoutImagesInput, BusinessDetailsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutImagesInput
    connect?: BusinessDetailsWhereUniqueInput
  }

  export type BusinessDetailsUpdateOneWithoutImagesNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutImagesInput, BusinessDetailsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutImagesInput
    upsert?: BusinessDetailsUpsertWithoutImagesInput
    disconnect?: BusinessDetailsWhereInput | boolean
    delete?: BusinessDetailsWhereInput | boolean
    connect?: BusinessDetailsWhereUniqueInput
    update?: XOR<XOR<BusinessDetailsUpdateToOneWithWhereWithoutImagesInput, BusinessDetailsUpdateWithoutImagesInput>, BusinessDetailsUncheckedUpdateWithoutImagesInput>
  }

  export type BusinessDetailsCreateNestedOneWithoutWebsitesInput = {
    create?: XOR<BusinessDetailsCreateWithoutWebsitesInput, BusinessDetailsUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutWebsitesInput
    connect?: BusinessDetailsWhereUniqueInput
  }

  export type BusinessDetailsUpdateOneWithoutWebsitesNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutWebsitesInput, BusinessDetailsUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutWebsitesInput
    upsert?: BusinessDetailsUpsertWithoutWebsitesInput
    disconnect?: BusinessDetailsWhereInput | boolean
    delete?: BusinessDetailsWhereInput | boolean
    connect?: BusinessDetailsWhereUniqueInput
    update?: XOR<XOR<BusinessDetailsUpdateToOneWithWhereWithoutWebsitesInput, BusinessDetailsUpdateWithoutWebsitesInput>, BusinessDetailsUncheckedUpdateWithoutWebsitesInput>
  }

  export type BusinessDetailsCreateNestedManyWithoutLanguageInput = {
    create?: XOR<BusinessDetailsCreateWithoutLanguageInput, BusinessDetailsUncheckedCreateWithoutLanguageInput> | BusinessDetailsCreateWithoutLanguageInput[] | BusinessDetailsUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutLanguageInput | BusinessDetailsCreateOrConnectWithoutLanguageInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<BusinessDetailsCreateWithoutLanguageInput, BusinessDetailsUncheckedCreateWithoutLanguageInput> | BusinessDetailsCreateWithoutLanguageInput[] | BusinessDetailsUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutLanguageInput | BusinessDetailsCreateOrConnectWithoutLanguageInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutLanguageInput, BusinessDetailsUncheckedCreateWithoutLanguageInput> | BusinessDetailsCreateWithoutLanguageInput[] | BusinessDetailsUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutLanguageInput | BusinessDetailsCreateOrConnectWithoutLanguageInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutLanguageInput | BusinessDetailsUpsertWithWhereUniqueWithoutLanguageInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutLanguageInput | BusinessDetailsUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutLanguageInput | BusinessDetailsUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutLanguageInput, BusinessDetailsUncheckedCreateWithoutLanguageInput> | BusinessDetailsCreateWithoutLanguageInput[] | BusinessDetailsUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutLanguageInput | BusinessDetailsCreateOrConnectWithoutLanguageInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutLanguageInput | BusinessDetailsUpsertWithWhereUniqueWithoutLanguageInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutLanguageInput | BusinessDetailsUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutLanguageInput | BusinessDetailsUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsCreateNestedManyWithoutProficiencyInput = {
    create?: XOR<BusinessDetailsCreateWithoutProficiencyInput, BusinessDetailsUncheckedCreateWithoutProficiencyInput> | BusinessDetailsCreateWithoutProficiencyInput[] | BusinessDetailsUncheckedCreateWithoutProficiencyInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutProficiencyInput | BusinessDetailsCreateOrConnectWithoutProficiencyInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUncheckedCreateNestedManyWithoutProficiencyInput = {
    create?: XOR<BusinessDetailsCreateWithoutProficiencyInput, BusinessDetailsUncheckedCreateWithoutProficiencyInput> | BusinessDetailsCreateWithoutProficiencyInput[] | BusinessDetailsUncheckedCreateWithoutProficiencyInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutProficiencyInput | BusinessDetailsCreateOrConnectWithoutProficiencyInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUpdateManyWithoutProficiencyNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutProficiencyInput, BusinessDetailsUncheckedCreateWithoutProficiencyInput> | BusinessDetailsCreateWithoutProficiencyInput[] | BusinessDetailsUncheckedCreateWithoutProficiencyInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutProficiencyInput | BusinessDetailsCreateOrConnectWithoutProficiencyInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutProficiencyInput | BusinessDetailsUpsertWithWhereUniqueWithoutProficiencyInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutProficiencyInput | BusinessDetailsUpdateWithWhereUniqueWithoutProficiencyInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutProficiencyInput | BusinessDetailsUpdateManyWithWhereWithoutProficiencyInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutProficiencyNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutProficiencyInput, BusinessDetailsUncheckedCreateWithoutProficiencyInput> | BusinessDetailsCreateWithoutProficiencyInput[] | BusinessDetailsUncheckedCreateWithoutProficiencyInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutProficiencyInput | BusinessDetailsCreateOrConnectWithoutProficiencyInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutProficiencyInput | BusinessDetailsUpsertWithWhereUniqueWithoutProficiencyInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutProficiencyInput | BusinessDetailsUpdateWithWhereUniqueWithoutProficiencyInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutProficiencyInput | BusinessDetailsUpdateManyWithWhereWithoutProficiencyInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsCreateNestedManyWithoutCourtInput = {
    create?: XOR<BusinessDetailsCreateWithoutCourtInput, BusinessDetailsUncheckedCreateWithoutCourtInput> | BusinessDetailsCreateWithoutCourtInput[] | BusinessDetailsUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCourtInput | BusinessDetailsCreateOrConnectWithoutCourtInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUncheckedCreateNestedManyWithoutCourtInput = {
    create?: XOR<BusinessDetailsCreateWithoutCourtInput, BusinessDetailsUncheckedCreateWithoutCourtInput> | BusinessDetailsCreateWithoutCourtInput[] | BusinessDetailsUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCourtInput | BusinessDetailsCreateOrConnectWithoutCourtInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUpdateManyWithoutCourtNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutCourtInput, BusinessDetailsUncheckedCreateWithoutCourtInput> | BusinessDetailsCreateWithoutCourtInput[] | BusinessDetailsUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCourtInput | BusinessDetailsCreateOrConnectWithoutCourtInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutCourtInput | BusinessDetailsUpsertWithWhereUniqueWithoutCourtInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutCourtInput | BusinessDetailsUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutCourtInput | BusinessDetailsUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutCourtNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutCourtInput, BusinessDetailsUncheckedCreateWithoutCourtInput> | BusinessDetailsCreateWithoutCourtInput[] | BusinessDetailsUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCourtInput | BusinessDetailsCreateOrConnectWithoutCourtInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutCourtInput | BusinessDetailsUpsertWithWhereUniqueWithoutCourtInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutCourtInput | BusinessDetailsUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutCourtInput | BusinessDetailsUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BusinessDetailsCreateWithoutCategoryInput, BusinessDetailsUncheckedCreateWithoutCategoryInput> | BusinessDetailsCreateWithoutCategoryInput[] | BusinessDetailsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCategoryInput | BusinessDetailsCreateOrConnectWithoutCategoryInput[]
    createMany?: BusinessDetailsCreateManyCategoryInputEnvelope
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BusinessDetailsCreateWithoutCategoryInput, BusinessDetailsUncheckedCreateWithoutCategoryInput> | BusinessDetailsCreateWithoutCategoryInput[] | BusinessDetailsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCategoryInput | BusinessDetailsCreateOrConnectWithoutCategoryInput[]
    createMany?: BusinessDetailsCreateManyCategoryInputEnvelope
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutCategoryInput, BusinessDetailsUncheckedCreateWithoutCategoryInput> | BusinessDetailsCreateWithoutCategoryInput[] | BusinessDetailsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCategoryInput | BusinessDetailsCreateOrConnectWithoutCategoryInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutCategoryInput | BusinessDetailsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BusinessDetailsCreateManyCategoryInputEnvelope
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutCategoryInput | BusinessDetailsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutCategoryInput | BusinessDetailsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutCategoryInput, BusinessDetailsUncheckedCreateWithoutCategoryInput> | BusinessDetailsCreateWithoutCategoryInput[] | BusinessDetailsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutCategoryInput | BusinessDetailsCreateOrConnectWithoutCategoryInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutCategoryInput | BusinessDetailsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BusinessDetailsCreateManyCategoryInputEnvelope
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutCategoryInput | BusinessDetailsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutCategoryInput | BusinessDetailsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsCreateNestedManyWithoutTagsInput = {
    create?: XOR<BusinessDetailsCreateWithoutTagsInput, BusinessDetailsUncheckedCreateWithoutTagsInput> | BusinessDetailsCreateWithoutTagsInput[] | BusinessDetailsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutTagsInput | BusinessDetailsCreateOrConnectWithoutTagsInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<BusinessDetailsCreateWithoutTagsInput, BusinessDetailsUncheckedCreateWithoutTagsInput> | BusinessDetailsCreateWithoutTagsInput[] | BusinessDetailsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutTagsInput | BusinessDetailsCreateOrConnectWithoutTagsInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
  }

  export type BusinessDetailsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutTagsInput, BusinessDetailsUncheckedCreateWithoutTagsInput> | BusinessDetailsCreateWithoutTagsInput[] | BusinessDetailsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutTagsInput | BusinessDetailsCreateOrConnectWithoutTagsInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutTagsInput | BusinessDetailsUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutTagsInput | BusinessDetailsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutTagsInput | BusinessDetailsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BusinessDetailsCreateWithoutTagsInput, BusinessDetailsUncheckedCreateWithoutTagsInput> | BusinessDetailsCreateWithoutTagsInput[] | BusinessDetailsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BusinessDetailsCreateOrConnectWithoutTagsInput | BusinessDetailsCreateOrConnectWithoutTagsInput[]
    upsert?: BusinessDetailsUpsertWithWhereUniqueWithoutTagsInput | BusinessDetailsUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    disconnect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    delete?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    connect?: BusinessDetailsWhereUniqueInput | BusinessDetailsWhereUniqueInput[]
    update?: BusinessDetailsUpdateWithWhereUniqueWithoutTagsInput | BusinessDetailsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BusinessDetailsUpdateManyWithWhereWithoutTagsInput | BusinessDetailsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BusinessCreateWithoutReviewsInput, BusinessUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReviewsInput
    connect?: BusinessWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<BusinessCreateWithoutReviewsInput, BusinessUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReviewsInput
    upsert?: BusinessUpsertWithoutReviewsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutReviewsInput, BusinessUpdateWithoutReviewsInput>, BusinessUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type BusinessCreateNestedOneWithoutBookingsInput = {
    create?: XOR<BusinessCreateWithoutBookingsInput, BusinessUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBookingsInput
    connect?: BusinessWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<BusinessCreateWithoutBookingsInput, BusinessUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutBookingsInput
    upsert?: BusinessUpsertWithoutBookingsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutBookingsInput, BusinessUpdateWithoutBookingsInput>, BusinessUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type BusinessCreateNestedOneWithoutChatsInput = {
    create?: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutChatsInput
    connect?: BusinessWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatsInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutChatsInput = {
    create?: XOR<MessageCreateWithoutChatsInput, MessageUncheckedCreateWithoutChatsInput> | MessageCreateWithoutChatsInput[] | MessageUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatsInput | MessageCreateOrConnectWithoutChatsInput[]
    createMany?: MessageCreateManyChatsInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<MessageCreateWithoutChatsInput, MessageUncheckedCreateWithoutChatsInput> | MessageCreateWithoutChatsInput[] | MessageUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatsInput | MessageCreateOrConnectWithoutChatsInput[]
    createMany?: MessageCreateManyChatsInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type BusinessUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutChatsInput
    upsert?: BusinessUpsertWithoutChatsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutChatsInput, BusinessUpdateWithoutChatsInput>, BusinessUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    upsert?: UserUpsertWithoutChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatsInput, UserUpdateWithoutChatsInput>, UserUncheckedUpdateWithoutChatsInput>
  }

  export type MessageUpdateManyWithoutChatsNestedInput = {
    create?: XOR<MessageCreateWithoutChatsInput, MessageUncheckedCreateWithoutChatsInput> | MessageCreateWithoutChatsInput[] | MessageUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatsInput | MessageCreateOrConnectWithoutChatsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatsInput | MessageUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: MessageCreateManyChatsInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatsInput | MessageUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatsInput | MessageUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<MessageCreateWithoutChatsInput, MessageUncheckedCreateWithoutChatsInput> | MessageCreateWithoutChatsInput[] | MessageUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatsInput | MessageCreateOrConnectWithoutChatsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatsInput | MessageUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: MessageCreateManyChatsInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatsInput | MessageUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatsInput | MessageUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessageInput = {
    create?: XOR<ChatCreateWithoutMessageInput, ChatUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessageInput
    connect?: ChatWhereUniqueInput
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type ChatUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<ChatCreateWithoutMessageInput, ChatUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessageInput
    upsert?: ChatUpsertWithoutMessageInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessageInput, ChatUpdateWithoutMessageInput>, ChatUncheckedUpdateWithoutMessageInput>
  }

  export type CityCreateNestedOneWithoutPincodesInput = {
    create?: XOR<CityCreateWithoutPincodesInput, CityUncheckedCreateWithoutPincodesInput>
    connectOrCreate?: CityCreateOrConnectWithoutPincodesInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutPincodesNestedInput = {
    create?: XOR<CityCreateWithoutPincodesInput, CityUncheckedCreateWithoutPincodesInput>
    connectOrCreate?: CityCreateOrConnectWithoutPincodesInput
    upsert?: CityUpsertWithoutPincodesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutPincodesInput, CityUpdateWithoutPincodesInput>, CityUncheckedUpdateWithoutPincodesInput>
  }

  export type StateCreateNestedOneWithoutCitiesInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    connect?: StateWhereUniqueInput
  }

  export type PincodeCreateNestedManyWithoutCityInput = {
    create?: XOR<PincodeCreateWithoutCityInput, PincodeUncheckedCreateWithoutCityInput> | PincodeCreateWithoutCityInput[] | PincodeUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PincodeCreateOrConnectWithoutCityInput | PincodeCreateOrConnectWithoutCityInput[]
    createMany?: PincodeCreateManyCityInputEnvelope
    connect?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
  }

  export type PincodeUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<PincodeCreateWithoutCityInput, PincodeUncheckedCreateWithoutCityInput> | PincodeCreateWithoutCityInput[] | PincodeUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PincodeCreateOrConnectWithoutCityInput | PincodeCreateOrConnectWithoutCityInput[]
    createMany?: PincodeCreateManyCityInputEnvelope
    connect?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
  }

  export type StateUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    upsert?: StateUpsertWithoutCitiesInput
    connect?: StateWhereUniqueInput
    update?: XOR<XOR<StateUpdateToOneWithWhereWithoutCitiesInput, StateUpdateWithoutCitiesInput>, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type PincodeUpdateManyWithoutCityNestedInput = {
    create?: XOR<PincodeCreateWithoutCityInput, PincodeUncheckedCreateWithoutCityInput> | PincodeCreateWithoutCityInput[] | PincodeUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PincodeCreateOrConnectWithoutCityInput | PincodeCreateOrConnectWithoutCityInput[]
    upsert?: PincodeUpsertWithWhereUniqueWithoutCityInput | PincodeUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PincodeCreateManyCityInputEnvelope
    set?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    disconnect?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    delete?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    connect?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    update?: PincodeUpdateWithWhereUniqueWithoutCityInput | PincodeUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PincodeUpdateManyWithWhereWithoutCityInput | PincodeUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PincodeScalarWhereInput | PincodeScalarWhereInput[]
  }

  export type PincodeUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<PincodeCreateWithoutCityInput, PincodeUncheckedCreateWithoutCityInput> | PincodeCreateWithoutCityInput[] | PincodeUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PincodeCreateOrConnectWithoutCityInput | PincodeCreateOrConnectWithoutCityInput[]
    upsert?: PincodeUpsertWithWhereUniqueWithoutCityInput | PincodeUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PincodeCreateManyCityInputEnvelope
    set?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    disconnect?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    delete?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    connect?: PincodeWhereUniqueInput | PincodeWhereUniqueInput[]
    update?: PincodeUpdateWithWhereUniqueWithoutCityInput | PincodeUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PincodeUpdateManyWithWhereWithoutCityInput | PincodeUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PincodeScalarWhereInput | PincodeScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutStateInput = {
    create?: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStateInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutStateInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutStateNestedInput = {
    create?: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStateInput
    upsert?: CountryUpsertWithoutStateInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutStateInput, CountryUpdateWithoutStateInput>, CountryUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithoutStateNestedInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutStateInput | CityUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutStateInput | CityUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: CityUpdateManyWithWhereWithoutStateInput | CityUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutStateInput | CityUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutStateInput | CityUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: CityUpdateManyWithWhereWithoutStateInput | CityUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type StateCreateNestedManyWithoutCountryInput = {
    create?: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput> | StateCreateWithoutCountryInput[] | StateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: StateCreateOrConnectWithoutCountryInput | StateCreateOrConnectWithoutCountryInput[]
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: StateWhereUniqueInput | StateWhereUniqueInput[]
  }

  export type StateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput> | StateCreateWithoutCountryInput[] | StateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: StateCreateOrConnectWithoutCountryInput | StateCreateOrConnectWithoutCountryInput[]
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: StateWhereUniqueInput | StateWhereUniqueInput[]
  }

  export type StateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput> | StateCreateWithoutCountryInput[] | StateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: StateCreateOrConnectWithoutCountryInput | StateCreateOrConnectWithoutCountryInput[]
    upsert?: StateUpsertWithWhereUniqueWithoutCountryInput | StateUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: StateCreateManyCountryInputEnvelope
    set?: StateWhereUniqueInput | StateWhereUniqueInput[]
    disconnect?: StateWhereUniqueInput | StateWhereUniqueInput[]
    delete?: StateWhereUniqueInput | StateWhereUniqueInput[]
    connect?: StateWhereUniqueInput | StateWhereUniqueInput[]
    update?: StateUpdateWithWhereUniqueWithoutCountryInput | StateUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: StateUpdateManyWithWhereWithoutCountryInput | StateUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: StateScalarWhereInput | StateScalarWhereInput[]
  }

  export type StateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput> | StateCreateWithoutCountryInput[] | StateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: StateCreateOrConnectWithoutCountryInput | StateCreateOrConnectWithoutCountryInput[]
    upsert?: StateUpsertWithWhereUniqueWithoutCountryInput | StateUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: StateCreateManyCountryInputEnvelope
    set?: StateWhereUniqueInput | StateWhereUniqueInput[]
    disconnect?: StateWhereUniqueInput | StateWhereUniqueInput[]
    delete?: StateWhereUniqueInput | StateWhereUniqueInput[]
    connect?: StateWhereUniqueInput | StateWhereUniqueInput[]
    update?: StateUpdateWithWhereUniqueWithoutCountryInput | StateUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: StateUpdateManyWithWhereWithoutCountryInput | StateUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: StateScalarWhereInput | StateScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBusinessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeFilter<$PrismaModel> | $Enums.BusinessType
  }

  export type NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessType | EnumBusinessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessType[] | ListEnumBusinessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessTypeWithAggregatesFilter<$PrismaModel> | $Enums.BusinessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessTypeFilter<$PrismaModel>
    _max?: NestedEnumBusinessTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactCreateNestedManyWithoutUserInput
    addresses?: UserAddressCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserCreateManySubscriptionInputEnvelope = {
    data: UserCreateManySubscriptionInput | UserCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateManyWithWhereWithoutSubscriptionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    slug?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    hideDetails?: BoolFilter<"User"> | boolean
    avatar?: StringNullableFilter<"User"> | string | null
    subscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionExpire?: DateTimeNullableFilter<"User"> | Date | string | null
    paymentVerification?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type UserContactCreateWithoutUserInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactCreateOrConnectWithoutUserInput = {
    where: UserContactWhereUniqueInput
    create: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput>
  }

  export type UserContactCreateManyUserInputEnvelope = {
    data: UserContactCreateManyUserInput | UserContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressCreateManyUserInputEnvelope = {
    data: UserAddressCreateManyUserInput | UserAddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    businessId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    Business: BusinessCreateNestedOneWithoutChatsInput
    Message?: MessageCreateNestedManyWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutUserInput = {
    id?: string
    businessId: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    Message?: MessageUncheckedCreateNestedManyWithoutChatsInput
  }

  export type ChatCreateOrConnectWithoutUserInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatCreateManyUserInputEnvelope = {
    data: ChatCreateManyUserInput | ChatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    business?: BusinessCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    businessId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    features?: UserSubscriptionCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserSubscriptionUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration: number
    features?: UserSubscriptionCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserSubscriptionCreateOrConnectWithoutUsersInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUsersInput, UserSubscriptionUncheckedCreateWithoutUsersInput>
  }

  export type UserContactUpsertWithWhereUniqueWithoutUserInput = {
    where: UserContactWhereUniqueInput
    update: XOR<UserContactUpdateWithoutUserInput, UserContactUncheckedUpdateWithoutUserInput>
    create: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput>
  }

  export type UserContactUpdateWithWhereUniqueWithoutUserInput = {
    where: UserContactWhereUniqueInput
    data: XOR<UserContactUpdateWithoutUserInput, UserContactUncheckedUpdateWithoutUserInput>
  }

  export type UserContactUpdateManyWithWhereWithoutUserInput = {
    where: UserContactScalarWhereInput
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyWithoutUserInput>
  }

  export type UserContactScalarWhereInput = {
    AND?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
    OR?: UserContactScalarWhereInput[]
    NOT?: UserContactScalarWhereInput | UserContactScalarWhereInput[]
    id?: StringFilter<"UserContact"> | string
    userId?: StringFilter<"UserContact"> | string
    type?: EnumContactTypeFilter<"UserContact"> | $Enums.ContactType
    value?: StringFilter<"UserContact"> | string
    isVerified?: BoolFilter<"UserContact"> | boolean
    isPrimary?: BoolFilter<"UserContact"> | boolean
    order?: IntNullableFilter<"UserContact"> | number | null
    verifiedAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    otp?: StringNullableFilter<"UserContact"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
    createdAt?: DateTimeFilter<"UserContact"> | Date | string
    updatedAt?: DateTimeFilter<"UserContact"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserContact"> | Date | string | null
  }

  export type UserAddressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutUserInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAddressScalarWhereInput = {
    AND?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    OR?: UserAddressScalarWhereInput[]
    NOT?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    id?: StringFilter<"UserAddress"> | string
    userId?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserAddress"> | Date | string | null
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    order?: IntNullableFilter<"UserAddress"> | number | null
    street?: StringFilter<"UserAddress"> | string
    city?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    pincode?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    date?: DateTimeFilter<"Booking"> | Date | string
    userId?: StringFilter<"Booking"> | string
    businessId?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ChatUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
  }

  export type ChatUpdateManyWithWhereWithoutUserInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    userId?: StringFilter<"Chat"> | string
    businessId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    businessId?: StringNullableFilter<"Review"> | string | null
    userId?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type UserSubscriptionUpsertWithoutUsersInput = {
    update: XOR<UserSubscriptionUpdateWithoutUsersInput, UserSubscriptionUncheckedUpdateWithoutUsersInput>
    create: XOR<UserSubscriptionCreateWithoutUsersInput, UserSubscriptionUncheckedCreateWithoutUsersInput>
    where?: UserSubscriptionWhereInput
  }

  export type UserSubscriptionUpdateToOneWithWhereWithoutUsersInput = {
    where?: UserSubscriptionWhereInput
    data: XOR<UserSubscriptionUpdateWithoutUsersInput, UserSubscriptionUncheckedUpdateWithoutUsersInput>
  }

  export type UserSubscriptionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: UserSubscriptionUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSubscriptionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: UserSubscriptionUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutContactsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addresses?: UserAddressCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: UserAddressUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAddressesInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessCreateWithoutSubscriptionInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactCreateNestedManyWithoutBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
    bookings?: BookingCreateNestedManyWithoutBusinessInput
    reviews?: ReviewCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBusinessInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutSubscriptionInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput>
  }

  export type BusinessCreateManySubscriptionInputEnvelope = {
    data: BusinessCreateManySubscriptionInput | BusinessCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutSubscriptionInput, BusinessUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<BusinessCreateWithoutSubscriptionInput, BusinessUncheckedCreateWithoutSubscriptionInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutSubscriptionInput, BusinessUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BusinessUpdateManyWithWhereWithoutSubscriptionInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type BusinessScalarWhereInput = {
    AND?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    OR?: BusinessScalarWhereInput[]
    NOT?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    id?: StringFilter<"Business"> | string
    name?: StringNullableFilter<"Business"> | string | null
    slug?: StringNullableFilter<"Business"> | string | null
    additionalContacts?: StringNullableListFilter<"Business">
    password?: StringNullableFilter<"Business"> | string | null
    salt?: StringNullableFilter<"Business"> | string | null
    isBusinessVerified?: BoolFilter<"Business"> | boolean
    type?: EnumBusinessTypeFilter<"Business"> | $Enums.BusinessType
    subscriptionId?: StringNullableFilter<"Business"> | string | null
    subscriptionExpire?: DateTimeNullableFilter<"Business"> | Date | string | null
    averageRating?: FloatNullableFilter<"Business"> | number | null
    reviewCount?: IntFilter<"Business"> | number
    isListed?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    paymentVerification?: BoolFilter<"Business"> | boolean
    price?: FloatNullableFilter<"Business"> | number | null
  }

  export type BusinessPrimaryContactCreateWithoutBusinessInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessPrimaryContactUncheckedCreateWithoutBusinessInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessPrimaryContactCreateOrConnectWithoutBusinessInput = {
    where: BusinessPrimaryContactWhereUniqueInput
    create: XOR<BusinessPrimaryContactCreateWithoutBusinessInput, BusinessPrimaryContactUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessPrimaryContactCreateManyBusinessInputEnvelope = {
    data: BusinessPrimaryContactCreateManyBusinessInput | BusinessPrimaryContactCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type BusinessSubscriptionCreateWithoutBusinessesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.BusinessType
    price: number
    duration: number
    features?: BusinessSubscriptionCreatefeaturesInput | string[]
    tierLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessSubscriptionUncheckedCreateWithoutBusinessesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.BusinessType
    price: number
    duration: number
    features?: BusinessSubscriptionCreatefeaturesInput | string[]
    tierLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessSubscriptionCreateOrConnectWithoutBusinessesInput = {
    where: BusinessSubscriptionWhereUniqueInput
    create: XOR<BusinessSubscriptionCreateWithoutBusinessesInput, BusinessSubscriptionUncheckedCreateWithoutBusinessesInput>
  }

  export type ChatCreateWithoutBusinessInput = {
    id?: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    User: UserCreateNestedOneWithoutChatsInput
    Message?: MessageCreateNestedManyWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutBusinessInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    Message?: MessageUncheckedCreateNestedManyWithoutChatsInput
  }

  export type ChatCreateOrConnectWithoutBusinessInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput>
  }

  export type ChatCreateManyBusinessInputEnvelope = {
    data: ChatCreateManyBusinessInput | ChatCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutBusinessInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutBusinessInput = {
    id?: string
    date: Date | string
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutBusinessInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBusinessInput, BookingUncheckedCreateWithoutBusinessInput>
  }

  export type BookingCreateManyBusinessInputEnvelope = {
    data: BookingCreateManyBusinessInput | BookingCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutBusinessInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutBusinessInput = {
    id?: string
    rating: number
    comment?: string | null
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutBusinessInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBusinessInput, ReviewUncheckedCreateWithoutBusinessInput>
  }

  export type ReviewCreateManyBusinessInputEnvelope = {
    data: ReviewCreateManyBusinessInput | ReviewCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type BusinessSupportingDocumentsCreateWithoutBusinessInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessSupportingDocumentsCreateOrConnectWithoutBusinessInput = {
    where: BusinessSupportingDocumentsWhereUniqueInput
    create: XOR<BusinessSupportingDocumentsCreateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessSupportingDocumentsCreateManyBusinessInputEnvelope = {
    data: BusinessSupportingDocumentsCreateManyBusinessInput | BusinessSupportingDocumentsCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type BusinessDetailsCreateWithoutBusinessInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutBusinessInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutBusinessInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutBusinessInput, BusinessDetailsUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessPrimaryContactUpsertWithWhereUniqueWithoutBusinessInput = {
    where: BusinessPrimaryContactWhereUniqueInput
    update: XOR<BusinessPrimaryContactUpdateWithoutBusinessInput, BusinessPrimaryContactUncheckedUpdateWithoutBusinessInput>
    create: XOR<BusinessPrimaryContactCreateWithoutBusinessInput, BusinessPrimaryContactUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessPrimaryContactUpdateWithWhereUniqueWithoutBusinessInput = {
    where: BusinessPrimaryContactWhereUniqueInput
    data: XOR<BusinessPrimaryContactUpdateWithoutBusinessInput, BusinessPrimaryContactUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessPrimaryContactUpdateManyWithWhereWithoutBusinessInput = {
    where: BusinessPrimaryContactScalarWhereInput
    data: XOR<BusinessPrimaryContactUpdateManyMutationInput, BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BusinessPrimaryContactScalarWhereInput = {
    AND?: BusinessPrimaryContactScalarWhereInput | BusinessPrimaryContactScalarWhereInput[]
    OR?: BusinessPrimaryContactScalarWhereInput[]
    NOT?: BusinessPrimaryContactScalarWhereInput | BusinessPrimaryContactScalarWhereInput[]
    id?: StringFilter<"BusinessPrimaryContact"> | string
    businessId?: StringFilter<"BusinessPrimaryContact"> | string
    type?: EnumContactTypeFilter<"BusinessPrimaryContact"> | $Enums.ContactType
    value?: StringFilter<"BusinessPrimaryContact"> | string
    isVerified?: BoolFilter<"BusinessPrimaryContact"> | boolean
    isPrimary?: BoolFilter<"BusinessPrimaryContact"> | boolean
    order?: IntNullableFilter<"BusinessPrimaryContact"> | number | null
    verifiedAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    otp?: StringNullableFilter<"BusinessPrimaryContact"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
    createdAt?: DateTimeFilter<"BusinessPrimaryContact"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessPrimaryContact"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessPrimaryContact"> | Date | string | null
  }

  export type BusinessSubscriptionUpsertWithoutBusinessesInput = {
    update: XOR<BusinessSubscriptionUpdateWithoutBusinessesInput, BusinessSubscriptionUncheckedUpdateWithoutBusinessesInput>
    create: XOR<BusinessSubscriptionCreateWithoutBusinessesInput, BusinessSubscriptionUncheckedCreateWithoutBusinessesInput>
    where?: BusinessSubscriptionWhereInput
  }

  export type BusinessSubscriptionUpdateToOneWithWhereWithoutBusinessesInput = {
    where?: BusinessSubscriptionWhereInput
    data: XOR<BusinessSubscriptionUpdateWithoutBusinessesInput, BusinessSubscriptionUncheckedUpdateWithoutBusinessesInput>
  }

  export type BusinessSubscriptionUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: BusinessSubscriptionUpdatefeaturesInput | string[]
    tierLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessSubscriptionUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    features?: BusinessSubscriptionUpdatefeaturesInput | string[]
    tierLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutBusinessInput, ChatUncheckedUpdateWithoutBusinessInput>
    create: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutBusinessInput, ChatUncheckedUpdateWithoutBusinessInput>
  }

  export type ChatUpdateManyWithWhereWithoutBusinessInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutBusinessInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBusinessInput, BookingUncheckedUpdateWithoutBusinessInput>
    create: XOR<BookingCreateWithoutBusinessInput, BookingUncheckedCreateWithoutBusinessInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBusinessInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBusinessInput, BookingUncheckedUpdateWithoutBusinessInput>
  }

  export type BookingUpdateManyWithWhereWithoutBusinessInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBusinessInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutBusinessInput, ReviewUncheckedUpdateWithoutBusinessInput>
    create: XOR<ReviewCreateWithoutBusinessInput, ReviewUncheckedCreateWithoutBusinessInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutBusinessInput, ReviewUncheckedUpdateWithoutBusinessInput>
  }

  export type ReviewUpdateManyWithWhereWithoutBusinessInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BusinessSupportingDocumentsUpsertWithWhereUniqueWithoutBusinessInput = {
    where: BusinessSupportingDocumentsWhereUniqueInput
    update: XOR<BusinessSupportingDocumentsUpdateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedUpdateWithoutBusinessInput>
    create: XOR<BusinessSupportingDocumentsCreateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessSupportingDocumentsUpdateWithWhereUniqueWithoutBusinessInput = {
    where: BusinessSupportingDocumentsWhereUniqueInput
    data: XOR<BusinessSupportingDocumentsUpdateWithoutBusinessInput, BusinessSupportingDocumentsUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessSupportingDocumentsUpdateManyWithWhereWithoutBusinessInput = {
    where: BusinessSupportingDocumentsScalarWhereInput
    data: XOR<BusinessSupportingDocumentsUpdateManyMutationInput, BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BusinessSupportingDocumentsScalarWhereInput = {
    AND?: BusinessSupportingDocumentsScalarWhereInput | BusinessSupportingDocumentsScalarWhereInput[]
    OR?: BusinessSupportingDocumentsScalarWhereInput[]
    NOT?: BusinessSupportingDocumentsScalarWhereInput | BusinessSupportingDocumentsScalarWhereInput[]
    id?: StringFilter<"BusinessSupportingDocuments"> | string
    businessId?: StringFilter<"BusinessSupportingDocuments"> | string
    type?: StringFilter<"BusinessSupportingDocuments"> | string
    url?: StringFilter<"BusinessSupportingDocuments"> | string
    createdAt?: DateTimeFilter<"BusinessSupportingDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessSupportingDocuments"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessSupportingDocuments"> | Date | string | null
  }

  export type BusinessDetailsUpsertWithoutBusinessInput = {
    update: XOR<BusinessDetailsUpdateWithoutBusinessInput, BusinessDetailsUncheckedUpdateWithoutBusinessInput>
    create: XOR<BusinessDetailsCreateWithoutBusinessInput, BusinessDetailsUncheckedCreateWithoutBusinessInput>
    where?: BusinessDetailsWhereInput
  }

  export type BusinessDetailsUpdateToOneWithWhereWithoutBusinessInput = {
    where?: BusinessDetailsWhereInput
    data: XOR<BusinessDetailsUpdateWithoutBusinessInput, BusinessDetailsUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessDetailsUpdateWithoutBusinessInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutBusinessInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessCreateWithoutPrimaryContactsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    subscription?: BusinessSubscriptionCreateNestedOneWithoutBusinessesInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
    bookings?: BookingCreateNestedManyWithoutBusinessInput
    reviews?: ReviewCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutPrimaryContactsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBusinessInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutPrimaryContactsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutPrimaryContactsInput, BusinessUncheckedCreateWithoutPrimaryContactsInput>
  }

  export type BusinessUpsertWithoutPrimaryContactsInput = {
    update: XOR<BusinessUpdateWithoutPrimaryContactsInput, BusinessUncheckedUpdateWithoutPrimaryContactsInput>
    create: XOR<BusinessCreateWithoutPrimaryContactsInput, BusinessUncheckedCreateWithoutPrimaryContactsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutPrimaryContactsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutPrimaryContactsInput, BusinessUncheckedUpdateWithoutPrimaryContactsInput>
  }

  export type BusinessUpdateWithoutPrimaryContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    subscription?: BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutPrimaryContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessDetailsCreateWithoutAddressesInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutAddressesInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutAddressesInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutAddressesInput, BusinessDetailsUncheckedCreateWithoutAddressesInput>
  }

  export type BusinessDetailsUpsertWithoutAddressesInput = {
    update: XOR<BusinessDetailsUpdateWithoutAddressesInput, BusinessDetailsUncheckedUpdateWithoutAddressesInput>
    create: XOR<BusinessDetailsCreateWithoutAddressesInput, BusinessDetailsUncheckedCreateWithoutAddressesInput>
    where?: BusinessDetailsWhereInput
  }

  export type BusinessDetailsUpdateToOneWithWhereWithoutAddressesInput = {
    where?: BusinessDetailsWhereInput
    data: XOR<BusinessDetailsUpdateWithoutAddressesInput, BusinessDetailsUncheckedUpdateWithoutAddressesInput>
  }

  export type BusinessDetailsUpdateWithoutAddressesInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessCreateWithoutBusinessDetailsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactCreateNestedManyWithoutBusinessInput
    subscription?: BusinessSubscriptionCreateNestedOneWithoutBusinessesInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
    bookings?: BookingCreateNestedManyWithoutBusinessInput
    reviews?: ReviewCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBusinessInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutBusinessDetailsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutBusinessDetailsInput, BusinessUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessWebsiteCreateWithoutBusinessDetailsInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BusinessWebsiteCreateOrConnectWithoutBusinessDetailsInput = {
    where: BusinessWebsiteWhereUniqueInput
    create: XOR<BusinessWebsiteCreateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessWebsiteCreateManyBusinessDetailsInputEnvelope = {
    data: BusinessWebsiteCreateManyBusinessDetailsInput | BusinessWebsiteCreateManyBusinessDetailsInput[]
    skipDuplicates?: boolean
  }

  export type BusinessImageCreateWithoutBusinessDetailsInput = {
    id?: string
    url: string
    order?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BusinessImageUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    url: string
    order?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BusinessImageCreateOrConnectWithoutBusinessDetailsInput = {
    where: BusinessImageWhereUniqueInput
    create: XOR<BusinessImageCreateWithoutBusinessDetailsInput, BusinessImageUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessImageCreateManyBusinessDetailsInputEnvelope = {
    data: BusinessImageCreateManyBusinessDetailsInput | BusinessImageCreateManyBusinessDetailsInput[]
    skipDuplicates?: boolean
  }

  export type LanguageCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type LanguageUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type LanguageCreateOrConnectWithoutBusinessDetailsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutBusinessDetailsInput, LanguageUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type ProficiencyCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ProficiencyUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ProficiencyCreateOrConnectWithoutBusinessDetailsInput = {
    where: ProficiencyWhereUniqueInput
    create: XOR<ProficiencyCreateWithoutBusinessDetailsInput, ProficiencyUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type CourtCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type CourtUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type CourtCreateOrConnectWithoutBusinessDetailsInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutBusinessDetailsInput, CourtUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type CategoryCreateWithoutBusinessesDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    categoryImage?: string | null
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutBusinessesDetailsInput = {
    id?: string
    name: string
    slug?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    categoryImage?: string | null
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutBusinessesDetailsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBusinessesDetailsInput, CategoryUncheckedCreateWithoutBusinessesDetailsInput>
  }

  export type TagCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutBusinessDetailsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutBusinessDetailsInput, TagUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessAddressCreateWithoutBusinessDetailsInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type BusinessAddressUncheckedCreateWithoutBusinessDetailsInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type BusinessAddressCreateOrConnectWithoutBusinessDetailsInput = {
    where: BusinessAddressWhereUniqueInput
    create: XOR<BusinessAddressCreateWithoutBusinessDetailsInput, BusinessAddressUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessAddressCreateManyBusinessDetailsInputEnvelope = {
    data: BusinessAddressCreateManyBusinessDetailsInput | BusinessAddressCreateManyBusinessDetailsInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutBusinessDetailsInput = {
    update: XOR<BusinessUpdateWithoutBusinessDetailsInput, BusinessUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<BusinessCreateWithoutBusinessDetailsInput, BusinessUncheckedCreateWithoutBusinessDetailsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutBusinessDetailsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutBusinessDetailsInput, BusinessUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type BusinessUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput
    subscription?: BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessWebsiteUpsertWithWhereUniqueWithoutBusinessDetailsInput = {
    where: BusinessWebsiteWhereUniqueInput
    update: XOR<BusinessWebsiteUpdateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<BusinessWebsiteCreateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessWebsiteUpdateWithWhereUniqueWithoutBusinessDetailsInput = {
    where: BusinessWebsiteWhereUniqueInput
    data: XOR<BusinessWebsiteUpdateWithoutBusinessDetailsInput, BusinessWebsiteUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type BusinessWebsiteUpdateManyWithWhereWithoutBusinessDetailsInput = {
    where: BusinessWebsiteScalarWhereInput
    data: XOR<BusinessWebsiteUpdateManyMutationInput, BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsInput>
  }

  export type BusinessWebsiteScalarWhereInput = {
    AND?: BusinessWebsiteScalarWhereInput | BusinessWebsiteScalarWhereInput[]
    OR?: BusinessWebsiteScalarWhereInput[]
    NOT?: BusinessWebsiteScalarWhereInput | BusinessWebsiteScalarWhereInput[]
    id?: StringFilter<"BusinessWebsite"> | string
    type?: StringFilter<"BusinessWebsite"> | string
    url?: StringFilter<"BusinessWebsite"> | string
    createdAt?: DateTimeFilter<"BusinessWebsite"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessWebsite"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessWebsite"> | Date | string
    businessDetailsId?: StringNullableFilter<"BusinessWebsite"> | string | null
  }

  export type BusinessImageUpsertWithWhereUniqueWithoutBusinessDetailsInput = {
    where: BusinessImageWhereUniqueInput
    update: XOR<BusinessImageUpdateWithoutBusinessDetailsInput, BusinessImageUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<BusinessImageCreateWithoutBusinessDetailsInput, BusinessImageUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessImageUpdateWithWhereUniqueWithoutBusinessDetailsInput = {
    where: BusinessImageWhereUniqueInput
    data: XOR<BusinessImageUpdateWithoutBusinessDetailsInput, BusinessImageUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type BusinessImageUpdateManyWithWhereWithoutBusinessDetailsInput = {
    where: BusinessImageScalarWhereInput
    data: XOR<BusinessImageUpdateManyMutationInput, BusinessImageUncheckedUpdateManyWithoutBusinessDetailsInput>
  }

  export type BusinessImageScalarWhereInput = {
    AND?: BusinessImageScalarWhereInput | BusinessImageScalarWhereInput[]
    OR?: BusinessImageScalarWhereInput[]
    NOT?: BusinessImageScalarWhereInput | BusinessImageScalarWhereInput[]
    id?: StringFilter<"BusinessImage"> | string
    url?: StringFilter<"BusinessImage"> | string
    order?: IntNullableFilter<"BusinessImage"> | number | null
    createdAt?: DateTimeFilter<"BusinessImage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessImage"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessImage"> | Date | string
    businessDetailsId?: StringNullableFilter<"BusinessImage"> | string | null
  }

  export type LanguageUpsertWithWhereUniqueWithoutBusinessDetailsInput = {
    where: LanguageWhereUniqueInput
    update: XOR<LanguageUpdateWithoutBusinessDetailsInput, LanguageUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<LanguageCreateWithoutBusinessDetailsInput, LanguageUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type LanguageUpdateWithWhereUniqueWithoutBusinessDetailsInput = {
    where: LanguageWhereUniqueInput
    data: XOR<LanguageUpdateWithoutBusinessDetailsInput, LanguageUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type LanguageUpdateManyWithWhereWithoutBusinessDetailsInput = {
    where: LanguageScalarWhereInput
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyWithoutBusinessDetailsInput>
  }

  export type LanguageScalarWhereInput = {
    AND?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    OR?: LanguageScalarWhereInput[]
    NOT?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    id?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    slug?: StringNullableFilter<"Language"> | string | null
    createdAt?: DateTimeFilter<"Language"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Language"> | Date | string | null
    updatedAt?: DateTimeFilter<"Language"> | Date | string
  }

  export type ProficiencyUpsertWithWhereUniqueWithoutBusinessDetailsInput = {
    where: ProficiencyWhereUniqueInput
    update: XOR<ProficiencyUpdateWithoutBusinessDetailsInput, ProficiencyUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<ProficiencyCreateWithoutBusinessDetailsInput, ProficiencyUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type ProficiencyUpdateWithWhereUniqueWithoutBusinessDetailsInput = {
    where: ProficiencyWhereUniqueInput
    data: XOR<ProficiencyUpdateWithoutBusinessDetailsInput, ProficiencyUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type ProficiencyUpdateManyWithWhereWithoutBusinessDetailsInput = {
    where: ProficiencyScalarWhereInput
    data: XOR<ProficiencyUpdateManyMutationInput, ProficiencyUncheckedUpdateManyWithoutBusinessDetailsInput>
  }

  export type ProficiencyScalarWhereInput = {
    AND?: ProficiencyScalarWhereInput | ProficiencyScalarWhereInput[]
    OR?: ProficiencyScalarWhereInput[]
    NOT?: ProficiencyScalarWhereInput | ProficiencyScalarWhereInput[]
    id?: StringFilter<"Proficiency"> | string
    name?: StringFilter<"Proficiency"> | string
    slug?: StringNullableFilter<"Proficiency"> | string | null
    createdAt?: DateTimeFilter<"Proficiency"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Proficiency"> | Date | string | null
    updatedAt?: DateTimeFilter<"Proficiency"> | Date | string
  }

  export type CourtUpsertWithWhereUniqueWithoutBusinessDetailsInput = {
    where: CourtWhereUniqueInput
    update: XOR<CourtUpdateWithoutBusinessDetailsInput, CourtUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<CourtCreateWithoutBusinessDetailsInput, CourtUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type CourtUpdateWithWhereUniqueWithoutBusinessDetailsInput = {
    where: CourtWhereUniqueInput
    data: XOR<CourtUpdateWithoutBusinessDetailsInput, CourtUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type CourtUpdateManyWithWhereWithoutBusinessDetailsInput = {
    where: CourtScalarWhereInput
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyWithoutBusinessDetailsInput>
  }

  export type CourtScalarWhereInput = {
    AND?: CourtScalarWhereInput | CourtScalarWhereInput[]
    OR?: CourtScalarWhereInput[]
    NOT?: CourtScalarWhereInput | CourtScalarWhereInput[]
    id?: StringFilter<"Court"> | string
    name?: StringFilter<"Court"> | string
    slug?: StringNullableFilter<"Court"> | string | null
    createdAt?: DateTimeFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Court"> | Date | string | null
    updatedAt?: DateTimeFilter<"Court"> | Date | string
  }

  export type CategoryUpsertWithoutBusinessesDetailsInput = {
    update: XOR<CategoryUpdateWithoutBusinessesDetailsInput, CategoryUncheckedUpdateWithoutBusinessesDetailsInput>
    create: XOR<CategoryCreateWithoutBusinessesDetailsInput, CategoryUncheckedCreateWithoutBusinessesDetailsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutBusinessesDetailsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutBusinessesDetailsInput, CategoryUncheckedUpdateWithoutBusinessesDetailsInput>
  }

  export type CategoryUpdateWithoutBusinessesDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryImage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutBusinessesDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryImage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutBusinessDetailsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutBusinessDetailsInput, TagUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<TagCreateWithoutBusinessDetailsInput, TagUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutBusinessDetailsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutBusinessDetailsInput, TagUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type TagUpdateManyWithWhereWithoutBusinessDetailsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutBusinessDetailsInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type BusinessAddressUpsertWithWhereUniqueWithoutBusinessDetailsInput = {
    where: BusinessAddressWhereUniqueInput
    update: XOR<BusinessAddressUpdateWithoutBusinessDetailsInput, BusinessAddressUncheckedUpdateWithoutBusinessDetailsInput>
    create: XOR<BusinessAddressCreateWithoutBusinessDetailsInput, BusinessAddressUncheckedCreateWithoutBusinessDetailsInput>
  }

  export type BusinessAddressUpdateWithWhereUniqueWithoutBusinessDetailsInput = {
    where: BusinessAddressWhereUniqueInput
    data: XOR<BusinessAddressUpdateWithoutBusinessDetailsInput, BusinessAddressUncheckedUpdateWithoutBusinessDetailsInput>
  }

  export type BusinessAddressUpdateManyWithWhereWithoutBusinessDetailsInput = {
    where: BusinessAddressScalarWhereInput
    data: XOR<BusinessAddressUpdateManyMutationInput, BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsInput>
  }

  export type BusinessAddressScalarWhereInput = {
    AND?: BusinessAddressScalarWhereInput | BusinessAddressScalarWhereInput[]
    OR?: BusinessAddressScalarWhereInput[]
    NOT?: BusinessAddressScalarWhereInput | BusinessAddressScalarWhereInput[]
    id?: StringFilter<"BusinessAddress"> | string
    businessDetailsId?: StringNullableFilter<"BusinessAddress"> | string | null
    createdAt?: DateTimeFilter<"BusinessAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessAddress"> | Date | string | null
    updatedAt?: DateTimeFilter<"BusinessAddress"> | Date | string
    order?: IntNullableFilter<"BusinessAddress"> | number | null
    street?: StringFilter<"BusinessAddress"> | string
    city?: StringFilter<"BusinessAddress"> | string
    country?: StringFilter<"BusinessAddress"> | string
    pincode?: StringFilter<"BusinessAddress"> | string
    state?: StringFilter<"BusinessAddress"> | string
  }

  export type BusinessCreateWithoutBusinessSupportingDocumentsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactCreateNestedManyWithoutBusinessInput
    subscription?: BusinessSubscriptionCreateNestedOneWithoutBusinessesInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
    bookings?: BookingCreateNestedManyWithoutBusinessInput
    reviews?: ReviewCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutBusinessSupportingDocumentsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBusinessInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutBusinessSupportingDocumentsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutBusinessSupportingDocumentsInput, BusinessUncheckedCreateWithoutBusinessSupportingDocumentsInput>
  }

  export type BusinessUpsertWithoutBusinessSupportingDocumentsInput = {
    update: XOR<BusinessUpdateWithoutBusinessSupportingDocumentsInput, BusinessUncheckedUpdateWithoutBusinessSupportingDocumentsInput>
    create: XOR<BusinessCreateWithoutBusinessSupportingDocumentsInput, BusinessUncheckedCreateWithoutBusinessSupportingDocumentsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutBusinessSupportingDocumentsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutBusinessSupportingDocumentsInput, BusinessUncheckedUpdateWithoutBusinessSupportingDocumentsInput>
  }

  export type BusinessUpdateWithoutBusinessSupportingDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput
    subscription?: BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutBusinessSupportingDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessDetailsCreateWithoutImagesInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutImagesInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutImagesInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutImagesInput, BusinessDetailsUncheckedCreateWithoutImagesInput>
  }

  export type BusinessDetailsUpsertWithoutImagesInput = {
    update: XOR<BusinessDetailsUpdateWithoutImagesInput, BusinessDetailsUncheckedUpdateWithoutImagesInput>
    create: XOR<BusinessDetailsCreateWithoutImagesInput, BusinessDetailsUncheckedCreateWithoutImagesInput>
    where?: BusinessDetailsWhereInput
  }

  export type BusinessDetailsUpdateToOneWithWhereWithoutImagesInput = {
    where?: BusinessDetailsWhereInput
    data: XOR<BusinessDetailsUpdateWithoutImagesInput, BusinessDetailsUncheckedUpdateWithoutImagesInput>
  }

  export type BusinessDetailsUpdateWithoutImagesInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsCreateWithoutWebsitesInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutWebsitesInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutWebsitesInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutWebsitesInput, BusinessDetailsUncheckedCreateWithoutWebsitesInput>
  }

  export type BusinessDetailsUpsertWithoutWebsitesInput = {
    update: XOR<BusinessDetailsUpdateWithoutWebsitesInput, BusinessDetailsUncheckedUpdateWithoutWebsitesInput>
    create: XOR<BusinessDetailsCreateWithoutWebsitesInput, BusinessDetailsUncheckedCreateWithoutWebsitesInput>
    where?: BusinessDetailsWhereInput
  }

  export type BusinessDetailsUpdateToOneWithWhereWithoutWebsitesInput = {
    where?: BusinessDetailsWhereInput
    data: XOR<BusinessDetailsUpdateWithoutWebsitesInput, BusinessDetailsUncheckedUpdateWithoutWebsitesInput>
  }

  export type BusinessDetailsUpdateWithoutWebsitesInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsCreateWithoutLanguageInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutLanguageInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutLanguageInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutLanguageInput, BusinessDetailsUncheckedCreateWithoutLanguageInput>
  }

  export type BusinessDetailsUpsertWithWhereUniqueWithoutLanguageInput = {
    where: BusinessDetailsWhereUniqueInput
    update: XOR<BusinessDetailsUpdateWithoutLanguageInput, BusinessDetailsUncheckedUpdateWithoutLanguageInput>
    create: XOR<BusinessDetailsCreateWithoutLanguageInput, BusinessDetailsUncheckedCreateWithoutLanguageInput>
  }

  export type BusinessDetailsUpdateWithWhereUniqueWithoutLanguageInput = {
    where: BusinessDetailsWhereUniqueInput
    data: XOR<BusinessDetailsUpdateWithoutLanguageInput, BusinessDetailsUncheckedUpdateWithoutLanguageInput>
  }

  export type BusinessDetailsUpdateManyWithWhereWithoutLanguageInput = {
    where: BusinessDetailsScalarWhereInput
    data: XOR<BusinessDetailsUpdateManyMutationInput, BusinessDetailsUncheckedUpdateManyWithoutLanguageInput>
  }

  export type BusinessDetailsScalarWhereInput = {
    AND?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
    OR?: BusinessDetailsScalarWhereInput[]
    NOT?: BusinessDetailsScalarWhereInput | BusinessDetailsScalarWhereInput[]
    id?: StringFilter<"BusinessDetails"> | string
    registrationNumber?: StringNullableFilter<"BusinessDetails"> | string | null
    license?: StringNullableFilter<"BusinessDetails"> | string | null
    experience?: IntNullableFilter<"BusinessDetails"> | number | null
    teamSize?: IntNullableFilter<"BusinessDetails"> | number | null
    description?: StringNullableFilter<"BusinessDetails"> | string | null
    latitude?: FloatNullableFilter<"BusinessDetails"> | number | null
    longitude?: FloatNullableFilter<"BusinessDetails"> | number | null
    degree?: StringNullableListFilter<"BusinessDetails">
    gstNumber?: StringNullableFilter<"BusinessDetails"> | string | null
    categoryId?: StringNullableFilter<"BusinessDetails"> | string | null
    logo?: StringNullableFilter<"BusinessDetails"> | string | null
    createdAt?: DateTimeFilter<"BusinessDetails"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessDetails"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BusinessDetails"> | Date | string | null
  }

  export type BusinessDetailsCreateWithoutProficiencyInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutProficiencyInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutProficiencyInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutProficiencyInput, BusinessDetailsUncheckedCreateWithoutProficiencyInput>
  }

  export type BusinessDetailsUpsertWithWhereUniqueWithoutProficiencyInput = {
    where: BusinessDetailsWhereUniqueInput
    update: XOR<BusinessDetailsUpdateWithoutProficiencyInput, BusinessDetailsUncheckedUpdateWithoutProficiencyInput>
    create: XOR<BusinessDetailsCreateWithoutProficiencyInput, BusinessDetailsUncheckedCreateWithoutProficiencyInput>
  }

  export type BusinessDetailsUpdateWithWhereUniqueWithoutProficiencyInput = {
    where: BusinessDetailsWhereUniqueInput
    data: XOR<BusinessDetailsUpdateWithoutProficiencyInput, BusinessDetailsUncheckedUpdateWithoutProficiencyInput>
  }

  export type BusinessDetailsUpdateManyWithWhereWithoutProficiencyInput = {
    where: BusinessDetailsScalarWhereInput
    data: XOR<BusinessDetailsUpdateManyMutationInput, BusinessDetailsUncheckedUpdateManyWithoutProficiencyInput>
  }

  export type BusinessDetailsCreateWithoutCourtInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutCourtInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutCourtInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutCourtInput, BusinessDetailsUncheckedCreateWithoutCourtInput>
  }

  export type BusinessDetailsUpsertWithWhereUniqueWithoutCourtInput = {
    where: BusinessDetailsWhereUniqueInput
    update: XOR<BusinessDetailsUpdateWithoutCourtInput, BusinessDetailsUncheckedUpdateWithoutCourtInput>
    create: XOR<BusinessDetailsCreateWithoutCourtInput, BusinessDetailsUncheckedCreateWithoutCourtInput>
  }

  export type BusinessDetailsUpdateWithWhereUniqueWithoutCourtInput = {
    where: BusinessDetailsWhereUniqueInput
    data: XOR<BusinessDetailsUpdateWithoutCourtInput, BusinessDetailsUncheckedUpdateWithoutCourtInput>
  }

  export type BusinessDetailsUpdateManyWithWhereWithoutCourtInput = {
    where: BusinessDetailsScalarWhereInput
    data: XOR<BusinessDetailsUpdateManyMutationInput, BusinessDetailsUncheckedUpdateManyWithoutCourtInput>
  }

  export type BusinessDetailsCreateWithoutCategoryInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutCategoryInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    tags?: TagUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutCategoryInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutCategoryInput, BusinessDetailsUncheckedCreateWithoutCategoryInput>
  }

  export type BusinessDetailsCreateManyCategoryInputEnvelope = {
    data: BusinessDetailsCreateManyCategoryInput | BusinessDetailsCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BusinessDetailsUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BusinessDetailsWhereUniqueInput
    update: XOR<BusinessDetailsUpdateWithoutCategoryInput, BusinessDetailsUncheckedUpdateWithoutCategoryInput>
    create: XOR<BusinessDetailsCreateWithoutCategoryInput, BusinessDetailsUncheckedCreateWithoutCategoryInput>
  }

  export type BusinessDetailsUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BusinessDetailsWhereUniqueInput
    data: XOR<BusinessDetailsUpdateWithoutCategoryInput, BusinessDetailsUncheckedUpdateWithoutCategoryInput>
  }

  export type BusinessDetailsUpdateManyWithWhereWithoutCategoryInput = {
    where: BusinessDetailsScalarWhereInput
    data: XOR<BusinessDetailsUpdateManyMutationInput, BusinessDetailsUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BusinessDetailsCreateWithoutTagsInput = {
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutBusinessDetailsInput
    websites?: BusinessWebsiteCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtCreateNestedManyWithoutBusinessDetailsInput
    category?: CategoryCreateNestedOneWithoutBusinessesDetailsInput
    addresses?: BusinessAddressCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsUncheckedCreateWithoutTagsInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    categoryId?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    websites?: BusinessWebsiteUncheckedCreateNestedManyWithoutBusinessDetailsInput
    images?: BusinessImageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    language?: LanguageUncheckedCreateNestedManyWithoutBusinessDetailsInput
    proficiency?: ProficiencyUncheckedCreateNestedManyWithoutBusinessDetailsInput
    court?: CourtUncheckedCreateNestedManyWithoutBusinessDetailsInput
    addresses?: BusinessAddressUncheckedCreateNestedManyWithoutBusinessDetailsInput
  }

  export type BusinessDetailsCreateOrConnectWithoutTagsInput = {
    where: BusinessDetailsWhereUniqueInput
    create: XOR<BusinessDetailsCreateWithoutTagsInput, BusinessDetailsUncheckedCreateWithoutTagsInput>
  }

  export type BusinessDetailsUpsertWithWhereUniqueWithoutTagsInput = {
    where: BusinessDetailsWhereUniqueInput
    update: XOR<BusinessDetailsUpdateWithoutTagsInput, BusinessDetailsUncheckedUpdateWithoutTagsInput>
    create: XOR<BusinessDetailsCreateWithoutTagsInput, BusinessDetailsUncheckedCreateWithoutTagsInput>
  }

  export type BusinessDetailsUpdateWithWhereUniqueWithoutTagsInput = {
    where: BusinessDetailsWhereUniqueInput
    data: XOR<BusinessDetailsUpdateWithoutTagsInput, BusinessDetailsUncheckedUpdateWithoutTagsInput>
  }

  export type BusinessDetailsUpdateManyWithWhereWithoutTagsInput = {
    where: BusinessDetailsScalarWhereInput
    data: XOR<BusinessDetailsUpdateManyMutationInput, BusinessDetailsUncheckedUpdateManyWithoutTagsInput>
  }

  export type BusinessCreateWithoutReviewsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactCreateNestedManyWithoutBusinessInput
    subscription?: BusinessSubscriptionCreateNestedOneWithoutBusinessesInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
    bookings?: BookingCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutReviewsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutReviewsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutReviewsInput, BusinessUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactCreateNestedManyWithoutUserInput
    addresses?: UserAddressCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type BusinessUpsertWithoutReviewsInput = {
    update: XOR<BusinessUpdateWithoutReviewsInput, BusinessUncheckedUpdateWithoutReviewsInput>
    create: XOR<BusinessCreateWithoutReviewsInput, BusinessUncheckedCreateWithoutReviewsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutReviewsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutReviewsInput, BusinessUncheckedUpdateWithoutReviewsInput>
  }

  export type BusinessUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput
    subscription?: BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactCreateNestedManyWithoutBusinessInput
    subscription?: BusinessSubscriptionCreateNestedOneWithoutBusinessesInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
    reviews?: ReviewCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutBookingsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutBookingsInput, BusinessUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactCreateNestedManyWithoutUserInput
    addresses?: UserAddressCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type BusinessUpsertWithoutBookingsInput = {
    update: XOR<BusinessUpdateWithoutBookingsInput, BusinessUncheckedUpdateWithoutBookingsInput>
    create: XOR<BusinessCreateWithoutBookingsInput, BusinessUncheckedCreateWithoutBookingsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutBookingsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutBookingsInput, BusinessUncheckedUpdateWithoutBookingsInput>
  }

  export type BusinessUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput
    subscription?: BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessCreateWithoutChatsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactCreateNestedManyWithoutBusinessInput
    subscription?: BusinessSubscriptionCreateNestedOneWithoutBusinessesInput
    bookings?: BookingCreateNestedManyWithoutBusinessInput
    reviews?: ReviewCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutChatsInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
    primaryContacts?: BusinessPrimaryContactUncheckedCreateNestedManyWithoutBusinessInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBusinessInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBusinessInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedCreateNestedManyWithoutBusinessInput
    businessDetails?: BusinessDetailsUncheckedCreateNestedOneWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutChatsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
  }

  export type UserCreateWithoutChatsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactCreateNestedManyWithoutUserInput
    addresses?: UserAddressCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutChatsInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionId?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
  }

  export type MessageCreateWithoutChatsInput = {
    id?: string
    content: string
    senderType: $Enums.SenderType
    createdAt?: Date | string
    readAt?: Date | string | null
    fileType?: string | null
    fileUrl?: string | null
  }

  export type MessageUncheckedCreateWithoutChatsInput = {
    id?: string
    content: string
    senderType: $Enums.SenderType
    createdAt?: Date | string
    readAt?: Date | string | null
    fileType?: string | null
    fileUrl?: string | null
  }

  export type MessageCreateOrConnectWithoutChatsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatsInput, MessageUncheckedCreateWithoutChatsInput>
  }

  export type MessageCreateManyChatsInputEnvelope = {
    data: MessageCreateManyChatsInput | MessageCreateManyChatsInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutChatsInput = {
    update: XOR<BusinessUpdateWithoutChatsInput, BusinessUncheckedUpdateWithoutChatsInput>
    create: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutChatsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutChatsInput, BusinessUncheckedUpdateWithoutChatsInput>
  }

  export type BusinessUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput
    subscription?: BusinessSubscriptionUpdateOneWithoutBusinessesNestedInput
    bookings?: BookingUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput
  }

  export type UserUpsertWithoutChatsInput = {
    update: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutChatsInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatsInput, MessageUncheckedUpdateWithoutChatsInput>
    create: XOR<MessageCreateWithoutChatsInput, MessageUncheckedCreateWithoutChatsInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatsInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatsInput, MessageUncheckedUpdateWithoutChatsInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatsInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatsInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    chatId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    fileType?: StringNullableFilter<"Message"> | string | null
    fileUrl?: StringNullableFilter<"Message"> | string | null
  }

  export type ChatCreateWithoutMessageInput = {
    id?: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    Business: BusinessCreateNestedOneWithoutChatsInput
    User: UserCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    businessId: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type ChatCreateOrConnectWithoutMessageInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessageInput, ChatUncheckedCreateWithoutMessageInput>
  }

  export type ChatUpsertWithoutMessageInput = {
    update: XOR<ChatUpdateWithoutMessageInput, ChatUncheckedUpdateWithoutMessageInput>
    create: XOR<ChatCreateWithoutMessageInput, ChatUncheckedCreateWithoutMessageInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessageInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessageInput, ChatUncheckedUpdateWithoutMessageInput>
  }

  export type ChatUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Business?: BusinessUpdateOneRequiredWithoutChatsNestedInput
    User?: UserUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CityCreateWithoutPincodesInput = {
    id?: string
    name: string
    slug?: string | null
    state: StateCreateNestedOneWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutPincodesInput = {
    id?: string
    name: string
    slug?: string | null
    stateId: string
  }

  export type CityCreateOrConnectWithoutPincodesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutPincodesInput, CityUncheckedCreateWithoutPincodesInput>
  }

  export type CityUpsertWithoutPincodesInput = {
    update: XOR<CityUpdateWithoutPincodesInput, CityUncheckedUpdateWithoutPincodesInput>
    create: XOR<CityCreateWithoutPincodesInput, CityUncheckedCreateWithoutPincodesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutPincodesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutPincodesInput, CityUncheckedUpdateWithoutPincodesInput>
  }

  export type CityUpdateWithoutPincodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutPincodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
  }

  export type StateCreateWithoutCitiesInput = {
    id?: string
    name: string
    slug?: string | null
    country: CountryCreateNestedOneWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    slug?: string | null
    countryId: string
  }

  export type StateCreateOrConnectWithoutCitiesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type PincodeCreateWithoutCityInput = {
    id?: string
    code: string
    slug?: string | null
  }

  export type PincodeUncheckedCreateWithoutCityInput = {
    id?: string
    code: string
    slug?: string | null
  }

  export type PincodeCreateOrConnectWithoutCityInput = {
    where: PincodeWhereUniqueInput
    create: XOR<PincodeCreateWithoutCityInput, PincodeUncheckedCreateWithoutCityInput>
  }

  export type PincodeCreateManyCityInputEnvelope = {
    data: PincodeCreateManyCityInput | PincodeCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type StateUpsertWithoutCitiesInput = {
    update: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    where?: StateWhereInput
  }

  export type StateUpdateToOneWithWhereWithoutCitiesInput = {
    where?: StateWhereInput
    data: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type StateUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
  }

  export type PincodeUpsertWithWhereUniqueWithoutCityInput = {
    where: PincodeWhereUniqueInput
    update: XOR<PincodeUpdateWithoutCityInput, PincodeUncheckedUpdateWithoutCityInput>
    create: XOR<PincodeCreateWithoutCityInput, PincodeUncheckedCreateWithoutCityInput>
  }

  export type PincodeUpdateWithWhereUniqueWithoutCityInput = {
    where: PincodeWhereUniqueInput
    data: XOR<PincodeUpdateWithoutCityInput, PincodeUncheckedUpdateWithoutCityInput>
  }

  export type PincodeUpdateManyWithWhereWithoutCityInput = {
    where: PincodeScalarWhereInput
    data: XOR<PincodeUpdateManyMutationInput, PincodeUncheckedUpdateManyWithoutCityInput>
  }

  export type PincodeScalarWhereInput = {
    AND?: PincodeScalarWhereInput | PincodeScalarWhereInput[]
    OR?: PincodeScalarWhereInput[]
    NOT?: PincodeScalarWhereInput | PincodeScalarWhereInput[]
    id?: StringFilter<"Pincode"> | string
    code?: StringFilter<"Pincode"> | string
    slug?: StringNullableFilter<"Pincode"> | string | null
    cityId?: StringFilter<"Pincode"> | string
  }

  export type CountryCreateWithoutStateInput = {
    id?: string
    name: string
    slug?: string | null
  }

  export type CountryUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    slug?: string | null
  }

  export type CountryCreateOrConnectWithoutStateInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
  }

  export type CityCreateWithoutStateInput = {
    id?: string
    name: string
    slug?: string | null
    pincodes?: PincodeCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    slug?: string | null
    pincodes?: PincodeUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutStateInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityCreateManyStateInputEnvelope = {
    data: CityCreateManyStateInput | CityCreateManyStateInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutStateInput = {
    update: XOR<CountryUpdateWithoutStateInput, CountryUncheckedUpdateWithoutStateInput>
    create: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutStateInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutStateInput, CountryUncheckedUpdateWithoutStateInput>
  }

  export type CountryUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CityUpsertWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityUpdateWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithWhereWithoutStateInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutStateInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    slug?: StringNullableFilter<"City"> | string | null
    stateId?: StringFilter<"City"> | string
  }

  export type StateCreateWithoutCountryInput = {
    id?: string
    name: string
    slug?: string | null
    cities?: CityCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    slug?: string | null
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCountryInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateCreateManyCountryInputEnvelope = {
    data: StateCreateManyCountryInput | StateCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type StateUpsertWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    update: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateUpdateWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    data: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
  }

  export type StateUpdateManyWithWhereWithoutCountryInput = {
    where: StateScalarWhereInput
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyWithoutCountryInput>
  }

  export type StateScalarWhereInput = {
    AND?: StateScalarWhereInput | StateScalarWhereInput[]
    OR?: StateScalarWhereInput[]
    NOT?: StateScalarWhereInput | StateScalarWhereInput[]
    id?: StringFilter<"State"> | string
    name?: StringFilter<"State"> | string
    slug?: StringNullableFilter<"State"> | string | null
    countryId?: StringFilter<"State"> | string
  }

  export type UserCreateManySubscriptionInput = {
    id?: string
    name: string
    slug?: string | null
    password?: string | null
    salt?: string | null
    hideDetails?: boolean
    avatar?: string | null
    subscriptionExpire?: Date | string | null
    paymentVerification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    hideDetails?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactCreateManyUserInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAddressCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    date: Date | string
    businessId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ChatCreateManyUserInput = {
    id?: string
    businessId: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    rating: number
    comment?: string | null
    businessId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Business?: BusinessUpdateOneRequiredWithoutChatsNestedInput
    Message?: MessageUpdateManyWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Message?: MessageUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCreateManySubscriptionInput = {
    id?: string
    name?: string | null
    slug?: string | null
    additionalContacts?: BusinessCreateadditionalContactsInput | string[]
    password?: string | null
    salt?: string | null
    isBusinessVerified?: boolean
    type?: $Enums.BusinessType
    subscriptionExpire?: Date | string | null
    averageRating?: number | null
    reviewCount?: number
    isListed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    paymentVerification?: boolean
    price?: number | null
  }

  export type BusinessUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUpdateManyWithoutBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    primaryContacts?: BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBusinessNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBusinessNestedInput
    businessSupportingDocuments?: BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessNestedInput
    businessDetails?: BusinessDetailsUncheckedUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    additionalContacts?: BusinessUpdateadditionalContactsInput | string[]
    password?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessVerified?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBusinessTypeFieldUpdateOperationsInput | $Enums.BusinessType
    subscriptionExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    isListed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentVerification?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BusinessPrimaryContactCreateManyBusinessInput = {
    id?: string
    type: $Enums.ContactType
    value: string
    isVerified?: boolean
    isPrimary?: boolean
    order?: number | null
    verifiedAt?: Date | string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChatCreateManyBusinessInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type BookingCreateManyBusinessInput = {
    id?: string
    date: Date | string
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ReviewCreateManyBusinessInput = {
    id?: string
    rating: number
    comment?: string | null
    userId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BusinessSupportingDocumentsCreateManyBusinessInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessPrimaryContactUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessPrimaryContactUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessPrimaryContactUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    value?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutChatsNestedInput
    Message?: MessageUpdateManyWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Message?: MessageUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessSupportingDocumentsUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessSupportingDocumentsUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessSupportingDocumentsUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessWebsiteCreateManyBusinessDetailsInput = {
    id?: string
    type: string
    url: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BusinessImageCreateManyBusinessDetailsInput = {
    id?: string
    url: string
    order?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type BusinessAddressCreateManyBusinessDetailsInput = {
    id?: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    updatedAt?: Date | string
    order?: number | null
    street: string
    city: string
    country: string
    pincode: string
    state: string
  }

  export type BusinessWebsiteUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessWebsiteUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessImageUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessImageUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessImageUncheckedUpdateManyWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProficiencyUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProficiencyUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProficiencyUncheckedUpdateManyWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtUncheckedUpdateManyWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessAddressUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessAddressUncheckedUpdateWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessDetailsUpdateWithoutLanguageInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessDetailsUpdateWithoutProficiencyInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutProficiencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutProficiencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessDetailsUpdateWithoutCourtInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessDetailsCreateManyCategoryInput = {
    id: string
    registrationNumber?: string | null
    license?: string | null
    experience?: number | null
    teamSize?: number | null
    description?: string | null
    latitude?: number | null
    longitude?: number | null
    degree?: BusinessDetailsCreatedegreeInput | string[]
    gstNumber?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BusinessDetailsUpdateWithoutCategoryInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    tags?: TagUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessDetailsUpdateWithoutTagsInput = {
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutBusinessDetailsNestedInput
    websites?: BusinessWebsiteUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUpdateManyWithoutBusinessDetailsNestedInput
    category?: CategoryUpdateOneWithoutBusinessesDetailsNestedInput
    addresses?: BusinessAddressUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    websites?: BusinessWebsiteUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    images?: BusinessImageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    language?: LanguageUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    proficiency?: ProficiencyUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    court?: CourtUncheckedUpdateManyWithoutBusinessDetailsNestedInput
    addresses?: BusinessAddressUncheckedUpdateManyWithoutBusinessDetailsNestedInput
  }

  export type BusinessDetailsUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    degree?: BusinessDetailsUpdatedegreeInput | string[]
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyChatsInput = {
    id?: string
    content: string
    senderType: $Enums.SenderType
    createdAt?: Date | string
    readAt?: Date | string | null
    fileType?: string | null
    fileUrl?: string | null
  }

  export type MessageUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PincodeCreateManyCityInput = {
    id?: string
    code: string
    slug?: string | null
  }

  export type PincodeUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PincodeUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PincodeUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CityCreateManyStateInput = {
    id?: string
    name: string
    slug?: string | null
  }

  export type CityUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    pincodes?: PincodeUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    pincodes?: PincodeUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StateCreateManyCountryInput = {
    id?: string
    name: string
    slug?: string | null
  }

  export type StateUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type UserSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type BusinessSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessCountOutputTypeDefaultArgs instead
     */
    export type BusinessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessDetailsCountOutputTypeDefaultArgs instead
     */
    export type BusinessDetailsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessDetailsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProficiencyCountOutputTypeDefaultArgs instead
     */
    export type ProficiencyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProficiencyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourtCountOutputTypeDefaultArgs instead
     */
    export type CourtCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourtCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatCountOutputTypeDefaultArgs instead
     */
    export type ChatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StateCountOutputTypeDefaultArgs instead
     */
    export type StateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryCountOutputTypeDefaultArgs instead
     */
    export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSubscriptionDefaultArgs instead
     */
    export type UserSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserContactDefaultArgs instead
     */
    export type UserContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAddressDefaultArgs instead
     */
    export type UserAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessSubscriptionDefaultArgs instead
     */
    export type BusinessSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessDefaultArgs instead
     */
    export type BusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessPrimaryContactDefaultArgs instead
     */
    export type BusinessPrimaryContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessPrimaryContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessAddressDefaultArgs instead
     */
    export type BusinessAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessAddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessDetailsDefaultArgs instead
     */
    export type BusinessDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessSupportingDocumentsDefaultArgs instead
     */
    export type BusinessSupportingDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessSupportingDocumentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessImageDefaultArgs instead
     */
    export type BusinessImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessWebsiteDefaultArgs instead
     */
    export type BusinessWebsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessWebsiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageDefaultArgs instead
     */
    export type LanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProficiencyDefaultArgs instead
     */
    export type ProficiencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProficiencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourtDefaultArgs instead
     */
    export type CourtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourtDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatDefaultArgs instead
     */
    export type ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PincodeDefaultArgs instead
     */
    export type PincodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PincodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StateDefaultArgs instead
     */
    export type StateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}